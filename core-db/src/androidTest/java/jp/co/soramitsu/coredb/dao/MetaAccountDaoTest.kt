package jp.co.soramitsu.coredb.dao

import android.database.sqlite.SQLiteConstraintException
import androidx.test.ext.junit.runners.AndroidJUnit4
import jp.co.soramitsu.core.models.CryptoType
import jp.co.soramitsu.coredb.AppDatabase
import jp.co.soramitsu.coredb.model.chain.ChainAccountLocal
import jp.co.soramitsu.coredb.model.chain.MetaAccountLocal
import kotlinx.coroutines.runBlocking
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNotEquals
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

private const val CHAIN_ID = "1"

@RunWith(AndroidJUnit4::class)
class MetaAccountDaoTest : DaoTest<MetaAccountDao>(AppDatabase::metaAccountDao) {

    private val chainDao by lazy {
        db.chainDao()
    }

    @Before
    fun insertChain() = runBlocking {
        chainDao.addChain(createTestChain(id = CHAIN_ID))
    }

    @Test
    fun shouldInsertMetaAccount() {
        runBlocking {
            dao.insertMetaAccount(testMetaAccount())
            dao.insertMetaAccount(testMetaAccount())

            val accountsFromDb = dao.getMetaAccounts()

            assertEquals(2, accountsFromDb.size)

            val isIdAutoGenerated = accountsFromDb.withIndex().all { (index, account) ->
                account.id == index + 1L
            }

            assertTrue("Id should be autogenerated", isIdAutoGenerated)
        }
    }

    @Test
    fun shouldInsertAndRetrieveChainAccounts() {
        runBlocking {
            val metaId = dao.insertMetaAccount(testMetaAccount())

            assertNotEquals(-1, metaId)

            dao.insertChainAccount(chainAccount(metaId))

            val joinedMetaAccountInfo = dao.getJoinedMetaAccountInfo(metaId)

            assertEquals(1, joinedMetaAccountInfo.chainAccounts.size)
        }
    }

    @Test(expected = SQLiteConstraintException::class)
    fun shouldForbidInsertingSameChainAccounts() {
        runBlocking {
            val metaId = dao.insertMetaAccount(testMetaAccount())

            dao.insertChainAccount(chainAccount(metaId))
            dao.insertChainAccount(chainAccount(metaId))
        }
    }

    private fun testMetaAccount() = MetaAccountLocal(
        substratePublicKey = byteArrayOf(),
        substrateCryptoType = CryptoType.SR25519,
        ethereumPublicKey = null,
        name = "Test",
        isSelected = false,
        substrateAccountId = byteArrayOf(),
        ethereumAddress = null,
        position = 0,
        googleBackupAddress = null,
        isBackedUp = false
    )

    private fun chainAccount(metaId: Long) = ChainAccountLocal(
        metaId = metaId,
        chainId = CHAIN_ID,
        publicKey = byteArrayOf(),
        cryptoType = CryptoType.SR25519,
        accountId = byteArrayOf(),
        name = ""
    )
}
