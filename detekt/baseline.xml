<?xml version="1.0" ?>
<SmellBaseline>
  <ManuallySuppressedIssues></ManuallySuppressedIssues>
  <CurrentIssues>
    <ID>BlockCommentInitialStarAlignment:PreferencesImpl.kt$PreferencesImpl$/* SharedPreferencesImpl stores listeners in a WeakHashMap, meaning listener is subject to GC if it is not kept anywhere else. This is not a problem until a stringFlow() call is followed later by shareIn() or stateIn(), which cause listener to be GC-ed (TODO - research why). To avoid that, store strong references to listeners until corresponding flow is closed. */</ID>
    <ID>BracesOnIfStatements:MetaAccount.kt$MetaAccount$if</ID>
    <ID>BracesOnIfStatements:StakingPoolSharedState.kt$EditPoolFlowState$if</ID>
    <ID>CastToNullableType:Constants.kt$as</ID>
    <ID>ClassOrdering:AccountDataSource.kt$AccountDataSource$// TODO for compatibility only val selectedAccountMapping: Flow&lt;Map&lt;ChainId, Account?&gt;&gt;</ID>
    <ID>ClassOrdering:AccountDataSourceImpl.kt$AccountDataSourceImpl$private fun migrateIfNeeded(migration: AccountDataMigration)</ID>
    <ID>ClassOrdering:AccountDetailsFragment.kt$AccountDetailsFragment$Companion</ID>
    <ID>ClassOrdering:AccountsForExportFragment.kt$AccountsForExportFragment$Companion</ID>
    <ID>ClassOrdering:AddNodeFragment.kt$AddNodeFragment$Companion</ID>
    <ID>ClassOrdering:AddNodeViewModel.kt$AddNodeViewModel$Companion</ID>
    <ID>ClassOrdering:AddressHistoryContent.kt$AddressHistoryViewState$val isEmpty: Boolean get() = recentAddresses.isEmpty() &amp;&amp; addressBookAddresses.isEmpty()</ID>
    <ID>ClassOrdering:AddressHistoryFragment.kt$AddressHistoryFragment$Companion</ID>
    <ID>ClassOrdering:AddressHistoryViewModel.kt$AddressHistoryViewModel$Companion</ID>
    <ID>ClassOrdering:AddressIconGenerator.kt$AddressIconGenerator$Companion</ID>
    <ID>ClassOrdering:AlertFragment.kt$AlertFragment$Companion</ID>
    <ID>ClassOrdering:AlertsInteractor.kt$AlertsInteractor$private val alertProducers = listOf( ::produceChangeValidatorsAlert, ::produceRedeemableAlert, ::produceMinStakeAlert, ::produceWaitingNextEraAlert, ::produceSetValidatorsAlert )</ID>
    <ID>ClassOrdering:AppDatabase.kt$AppDatabase$Companion</ID>
    <ID>ClassOrdering:Asset.kt$Asset$Companion</ID>
    <ID>ClassOrdering:AssetLocal.kt$AssetLocal$val totalInPlanks: BigInteger get() = freeInPlanks.orZero() + reservedInPlanks.orZero()</ID>
    <ID>ClassOrdering:AssetSelectFragment.kt$AssetSelectFragment$Companion</ID>
    <ID>ClassOrdering:AssetSelectorMixin.kt$AssetSelectorMixin$val selectedAssetModelFlow: Flow&lt;AssetModel&gt;</ID>
    <ID>ClassOrdering:BackupMnemonicFragment.kt$BackupMnemonicFragment$Companion</ID>
    <ID>ClassOrdering:BackupWalletDialog.kt$BackupWalletDialog$Companion</ID>
    <ID>ClassOrdering:BalanceDetailFragment.kt$BalanceDetailFragment$Companion</ID>
    <ID>ClassOrdering:BalanceDetailViewModel.kt$BalanceDetailViewModel$Companion</ID>
    <ID>ClassOrdering:BalanceDetailViewModel.kt$BalanceDetailViewModel$private fun isBuyEnabled(): Boolean</ID>
    <ID>ClassOrdering:BalanceListViewModel.kt$BalanceListViewModel$// private val soraCardState = combine( // interactor.observeIsShowSoraCard(), // soraCardInteractor.subscribeSoraCardInfo() // ) { isShow, soraCardInfo -&gt; // val kycStatus = soraCardInfo?.kycStatus?.let(::mapKycStatus) // SoraCardItemViewState(kycStatus, soraCardInfo, null, isShow) // } private val soraCardState = flowOf(SoraCardItemViewState())</ID>
    <ID>ClassOrdering:BalanceListViewModel.kt$BalanceListViewModel$init { updateSoraCardStatus() router.chainSelectorPayloadFlow.map { chainId -&gt; val walletId = interactor.getSelectedMetaAccount().id interactor.saveChainId(walletId, chainId) selectedChainId.value = chainId }.launchIn(this) interactor.selectedMetaAccountFlow().map { wallet -&gt; selectedChainId.value = interactor.getSavedChainId(wallet.id) }.launchIn(this) if (!interactor.isShowGetSoraCard()) { interactor.decreaseSoraCardHiddenSessions() } }</ID>
    <ID>ClassOrdering:BalanceListViewModel.kt$BalanceListViewModel$val state = combine( assetStates, assetTypeSelectorState, balanceFlow, selectedChainId, soraCardState ) { assetsListItemStates: List&lt;AssetListItemViewState&gt;, multiToggleButtonState: MultiToggleButtonState&lt;AssetType&gt;, balanceModel: BalanceModel, selectedChainId: ChainId?, soraCardState: SoraCardItemViewState -&gt; val selectedChainAddress = selectedChainId?.let { currentAccountAddress(chainId = it) }.orEmpty() val balanceState = AssetBalanceViewState( transferableBalance = balanceModel.totalTransferableBalance?.formatFiat(balanceModel.fiatSymbol).orEmpty(), address = selectedChainAddress, changeViewState = ChangeBalanceViewState( percentChange = balanceModel.transferableRate?.formatAsChange().orEmpty(), fiatChange = balanceModel.totalTransferableBalanceChange.abs().formatFiat(balanceModel.fiatSymbol) ) ) val hasNetworkIssues = assetsListItemStates.any { !it.hasAccount || it.hasNetworkIssue } WalletState( assets = assetsListItemStates, multiToggleButtonState = multiToggleButtonState, balance = balanceState, hasNetworkIssues = hasNetworkIssues, soraCardState = soraCardState ) }.stateIn(scope = this, started = SharingStarted.Eagerly, initialValue = WalletState.default)</ID>
    <ID>ClassOrdering:BalanceListViewModel.kt$BalanceListViewModel$val toolbarState = combine(currentAddressModelFlow(), selectedChainItemFlow) { addressModel, chain -&gt; LoadingState.Loaded( MainToolbarViewState( title = addressModel.nameOrAddress, homeIconState = ToolbarHomeIconState(walletIcon = addressModel.image), selectorViewState = ChainSelectorViewState(chain?.title, chain?.id) ) ) }.stateIn(scope = this, started = SharingStarted.Eagerly, initialValue = LoadingState.Loading())</ID>
    <ID>ClassOrdering:BaseBottomSheetDialogFragment.kt$BaseBottomSheetDialogFragment$val Int.dp: Int get() = dp(requireContext())</ID>
    <ID>ClassOrdering:BaseConfirmViewModel.kt$BaseConfirmViewModel$private val defaultFeeState get() = TitleValueViewState( resourceManager.getString(R.string.common_network_fee), null, null )</ID>
    <ID>ClassOrdering:BaseConfirmViewModel.kt$BaseConfirmViewModel$private val defaultScreenState get() = ConfirmScreenViewState( toolbarViewState, amountViewState.value.orEmpty(), listOf( defaultAddressViewState, amountViewState, defaultFeeState ), GradientIconState.Remote(asset.token.configuration.iconUrl, asset.token.configuration.color), titleRes, additionalMessageRes, isLoading = false )</ID>
    <ID>ClassOrdering:BaseFragment.kt$BaseFragment$val Int.dp: Int get() = dp(requireContext())</ID>
    <ID>ClassOrdering:BaseViewModel.kt$BaseViewModel$override val coroutineContext: CoroutineContext get() = viewModelScope.coroutineContext</ID>
    <ID>ClassOrdering:BeaconFragment.kt$BeaconFragment$Companion</ID>
    <ID>ClassOrdering:BeaconInteractor.kt$BeaconInteractor$Companion</ID>
    <ID>ClassOrdering:BifrostApi.kt$BifrostApi$@POST("/") suspend fun getAccountByReferralCode(@Body body: BifrostReferralCheckRequest): SubQueryResponse&lt;GetAccountByReferralCodeResponse&gt;</ID>
    <ID>ClassOrdering:BlockExplorerUrlBuilder.kt$BlockExplorerUrlBuilder$init { if (!baseUrl.contains("{type}") || !baseUrl.contains("{value}")) { throw IllegalArgumentException("Wrong baseUrl format") } }</ID>
    <ID>ClassOrdering:BlockNumberUpdater.kt$BlockNumberUpdater$override val requiredModules = listOf(Modules.SYSTEM)</ID>
    <ID>ClassOrdering:ChainSelectFragment.kt$ChainSelectFragment$Companion</ID>
    <ID>ClassOrdering:CollatorDetailsFragment.kt$CollatorDetailsFragment$Companion</ID>
    <ID>ClassOrdering:CollatorDetailsViewModel.kt$CollatorDetailsViewModel$private fun mapStatus(status: CandidateInfoStatus)</ID>
    <ID>ClassOrdering:ConfirmBondMoreFragment.kt$ConfirmBondMoreFragment$Companion</ID>
    <ID>ClassOrdering:ConfirmContributeFragment.kt$ConfirmContributeFragment$Companion</ID>
    <ID>ClassOrdering:ConfirmJoinPoolViewModel.kt$ConfirmJoinPoolViewModel$private val defaultFeeState get() = TitleValueViewState( resourceManager.getString(R.string.common_network_fee), null, null )</ID>
    <ID>ClassOrdering:ConfirmJoinPoolViewModel.kt$ConfirmJoinPoolViewModel$private val defaultScreenState get() = ConfirmJoinPoolScreenViewState( toolbarViewState, "... ${asset.token.configuration.symbol}", addressViewState, poolViewState, defaultFeeState, GradientIconState.Local(R.drawable.ic_vector), isLoading = false )</ID>
    <ID>ClassOrdering:ConfirmMnemonicFragment.kt$ConfirmMnemonicFragment$Companion</ID>
    <ID>ClassOrdering:ConfirmMnemonicFragment.kt$ConfirmMnemonicFragment$private val wordClickListener: (MnemonicWordView, String) -&gt; Unit = { mnemonicWordView, word -&gt; viewModel.addWordToConfirmMnemonic(word) binding.wordsMnemonicView.removeWordView(mnemonicWordView) val wordView = MnemonicWordView(activity!!).apply { setWord(word) setColorMode(MnemonicWordView.ColorMode.DARK) measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED) } binding.confirmationMnemonicView.populateWord(wordView) }</ID>
    <ID>ClassOrdering:ConfirmPayoutFragment.kt$ConfirmPayoutFragment$Companion</ID>
    <ID>ClassOrdering:ConfirmRebondFragment.kt$ConfirmRebondFragment$Companion</ID>
    <ID>ClassOrdering:ConfirmRewardDestinationFragment.kt$ConfirmRewardDestinationFragment$Companion</ID>
    <ID>ClassOrdering:ConfirmSendContent.kt$ConfirmSendViewState$val tableItems = listOf( fromInfoItem, toInfoItem, amountInfoItem, tipInfoItem, feeInfoItem ).mapNotNull { it }</ID>
    <ID>ClassOrdering:ConfirmSendFragment.kt$ConfirmSendFragment$Companion</ID>
    <ID>ClassOrdering:ConfirmSetControllerFragment.kt$ConfirmSetControllerFragment$Companion</ID>
    <ID>ClassOrdering:ConfirmUnbondFragment.kt$ConfirmUnbondFragment$Companion</ID>
    <ID>ClassOrdering:CreateAccountDialog.kt$CreateAccountDialog$Companion</ID>
    <ID>ClassOrdering:CreateAccountFragment.kt$CreateAccountFragment$Companion</ID>
    <ID>ClassOrdering:CreateBackupPasswordDialog.kt$CreateBackupPasswordDialog$Companion</ID>
    <ID>ClassOrdering:CreateContactFragment.kt$CreateContactFragment$Companion</ID>
    <ID>ClassOrdering:CreatePoolSetupViewModel.kt$CreatePoolSetupViewModel$Companion</ID>
    <ID>ClassOrdering:CrossChainConfirmContent.kt$CrossChainConfirmViewState$val tableItems = listOf( toInfoItem, originNetworkItem, destinationNetworkItem, tipInfoItem, originFeeInfoItem, destinationFeeInfoItem ).mapNotNull { it }</ID>
    <ID>ClassOrdering:CrossChainConfirmFragment.kt$CrossChainConfirmFragment$Companion</ID>
    <ID>ClassOrdering:CrossChainSetupFragment.kt$CrossChainSetupFragment$Companion</ID>
    <ID>ClassOrdering:CrossChainSetupViewModel.kt$CrossChainSetupViewModel$private val tipAmountFlow = combine(tipFlow, assetFlow) { tip: BigInteger?, asset: Asset? -&gt; tip?.let { asset?.token?.amountFromPlanks(it) } }</ID>
    <ID>ClassOrdering:CrossChainSetupViewModel.kt$CrossChainSetupViewModel$private val tipFlow = chainAssetsManager.originChainIdFlow.map { it?.let { walletConstants.tip(it) } }</ID>
    <ID>ClassOrdering:CrowdloanContributeFragment.kt$CrowdloanContributeFragment$Companion</ID>
    <ID>ClassOrdering:CrowdloanRouter.kt$CrowdloanRouter$fun openContribute(payload: ContributePayload)</ID>
    <ID>ClassOrdering:CustomContribute.kt$CustomContributeViewState$val applyActionState: Flow&lt;ApplyActionState&gt;</ID>
    <ID>ClassOrdering:CustomContributeFactory.kt$CustomContributeFactory$val submitter: CustomContributeSubmitter</ID>
    <ID>ClassOrdering:CustomContributeFragment.kt$CustomContributeFragment$Companion</ID>
    <ID>ClassOrdering:CustomContributeViewModel.kt$CustomContributeViewModel$val applyButtonState = MediatorLiveData&lt;Pair&lt;ApplyActionState, Boolean&gt;&gt;().apply { var isValidation = false var isApplying = false var state: ApplyActionState? = null var feeStatus: FeeStatus? = null fun handleUpdates() { state?.let { val inProgress = isValidation || isApplying || feeStatus == FeeStatus.Loading value = Pair(it, inProgress) } } addSource(applyButtonStateLD) { state = it handleUpdates() } addSource(_validationProgress) { isValidation = it if (!it) { // called false only in error case -&gt; need to stop applying too isApplying = false } handleUpdates() } addSource(_applyingInProgress) { isApplying = it handleUpdates() } addSource(feeLive) { feeStatus = it handleUpdates() } }</ID>
    <ID>ClassOrdering:CustomValidatorsSettingsFragment.kt$CustomValidatorsSettingsFragment$Companion</ID>
    <ID>ClassOrdering:DeviceVibrator.kt$DeviceVibrator$fun makeShortVibration()</ID>
    <ID>ClassOrdering:DotsProgressView.kt$DotsProgressView$Companion</ID>
    <ID>ClassOrdering:EditPoolViewModel.kt$EditPoolViewModel$Companion</ID>
    <ID>ClassOrdering:EncryptionUtil.kt$EncryptionUtil$Companion</ID>
    <ID>ClassOrdering:EnoughToPayFeesValidation.kt$EnoughToPayFeesValidation$override suspend fun validate(value: P): ValidationStatus&lt;E&gt;</ID>
    <ID>ClassOrdering:ErrorDialog.kt$ErrorDialog$Companion</ID>
    <ID>ClassOrdering:EstimateEarningView.kt$EstimateEarningView$val infoActions: View get() = binding.stakeMoreActions</ID>
    <ID>ClassOrdering:ExportFragment.kt$ExportFragment$Companion</ID>
    <ID>ClassOrdering:ExportJsonConfirmFragment.kt$ExportJsonConfirmFragment$Companion</ID>
    <ID>ClassOrdering:ExportJsonPasswordFragment.kt$ExportJsonPasswordFragment$Companion</ID>
    <ID>ClassOrdering:ExportMnemonicFragment.kt$ExportMnemonicFragment$Companion</ID>
    <ID>ClassOrdering:ExportSeedFragment.kt$ExportSeedFragment$Companion</ID>
    <ID>ClassOrdering:ExportSeedViewModel.kt$ExportSeedViewModel$private fun seedFromEntropy(secret: EncodableStruct&lt;MetaAccountSecrets&gt;?)</ID>
    <ID>ClassOrdering:ExtrinsicDetailFragment.kt$ExtrinsicDetailFragment$Companion</ID>
    <ID>ClassOrdering:FiatFormatter.kt$FiatFormatter$override fun format(number: BigDecimal): String</ID>
    <ID>ClassOrdering:FrozenTokensFragment.kt$FrozenTokensFragment$Companion</ID>
    <ID>ClassOrdering:GetSoraCardViewModel.kt$GetSoraCardViewModel$Companion</ID>
    <ID>ClassOrdering:ImportAccountFragment.kt$ImportAccountFragment$Companion</ID>
    <ID>ClassOrdering:ImportSourceModel.kt$MnemonicImportSource$init { addValidationSource(mnemonicContentLiveData) }</ID>
    <ID>ClassOrdering:ImportSourceModel.kt$RawSeedImportSource$init { addValidationSource(rawSeedLiveData) }</ID>
    <ID>ClassOrdering:InfoDialog.kt$InfoDialog$Companion</ID>
    <ID>ClassOrdering:KaruraApi.kt$KaruraApi$Companion</ID>
    <ID>ClassOrdering:LockBottomSheetBehavior.kt$LockBottomSheetBehavior$Companion</ID>
    <ID>ClassOrdering:ManualRewardCalculator.kt$ManualRewardCalculator$private val maxAPY = apyByValidator.values.maxOrNull() ?: 0.0</ID>
    <ID>ClassOrdering:MetaAccountLocal.kt$MetaAccountLocal$@PrimaryKey(autoGenerate = true) var id: Long = 0</ID>
    <ID>ClassOrdering:MnemonicContainerView.kt$MnemonicContainerView$Companion</ID>
    <ID>ClassOrdering:MoonbeamContributeViewState.kt$MoonbeamContributeViewState$override val applyActionState = when (customContributePayload.step) { TERMS -&gt; privacyAcceptedFlow.map { privacyAccepted -&gt; when { privacyAccepted -&gt; ApplyActionState.Available else -&gt; ApplyActionState.Unavailable(reason = resourceManager.getString(R.string.common_continue)) } } CONTRIBUTE -&gt; enteredEtheriumAddressFlow.combine(enteredAmountFlow) { ethAddress, amount -&gt; when { amount.isEmpty() -&gt; ApplyActionState.Unavailable(reason = resourceManager.getString(R.string.common_continue)) ethAddress.isEmpty() -&gt; ApplyActionState.Unavailable(reason = resourceManager.getString(R.string.common_continue)) else -&gt; ApplyActionState.Available } } else -&gt; flow { ApplyActionState.Available } }</ID>
    <ID>ClassOrdering:MoonbeamContributeViewState.kt$MoonbeamContributeViewState$private val savedEthAddress: String? = selectedAddressModelFlow.value?.address?.let { address -&gt; interactor.getEthAddress( paraId = customContributePayload.paraId, address = address ) }</ID>
    <ID>ClassOrdering:MoonbeamContributeViewState.kt$MoonbeamContributeViewState$private val selectedAddressModelFlow = accountUseCase.selectedAccountFlow() .asLiveData(coroutineScope)</ID>
    <ID>ClassOrdering:MoonbeamContributeViewState.kt$MoonbeamContributeViewState$val enteredAmountFlow = MutableStateFlow("")</ID>
    <ID>ClassOrdering:MoonbeamContributeViewState.kt$MoonbeamContributeViewState$val enteredEtheriumAddressFlow = MutableStateFlow(savedEthAddress.orEmpty())</ID>
    <ID>ClassOrdering:Navigator.kt$Navigator$override val beaconSignStatus: Flow&lt;SignStatus&gt; get() = navController!!.currentBackStackEntry!!.savedStateHandle .getLiveData&lt;SignStatus&gt;(SignBeaconTransactionFragment.SIGN_RESULT_KEY) .asFlow()</ID>
    <ID>ClassOrdering:Navigator.kt$Navigator$override val chainSelectorPayloadFlow: Flow&lt;ChainId?&gt; get() = navController?.currentBackStackEntry?.savedStateHandle ?.getLiveData&lt;ChainId?&gt;(ChainSelectFragment.KEY_SELECTED_CHAIN_ID) ?.asFlow() ?: emptyFlow()</ID>
    <ID>ClassOrdering:Navigator.kt$Navigator$override val currentStackEntryLifecycle: Lifecycle get() = navController!!.currentBackStackEntry!!.getLifecycle()</ID>
    <ID>ClassOrdering:Navigator.kt$Navigator$override val customBonusFlow: Flow&lt;BonusPayload?&gt; get() = navController!!.currentBackStackEntry!!.savedStateHandle .getLiveData&lt;BonusPayload?&gt;(CrowdloanContributeFragment.KEY_BONUS_LIVE_DATA) .asFlow()</ID>
    <ID>ClassOrdering:Navigator.kt$Navigator$override val educationalStoriesCompleted: Flow&lt;Boolean&gt; get() { return combineLiveData( navController?.currentBackStackEntry?.getLifecycle()?.onResumeObserver() ?: return flowOf(false), navController?.currentBackStackEntry?.savedStateHandle?.getLiveData&lt;Boolean&gt;(StoryFragment.KEY_STORY) ?: return flowOf(false), combiner = { (isResumed: Boolean, storiesCompleted: Boolean) -&gt; isResumed &amp;&amp; storiesCompleted } ).asFlow() }</ID>
    <ID>ClassOrdering:Navigator.kt$Navigator$override val latestCustomBonus: BonusPayload? get() = navController!!.currentBackStackEntry!!.savedStateHandle .get(CrowdloanContributeFragment.KEY_BONUS_LIVE_DATA)</ID>
    <ID>ClassOrdering:Navigator.kt$Navigator$override val walletSelectorPayloadFlow: Flow&lt;WalletSelectorPayload?&gt; get() = navController?.currentBackStackEntry?.savedStateHandle ?.getLiveData&lt;WalletSelectorPayload?&gt;(WalletSelectorPayload::class.java.name) ?.asFlow() ?: emptyFlow()</ID>
    <ID>ClassOrdering:NetworkInfoView.kt$NetworkInfoView$Companion</ID>
    <ID>ClassOrdering:NodeDetailsFragment.kt$NodeDetailsFragment$Companion</ID>
    <ID>ClassOrdering:NodesFragment.kt$NodesFragment$Companion</ID>
    <ID>ClassOrdering:OptionsAddAccountFragment.kt$OptionsAddAccountFragment$Companion</ID>
    <ID>ClassOrdering:OptionsWalletFragment.kt$OptionsWalletFragment$Companion</ID>
    <ID>ClassOrdering:PayoutDetailsFragment.kt$PayoutDetailsFragment$Companion</ID>
    <ID>ClassOrdering:PincodeFragment.kt$PincodeFragment$Companion</ID>
    <ID>ClassOrdering:PolkaswapDisclaimerViewModel.kt$PolkaswapDisclaimerViewModel$Companion</ID>
    <ID>ClassOrdering:PolkaswapInteractor.kt$PolkaswapInteractor$Companion</ID>
    <ID>ClassOrdering:PolkaswapInteractor.kt$PolkaswapInteractor$val availableMarkets: MutableMap&lt;Int, List&lt;Market&gt;&gt;</ID>
    <ID>ClassOrdering:PolkaswapInteractor.kt$PolkaswapInteractor$val bestDexIdFlow: StateFlow&lt;LoadingState&lt;Int&gt;&gt;</ID>
    <ID>ClassOrdering:PoolFullUnstakeDepositorAlertFragment.kt$PoolFullUnstakeDepositorAlertFragment$Companion</ID>
    <ID>ClassOrdering:PoolInfoFragment.kt$PoolInfoFragment$Companion</ID>
    <ID>ClassOrdering:PoolInfoOptionsFragment.kt$PoolInfoOptionsFragment$Companion</ID>
    <ID>ClassOrdering:PoolInfoViewModel.kt$PoolInfoViewModel$private fun setupSelectedValidatorsSharedState()</ID>
    <ID>ClassOrdering:PreferencesImpl.kt$PreferencesImpl$Companion</ID>
    <ID>ClassOrdering:QrCodeGenerator.kt$QrCodeGenerator$Companion</ID>
    <ID>ClassOrdering:ReceiveFragment.kt$ReceiveFragment$Companion</ID>
    <ID>ClassOrdering:RedeemFragment.kt$RedeemFragment$Companion</ID>
    <ID>ClassOrdering:ReferralContributeViewState.kt$ReferralContributeViewState$abstract fun createBonusPayload( referralCode: String, email: String? = null, agreeReceiveEmail: Boolean? = null ): ReferralCodePayload</ID>
    <ID>ClassOrdering:ReferralContributeViewState.kt$ReferralContributeViewState$abstract suspend fun validatePayload(payload: ReferralCodePayload)</ID>
    <ID>ClassOrdering:ReferralContributeViewState.kt$ReferralContributeViewState$fun applyFearlessCode()</ID>
    <ID>ClassOrdering:ReferralContributeViewState.kt$ReferralContributeViewState$fun learnMoreClicked()</ID>
    <ID>ClassOrdering:ReferralContributeViewState.kt$ReferralContributeViewState$fun termsClicked()</ID>
    <ID>ClassOrdering:RewardDestinationMixin.kt$RewardDestinationMixin$val canRestake: Flow&lt;Boolean&gt;</ID>
    <ID>ClassOrdering:RewardDetailFragment.kt$RewardDetailFragment$Companion</ID>
    <ID>ClassOrdering:RootActivity.kt$RootActivity$Companion</ID>
    <ID>ClassOrdering:RootActivity.kt$RootActivity$private val navController: NavController by lazy { val navHostFragment = supportFragmentManager.findFragmentById(R.id.navHost) as NavHostFragment navHostFragment.navController }</ID>
    <ID>ClassOrdering:RootViewModel.kt$RootViewModel$Companion</ID>
    <ID>ClassOrdering:RuntimeProvider.kt$RuntimeProvider$init { runtimeSyncService.syncResultFlow(chainId) .onEach(::considerReconstructingRuntime) .launchIn(this) tryLoadFromCache() }</ID>
    <ID>ClassOrdering:ScannerActivity.kt$ScannerActivity$Companion</ID>
    <ID>ClassOrdering:SelectBondMoreFragment.kt$SelectBondMoreFragment$Companion</ID>
    <ID>ClassOrdering:SelectMarketFragment.kt$SelectMarketFragment$Companion</ID>
    <ID>ClassOrdering:SelectUnbondFragment.kt$SelectUnbondFragment$Companion</ID>
    <ID>ClassOrdering:SelectValidatorsScreen.kt$MultiSelectListViewState$val isEmpty = items.isEmpty()</ID>
    <ID>ClassOrdering:SelectValidatorsViewModel.kt$SelectValidatorsViewModel$private fun setupFilters()</ID>
    <ID>ClassOrdering:SelectValidatorsViewModel.kt$SelectValidatorsViewModel$private fun subscribeOnSettings()</ID>
    <ID>ClassOrdering:SendSetupFragment.kt$SendSetupFragment$Companion</ID>
    <ID>ClassOrdering:SendSetupViewModel.kt$SendSetupViewModel$Companion</ID>
    <ID>ClassOrdering:SendSetupViewModel.kt$SendSetupViewModel$private fun getPhishingMessage(type: PhishingType): String</ID>
    <ID>ClassOrdering:SendSetupViewModel.kt$SendSetupViewModel$private val tipAmountFlow = combine(tipFlow, assetFlow) { tip: BigInteger?, asset: Asset? -&gt; tip?.let { asset?.token?.amountFromPlanks(it) } }</ID>
    <ID>ClassOrdering:SendSetupViewModel.kt$SendSetupViewModel$private val tipFlow = chainIdFlow.map { it?.let { walletConstants.tip(it) } }</ID>
    <ID>ClassOrdering:SetControllerFragment.kt$SetControllerFragment$Companion</ID>
    <ID>ClassOrdering:SetControllerViewModel.kt$SetControllerViewModel$init { loadFee() viewModelScope.launch { if (interactor.isControllerFeatureDeprecated(chainId)) { _controllerAccountModel.value = accountStakingFlow.map { generateIcon(it.stashAddress) }.first() } else { _controllerAccountModel.value = accountStakingFlow.map { generateIcon(it.controllerAddress) }.first() } } }</ID>
    <ID>ClassOrdering:SetupStakingPoolViewModel.kt$SetupStakingPoolViewModel$private val defaultAccountInfoState get() = AccountInfoViewState( accountName = "...", address = "", image = R.drawable.ic_wallet, caption = resourceManager.getString(R.string.pool_staking_join_account_title) )</ID>
    <ID>ClassOrdering:SetupStakingPoolViewModel.kt$SetupStakingPoolViewModel$private val defaultAmountInputState get() = AmountInputViewState( tokenName = "...", tokenImage = "", totalBalance = resourceManager.getString(R.string.common_balance_format, "..."), fiatAmount = "", tokenAmount = initialAmount, initial = null )</ID>
    <ID>ClassOrdering:SetupStakingPoolViewModel.kt$SetupStakingPoolViewModel$private val defaultButtonState get() = ButtonViewState( resourceManager.getString(R.string.pool_staking_join_button_title), true )</ID>
    <ID>ClassOrdering:SetupStakingPoolViewModel.kt$SetupStakingPoolViewModel$private val defaultState get() = SetupStakingScreenViewState( toolbarViewState, defaultAccountInfoState, defaultAmountInputState, FeeInfoViewState.default, defaultButtonState )</ID>
    <ID>ClassOrdering:SignBeaconTransactionFragment.kt$SignBeaconTransactionFragment$Companion</ID>
    <ID>ClassOrdering:SoraCardRepositoryImpl.kt$SoraCardRepositoryImpl$Companion</ID>
    <ID>ClassOrdering:SoraRewardCalculator.kt$SoraRewardCalculator$Companion</ID>
    <ID>ClassOrdering:SoraStakingRewardsScenario.kt$SoraStakingRewardsScenario$Companion</ID>
    <ID>ClassOrdering:StakeSummaryView.kt$StakeSummaryView$val moreActions: View get() = binding.stakeMoreActions</ID>
    <ID>ClassOrdering:StakingBalanceFragment.kt$StakingBalanceFragment$Companion</ID>
    <ID>ClassOrdering:StakingFragment.kt$StakingFragment$override fun initViews()</ID>
    <ID>ClassOrdering:StakingFragment.kt$StakingFragment$private var returnsJob: Job? = null</ID>
    <ID>ClassOrdering:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$// todo move to overrides parameter of chain_type.json val hoursInRound = mapOf( "fe58ea77779b7abda7da4ec526d14db9b1e9cd40a217c34892af80a9b332b76d" to 6, // moonbeam "401a1f9dca3da46f5c4091016c8a2f26dcea05865116b286f60f668207d1474b" to 2, // moonriver "91bc6e169807aaa54802737e1c504b2577d4fafedd5a02c10293b1cd60e39527" to 2 // moonbase )</ID>
    <ID>ClassOrdering:StakingPoolViewModel.kt$StakingPoolViewModel$override suspend fun getStakingViewStateFlowOld(): Flow&lt;StakingViewStateOld&gt;</ID>
    <ID>ClassOrdering:StakingRouter.kt$StakingRouter$val currentStackEntryLifecycle: Lifecycle</ID>
    <ID>ClassOrdering:StakingRouter.kt$StakingRouter$val walletSelectorPayloadFlow: Flow&lt;WalletSelectorPayload?&gt;</ID>
    <ID>ClassOrdering:StakingScenario.kt$StakingScenario$val viewModel = state.selectionItem.map { getViewModel(it.type) }</ID>
    <ID>ClassOrdering:StakingScenarioViewModel.kt$StakingScenarioViewModel$Companion</ID>
    <ID>ClassOrdering:StakingScenarioViewModel.kt$StakingScenarioViewModel$val enteredAmountFlow: MutableStateFlow&lt;BigDecimal?&gt;</ID>
    <ID>ClassOrdering:StakingScenarioViewModel.kt$StakingScenarioViewModel$val stakingViewStateFlowOld: Flow&lt;StakingViewStateOld&gt;</ID>
    <ID>ClassOrdering:StakingSharedState.kt$StakingSharedState$Companion</ID>
    <ID>ClassOrdering:StakingViewModel.kt$StakingViewModel$inline fun &lt;reified T : StakingAssetInfoViewState&gt; Map&lt;StakingType, StakingAssetInfoViewState&gt;.get(type: StakingType): T</ID>
    <ID>ClassOrdering:StakingViewStateOld.kt$StakeViewState$fun manageActionChosen(action: ManageStakeAction)</ID>
    <ID>ClassOrdering:StakingViewStateOld.kt$StakeViewState$fun moreActionsClicked()</ID>
    <ID>ClassOrdering:StakingViewStateOld.kt$WelcomeViewState$abstract fun infoActionClicked()</ID>
    <ID>ClassOrdering:StakingViewStateOld.kt$WelcomeViewState$abstract fun nextClicked()</ID>
    <ID>ClassOrdering:StakingViewStateOld.kt$WelcomeViewState$protected suspend fun rewardCalculator(): RewardCalculator</ID>
    <ID>ClassOrdering:StartChangeCollatorsViewModel.kt$StartChangeCollatorsViewModel$init { launch { collatorRecommendatorFactory.awaitBlockCreatorsLoading(router.currentStackEntryLifecycle) collatorsLoading.value = false } }</ID>
    <ID>ClassOrdering:StartChangeValidatorsViewModel.kt$StartChangeValidatorsViewModel$init { launch { validatorRecommendatorFactory.awaitBlockCreatorsLoading(router.currentStackEntryLifecycle) validatorsLoading.value = false } }</ID>
    <ID>ClassOrdering:StartSelectValidatorsViewModel.kt$StartSelectValidatorsViewModel$Companion</ID>
    <ID>ClassOrdering:StorageSubscriptionBuilder.kt$StorageSubscriptionBuilder$Companion</ID>
    <ID>ClassOrdering:StoryFragment.kt$StoryFragment$Companion</ID>
    <ID>ClassOrdering:SubqueryHistoryRequest.kt$SubqueryHistoryRequest$private val TransactionFilter.filterName @SuppressLint("DefaultLocale") get() = name.toLowerCase()</ID>
    <ID>ClassOrdering:SuccessFragment.kt$SuccessFragment$Companion</ID>
    <ID>ClassOrdering:SuccessViewModel.kt$SuccessViewModel$override val openBrowserEvent: MutableLiveData&lt;Event&lt;String&gt;&gt; = MutableLiveData()</ID>
    <ID>ClassOrdering:SuccessfulFragment.kt$SuccessfulFragment$Companion</ID>
    <ID>ClassOrdering:SwapDetailFragment.kt$SwapDetailFragment$Companion</ID>
    <ID>ClassOrdering:SwapDetailViewModel.kt$SwapDetailViewModel$Companion</ID>
    <ID>ClassOrdering:SwapPreviewFragment.kt$SwapPreviewFragment$Companion</ID>
    <ID>ClassOrdering:SwapTokensFragment.kt$SwapTokensFragment$Companion</ID>
    <ID>ClassOrdering:SwapTokensViewModel.kt$SwapTokensViewModel$var awaitNewFeeJob: Job? = null</ID>
    <ID>ClassOrdering:TernoaRewardCalculator.kt$TernoaRewardCalculator$Companion</ID>
    <ID>ClassOrdering:TransactionDetailViewModel.kt$TransactionDetailViewModel$val retryAddressModelLiveData = if (operation.isIncome) senderAddressModelLiveData else recipientAddressModelLiveData</ID>
    <ID>ClassOrdering:TransactionHistoryProvider.kt$TransactionHistoryProvider$Companion</ID>
    <ID>ClassOrdering:TransactionHistoryProvider.kt$TransactionHistoryProvider$init { launch { assetPayloadStateFlow.onEach { reloadHistory() }.launchIn(this) historyFiltersProvider.filtersFlow().onEach { reloadHistory() }.launchIn(this) } }</ID>
    <ID>ClassOrdering:TransactionHistoryProvider.kt$TransactionHistoryProvider$private val _sideEffects: MutableSharedFlow&lt;TransactionHistoryUi.SideEffect&gt; = MutableSharedFlow()</ID>
    <ID>ClassOrdering:TransactionHistoryProvider.kt$TransactionHistoryProvider$var nextPageLoading = false</ID>
    <ID>ClassOrdering:TransactionRawDataFragment.kt$TransactionRawDataFragment$Companion</ID>
    <ID>ClassOrdering:TransactionSettingsFragment.kt$TransactionSettingsFragment$Companion</ID>
    <ID>ClassOrdering:TransferDetailFragment.kt$TransferDetailFragment$Companion</ID>
    <ID>ClassOrdering:TransferValidityChecks.kt$TransferValidityChecksProvider$override val showTransferError = MutableLiveData&lt;Event&lt;TransferValidityLevel.Error.Status&gt;&gt;()</ID>
    <ID>ClassOrdering:TransferValidityChecks.kt$TransferValidityChecksProvider$override val showTransferWarning = MutableLiveData&lt;Event&lt;TransferValidityLevel.Warning.Status&gt;&gt;()</ID>
    <ID>ClassOrdering:ValidationExecutor.kt$ValidationExecutor$override val validationFailureEvent = MutableLiveData&lt;Event&lt;DefaultFailure&gt;&gt;()</ID>
    <ID>ClassOrdering:ValidatorDetailsFragment.kt$ValidatorDetailsFragment$Companion</ID>
    <ID>ClassOrdering:WalletExportFragment.kt$WalletExportFragment$Companion</ID>
    <ID>ClassOrdering:WalletRepositoryImpl.kt$WalletRepositoryImpl$Companion</ID>
    <ID>ClassOrdering:WalletRouter.kt$WalletRouter$val beaconSignStatus: Flow&lt;SignStatus&gt;</ID>
    <ID>ClassOrdering:WalletRouter.kt$WalletRouter$val chainSelectorPayloadFlow: Flow&lt;ChainId?&gt;</ID>
    <ID>ClassOrdering:WalletSelectorFragment.kt$WalletSelectorFragment$Companion</ID>
    <ID>ClassOrdering:WebViewerFragment.kt$WebViewerFragment$Companion</ID>
    <ID>ClassOrdering:WelcomeFragment.kt$WelcomeFragment$Companion</ID>
    <ID>CommentOverPrivateFunction:V2Migration.kt$V2Migration$private fun insertMetaAccount(metaAccountLocal: MetaAccountLocal, database: SupportSQLiteDatabase): Long</ID>
    <ID>CommentOverPrivateProperty:MetaAccountDao.kt$/** * Fetch meta account where * accountId = meta.substrateAccountId * or hex(accountId) = meta.ethereumAddress * or there is a child chain account which have child.accountId = accountId */ private const val FIND_BY_ADDRESS_QUERY = """ SELECT * FROM meta_accounts WHERE substrateAccountId = :accountId OR ethereumAddress = :accountId OR id = ( SELECT id FROM meta_accounts AS m INNER JOIN chain_accounts as c ON m.id = c.metaId WHERE c.accountId = :accountId ) """</ID>
    <ID>CommentWrapping:SelectUnbondViewModel.kt$SelectUnbondViewModel$/*, validPayload.asset.bondedInPlanks.orZero(), amountInPlanks*/</ID>
    <ID>CommentWrapping:ViewExt.kt$/*defValue*/</ID>
    <ID>ComplexCondition:QrCodeGenerator.kt$QrCodeGenerator$y == 0 || y &gt; byteMatrix.height || x == 0 || x &gt; byteMatrix.width</ID>
    <ID>ComplexCondition:RuntimeProvider.kt$RuntimeProvider$currentVersion == null || // metadata was synced and new hash is different from current one (runtimeSyncResult.metadataHash != null &amp;&amp; currentVersion.metadataHash != runtimeSyncResult.metadataHash) || // types were synced and new hash is different from current one (runtimeSyncResult.typesHash != null &amp;&amp; currentVersion.ownTypesHash != runtimeSyncResult.typesHash)</ID>
    <ID>ComplexCondition:TransactionHistoryProvider.kt$TransactionHistoryProvider$hasDataToLoad.not() || isIndexEnoughToLoadNextPage.not() || isNextPageLoaded || nextPageLoading</ID>
    <ID>ComplexInterface:AccountDataSource.kt$AccountDataSource : SecretStoreV1</ID>
    <ID>ComplexInterface:AccountInteractor.kt$AccountInteractor</ID>
    <ID>ComplexInterface:AccountRepository.kt$AccountRepository</ID>
    <ID>ComplexInterface:AccountRouter.kt$AccountRouter : SecureRouter</ID>
    <ID>ComplexInterface:CrossChainSetupContent.kt$CrossChainSetupScreenInterface</ID>
    <ID>ComplexInterface:CrowdloanRepository.kt$CrowdloanRepository</ID>
    <ID>ComplexInterface:CrowdloanRouter.kt$CrowdloanRouter</ID>
    <ID>ComplexInterface:MetaAccountDao.kt$MetaAccountDao</ID>
    <ID>ComplexInterface:OnboardingRouter.kt$OnboardingRouter</ID>
    <ID>ComplexInterface:PolkaswapInteractor.kt$PolkaswapInteractor</ID>
    <ID>ComplexInterface:PolkaswapRouter.kt$PolkaswapRouter</ID>
    <ID>ComplexInterface:Preferences.kt$Preferences</ID>
    <ID>ComplexInterface:SendSetupContent.kt$SendSetupScreenInterface</ID>
    <ID>ComplexInterface:StakingApi.kt$StakingApi</ID>
    <ID>ComplexInterface:StakingRouter.kt$StakingRouter</ID>
    <ID>ComplexInterface:StakingScenarioInteractor.kt$StakingScenarioInteractor</ID>
    <ID>ComplexInterface:StakingScenarioViewModel.kt$StakingScenarioViewModel</ID>
    <ID>ComplexInterface:StorageCache.kt$StorageCache</ID>
    <ID>ComplexInterface:SubstrateRemoteSource.kt$SubstrateRemoteSource</ID>
    <ID>ComplexInterface:SwapTokensContent.kt$SwapTokensCallbacks</ID>
    <ID>ComplexInterface:UpdatesMixin.kt$UpdatesProviderUi</ID>
    <ID>ComplexInterface:WalletInteractor.kt$WalletInteractor</ID>
    <ID>ComplexInterface:WalletRepository.kt$WalletRepository</ID>
    <ID>ComplexInterface:WalletRouter.kt$WalletRouter : SecureRouterWalletRouterApi</ID>
    <ID>CyclomaticComplexMethod:BeaconStateMachine.kt$BeaconStateMachine$override fun performTransition(state: State, event: Event): State</ID>
    <ID>CyclomaticComplexMethod:Chain.kt$Chain$override fun equals(other: Any?): Boolean</ID>
    <ID>CyclomaticComplexMethod:ConfirmContributeViewModel.kt$ConfirmContributeViewModel$private fun sendTransaction(suppressWarnings: Boolean = false)</ID>
    <ID>CyclomaticComplexMethod:CustomContributeFragment.kt$CustomContributeFragment$override fun subscribe(viewModel: CustomContributeViewModel)</ID>
    <ID>CyclomaticComplexMethod:EthereumDerivationPathTransformer.kt$EthereumDerivationPathTransformer$override fun afterTextChanged(s: Editable?)</ID>
    <ID>CyclomaticComplexMethod:ExportJsonPasswordViewModel.kt$ExportJsonPasswordViewModel$fun nextClicked()</ID>
    <ID>CyclomaticComplexMethod:MetaAccount.kt$MetaAccount$override fun equals(other: Any?): Boolean</ID>
    <ID>CyclomaticComplexMethod:OperationMappers.kt$suspend fun mapOperationToOperationModel( operation: Operation, nameIdentifier: AddressDisplayUseCase.Identifier, resourceManager: ResourceManager, iconGenerator: AddressIconGenerator ): OperationModel</ID>
    <ID>CyclomaticComplexMethod:StakingFragment.kt$StakingFragment$override fun subscribe(viewModel: StakingViewModel)</ID>
    <ID>CyclomaticComplexMethod:StakingPoolSharedState.kt$EditPoolFlowState$override fun equals(other: Any?): Boolean</ID>
    <ID>DataClassShouldBeImmutable:AddressBookContact.kt$AddressBookContact$@PrimaryKey(autoGenerate = true) var id: Long = 0</ID>
    <ID>DataClassShouldBeImmutable:AssetLocal.kt$AssetUpdateItem$var enabled: Boolean</ID>
    <ID>DataClassShouldBeImmutable:AssetLocal.kt$AssetUpdateItem$var sortIndex: Int</ID>
    <ID>DataClassShouldBeImmutable:NodeLocal.kt$NodeLocal$@PrimaryKey(autoGenerate = true) var id: Int = 0</ID>
    <ID>DestructuringDeclarationWithTooManyEntries:TransactionItem.kt$val (image, imageSpacer, header, amount, statusSpacer, status, subHeader, time) = createRefs()</ID>
    <ID>EmptyFunctionBlock:StakingAssetInfo.kt${ }</ID>
    <ID>EmptyKtFile:BeaconComponent.kt$.BeaconComponent.kt</ID>
    <ID>EmptyKtFile:BeaconModule.kt$.BeaconModule.kt</ID>
    <ID>EmptyKtFile:ExperimentalComponent.kt$.ExperimentalComponent.kt</ID>
    <ID>EmptyKtFile:ExperimentalModule.kt$.ExperimentalModule.kt</ID>
    <ID>EmptyKtFile:ValidatorDetailsModule.kt$.ValidatorDetailsModule.kt</ID>
    <ID>EmptySecondaryConstructor:SignBeaconTransactionFragment.kt$ParcelableJsonPayload${ }</ID>
    <ID>EndOfSentenceFormat:AccountDataSourceImpl.kt$AccountDataSourceImpl$* Fast lookup table for accessing account based on accountId</ID>
    <ID>EndOfSentenceFormat:AssetNotNeedAccountUseCase.kt$AssetNotNeedAccountUseCase$* Get assets without account</ID>
    <ID>EndOfSentenceFormat:AssetNotNeedAccountUseCase.kt$AssetNotNeedAccountUseCase$* Mark asset without account - as correct, no need of account * used in lists sort</ID>
    <ID>EndOfSentenceFormat:ComputationalCache.kt$ComputationalCache$* Caches computation till lifecycle is destroyed</ID>
    <ID>EndOfSentenceFormat:Keypair.kt$* Creates [Sr25519Keypair] if [nonce] is not null * Creates [BaseKeypair] otherwise</ID>
    <ID>EndOfSentenceFormat:KoltinExt.kt$* Complexity: O(n * log(n))</ID>
    <ID>EndOfSentenceFormat:LiveDatExt.kt$* Supports up to N sources, where N is last componentN() in ComponentHolder * @see ComponentHolder</ID>
    <ID>EndOfSentenceFormat:MetaAccountDao.kt$* Fetch meta account where * accountId = meta.substrateAccountId * or hex(accountId) = meta.ethereumAddress * or there is a child chain account which have child.accountId = accountId</ID>
    <ID>EndOfSentenceFormat:StorageCache.kt$StorageCache$* Should be not empty</ID>
    <ID>EndOfSentenceFormat:StorageCache.kt$StorageCache$* Should suspend until all keys will be found * Thus, result.size == fullKeys.size</ID>
    <ID>EndOfSentenceFormat:StorageCache.kt$StorageCache$* Should suspend until any matched result found</ID>
    <ID>EndOfSentenceFormat:StorageCache.kt$StorageCache$* Should suspend until any matched result found * Thus, will not be empty</ID>
    <ID>EndOfSentenceFormat:TotalBalanceUseCase.kt$TotalBalanceUseCase$* Calculate total account balance * * @param metaId - when specified calculation performed for particular metaAccountId, if not - for current metaAccountId</ID>
    <ID>EndOfSentenceFormat:Updater.kt$SideEffectScope$* We do not want this extension to be visible outside of update system * So, we put it into marker interface, which will allow to reach it in consumers code</ID>
    <ID>EndOfSentenceFormat:Updater.kt$Updater$* Implementations should be aware of cancellation</ID>
    <ID>EnumWrapping:AcalaBonusPayload.kt$AcalaContributionType</ID>
    <ID>EnumWrapping:AccountInChain.kt$AccountInChain$From</ID>
    <ID>EnumWrapping:AssetSelectorView.kt$AssetSelectorView$BackgroundStyle</ID>
    <ID>EnumWrapping:BlockExplorerUrlBuilder.kt$BlockExplorerUrlBuilder$Type</ID>
    <ID>EnumWrapping:BondMoreValidationFailure.kt$BondMoreValidationFailure</ID>
    <ID>EnumWrapping:BondedPool.kt$BondedPoolState</ID>
    <ID>EnumWrapping:CandidateInfo.kt$CandidateCapacity</ID>
    <ID>EnumWrapping:Chain.kt$Chain.Explorer$Type</ID>
    <ID>EnumWrapping:Chain.kt$Chain.ExternalApi.Section$Type</ID>
    <ID>EnumWrapping:ChainEcosystem.kt$ChainEcosystem</ID>
    <ID>EnumWrapping:ChainType.kt$ChainType</ID>
    <ID>EnumWrapping:CollatorsAdapter.kt$CollatorsAdapter$Mode</ID>
    <ID>EnumWrapping:Data.kt$Data.Hash$Type</ID>
    <ID>EnumWrapping:DelegatorState.kt$DelegatorStateStatus</ID>
    <ID>EnumWrapping:DropDown.kt$DropDownViewState$ClickableMode</ID>
    <ID>EnumWrapping:ExperimentalViewModel.kt$ExperimentalState$ExperimentStatus</ID>
    <ID>EnumWrapping:ExtrinsicDetailViewModel.kt$ExternalActionsSource</ID>
    <ID>EnumWrapping:ExtrinsicStatusEvent.kt$ExtrinsicStatusEvent</ID>
    <ID>EnumWrapping:Filters.kt$Filters</ID>
    <ID>EnumWrapping:Filters.kt$Sorting</ID>
    <ID>EnumWrapping:ImportAccountType.kt$ImportAccountType</ID>
    <ID>EnumWrapping:Operation.kt$Operation$Status</ID>
    <ID>EnumWrapping:OperationLocal.kt$OperationLocal$Source</ID>
    <ID>EnumWrapping:OperationLocal.kt$OperationLocal$Status</ID>
    <ID>EnumWrapping:OperationLocal.kt$OperationLocal$Type</ID>
    <ID>EnumWrapping:OperationModel.kt$OperationModel$Type</ID>
    <ID>EnumWrapping:PhishingModel.kt$PhishingType</ID>
    <ID>EnumWrapping:PoolMember.kt$NominationPoolState</ID>
    <ID>EnumWrapping:PoolMember.kt$RoleInPool</ID>
    <ID>EnumWrapping:RebondKind.kt$RebondKind</ID>
    <ID>EnumWrapping:RebondValidationFailure.kt$RebondValidationFailure</ID>
    <ID>EnumWrapping:RewardDetailViewModel.kt$ExternalActionsSource</ID>
    <ID>EnumWrapping:SelectableListItem.kt$SelectableListItemState$SelectableListItemAdditionalStatus</ID>
    <ID>EnumWrapping:SetControllerValidationFailure.kt$SetControllerValidationFailure</ID>
    <ID>EnumWrapping:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit$SelectionMethod</ID>
    <ID>EnumWrapping:SignStatus.kt$SignStatus</ID>
    <ID>EnumWrapping:SourceInternal.kt$SourceType</ID>
    <ID>EnumWrapping:StakeSummary.kt$DelegatorStatus.Inactive$Reason</ID>
    <ID>EnumWrapping:StakeSummary.kt$NominatorStatus.Inactive$Reason</ID>
    <ID>EnumWrapping:StakeSummary.kt$ValidatorStatus</ID>
    <ID>EnumWrapping:StakingPoolSharedState.kt$SelectValidatorFlowState$ValidatorSelectMode</ID>
    <ID>EnumWrapping:StakingReward.kt$StakingReward$Type</ID>
    <ID>EnumWrapping:StakingSharedState.kt$StakingType</ID>
    <ID>EnumWrapping:StakingSharedState.kt$SyntheticStakingType</ID>
    <ID>EnumWrapping:StakingViewStateOld.kt$ManageStakeAction</ID>
    <ID>EnumWrapping:TextInput.kt$TextInputViewState$Mode</ID>
    <ID>EnumWrapping:TransactionDetailViewModel.kt$ExternalActionsSource</ID>
    <ID>EnumWrapping:TransactionFilter.kt$TransactionFilter</ID>
    <ID>EnumWrapping:V2MigrationTest.kt$V2MigrationTest$Type</ID>
    <ID>EnumWrapping:Validation.kt$DefaultFailureLevel : Level</ID>
    <ID>EnumWrapping:ValidatorsAdapter.kt$ValidatorsAdapter$Mode</ID>
    <ID>EnumWrapping:XcmChainType.kt$XcmChainType : Parcelable</ID>
    <ID>EqualsAlwaysReturnsTrueOrFalse:IgnoredOnEquals.kt$IgnoredOnEquals$override fun equals(other: Any?): Boolean</ID>
    <ID>EqualsWithHashCodeExist:AccountStakingLocal.kt$AccountStakingLocal</ID>
    <ID>EqualsWithHashCodeExist:AccountStakingLocal.kt$AccountStakingLocal$AccessInfo</ID>
    <ID>EqualsWithHashCodeExist:IgnoredOnEquals.kt$IgnoredOnEquals&lt;out T&gt;</ID>
    <ID>EqualsWithHashCodeExist:RewardDestinationModel.kt$RewardDestinationModel$Payout : RewardDestinationModel</ID>
    <ID>FinalNewline:KotlinExtTest.kt$jp.co.soramitsu.common.utils.KotlinExtTest.kt</ID>
    <ID>ForbiddenComment:Account.kt$Account$// TODO make optional</ID>
    <ID>ForbiddenComment:AccountDataSource.kt$AccountDataSource$// TODO for compatibility only</ID>
    <ID>ForbiddenComment:AccountDataSourceImpl.kt$AccountDataSourceImpl$// todo add etherium support</ID>
    <ID>ForbiddenComment:AccountRepositoryImpl.kt$AccountRepositoryImpl$// TODO remove</ID>
    <ID>ForbiddenComment:AccountRepositoryImpl.kt$AccountRepositoryImpl$// TODO wallet</ID>
    <ID>ForbiddenComment:AddressDisplayUseCase.kt$AddressDisplayUseCase$// TODO adopt for meta account logic</ID>
    <ID>ForbiddenComment:BackupMnemonicViewModel.kt$BackupMnemonicViewModel$// TODO: Implement onGoogleLoginError</ID>
    <ID>ForbiddenComment:BackupWalletViewModel.kt$BackupWalletViewModel$// TODO</ID>
    <ID>ForbiddenComment:BackupWalletViewModel.kt$BackupWalletViewModel$// TODO: Only polkadotChainId?</ID>
    <ID>ForbiddenComment:Base58Ext.kt$Base58Ext$// TODO make Base58 static in fearless utils</ID>
    <ID>ForbiddenComment:BeaconViewModel.kt$BeaconViewModel$// todo hardcoded westend</ID>
    <ID>ForbiddenComment:BeaconViewModel.kt$BeaconViewModel$// todo think about multiple networks</ID>
    <ID>ForbiddenComment:ChainSyncService.kt$ChainSyncService$// todo add genshiro type to json</ID>
    <ID>ForbiddenComment:ConfirmStakingViewModel.kt$ConfirmStakingViewModel$// todo add collators support</ID>
    <ID>ForbiddenComment:CreateBackupPasswordViewModel.kt$CreateBackupPasswordViewModel$// TODO: Backup fix</ID>
    <ID>ForbiddenComment:CreateBackupPasswordViewModel.kt$CreateBackupPasswordViewModel$// TODO: Handle create account error</ID>
    <ID>ForbiddenComment:CrowdloanContributeInteractor.kt$CrowdloanContributeInteractor$// TODO optional for ethereum chains</ID>
    <ID>ForbiddenComment:CrowdloanInteractor.kt$CrowdloanInteractor$// TODO ethereum</ID>
    <ID>ForbiddenComment:CustomContributeViewModel.kt$CustomContributeViewModel$// todo rework with dagger separate validate systems</ID>
    <ID>ForbiddenComment:ExtrinsicBuilderExt.kt$// TODO rename to createPool when polkadot runtime upgrades to 9390</ID>
    <ID>ForbiddenComment:FearlessException.kt$FearlessException.Companion$// TODO: add common error text to resources</ID>
    <ID>ForbiddenComment:GiantsquidHistorySource.kt$GiantsquidHistorySource$// todo complete history parse</ID>
    <ID>ForbiddenComment:ImportAccountType.kt$// todo think of replace with MultiChainEncryption.Ethereum or CryptoType.ECDSA</ID>
    <ID>ForbiddenComment:ImportRemoteWalletViewModel.kt$ImportRemoteWalletViewModel$// TODO: Backup fix</ID>
    <ID>ForbiddenComment:ImportRemoteWalletViewModel.kt$ImportRemoteWalletViewModel$// TODO: Handle exception</ID>
    <ID>ForbiddenComment:KaruraContributeInteractor.kt$KaruraContributeInteractor$// TODO crowdloan</ID>
    <ID>ForbiddenComment:KoltinExt.kt$// TODO possible to optimize</ID>
    <ID>ForbiddenComment:PaymentUpdater.kt$PaymentUpdater$// TODO do not hardcode chain asset id</ID>
    <ID>ForbiddenComment:PayoutDetailsFragment.kt$PayoutDetailsFragment$// TODO perform date formatting in viewModel</ID>
    <ID>ForbiddenComment:PreferencesImpl.kt$PreferencesImpl$/* SharedPreferencesImpl stores listeners in a WeakHashMap, meaning listener is subject to GC if it is not kept anywhere else. This is not a problem until a stringFlow() call is followed later by shareIn() or stateIn(), which cause listener to be GC-ed (TODO - research why). To avoid that, store strong references to listeners until corresponding flow is closed. */</ID>
    <ID>ForbiddenComment:RootInteractor.kt$RootInteractor$// TODO remove this logic</ID>
    <ID>ForbiddenComment:SelectCustomCollatorsViewModel.kt$SelectCustomCollatorsViewModel$// todo do we need apply selected collators when moving back?</ID>
    <ID>ForbiddenComment:SelectedAccountUseCase.kt$SelectedAccountUseCase$// TODO use meta account</ID>
    <ID>ForbiddenComment:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit$// is Payload.Collators -&gt; SelectBlockProducersStep.Payload.Collators //todo</ID>
    <ID>ForbiddenComment:SocketSingleRequestExecutor.kt$SocketSingleRequestExecutor$// TODO this is not being used anywhere. Can we delete it?</ID>
    <ID>ForbiddenComment:StakingAssetInfoViewState.kt$StakingAssetInfoViewState.Parachain$// todo stories view state</ID>
    <ID>ForbiddenComment:StakingAssetInfoViewState.kt$StakingAssetInfoViewState.RelayChain$// todo stories view state</ID>
    <ID>ForbiddenComment:StakingLedgerUpdater.kt$StakingLedgerUpdater$// TODO ethereum</ID>
    <ID>ForbiddenComment:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$// todo move to overrides parameter of chain_type.json</ID>
    <ID>ForbiddenComment:StakingPoolApi.kt$StakingPoolApi$// todo temporary fix until all runtimes will be updated</ID>
    <ID>ForbiddenComment:StakingPoolViewModel.kt$StakingPoolViewModel$// todo hardcoded returns for demo</ID>
    <ID>ForbiddenComment:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$// TODO may be null for ethereum chains</ID>
    <ID>ForbiddenComment:StakingViewModel.kt$StakingScreenViewState$// todo shouldn't be nullable - it's just a stub</ID>
    <ID>ForbiddenComment:StakingViewModel.kt$StakingViewModel$// todo it's a stub</ID>
    <ID>ForbiddenComment:StakingViewStateOld.kt$// todo fix</ID>
    <ID>ForbiddenComment:StakingViewStateOld.kt$Pool$// todo stub</ID>
    <ID>ForbiddenComment:StartStakingPoolViewModel.kt$StartStakingPoolViewModel$// todo hardcoded returns for demo</ID>
    <ID>ForbiddenComment:SuccessfulFragment.kt$SuccessfulFragment.Companion$// todo shit</ID>
    <ID>ForbiddenComment:ValidateTransferUseCase.kt$// TODO create errors for utility asset (UtilityExistentialDepositWarning, InsufficientUtilityAssetBalance)</ID>
    <ID>ForbiddenComment:WelcomeViewModel.kt$WelcomeViewModel$// TODO: Login error</ID>
    <ID>ForbiddenComment:WssSubstrateSource.kt$WssSubstrateSource$// this logic was added to support Moonbeam/Moonriver chains; todo separate assets in json like orml</ID>
    <ID>FunctionMaxLength:ParachainMetadata.kt$fun mapmapParachainMetadataFlowDataRemoteToParachainMetadataFlowData(flowData: Map&lt;String, Any?&gt;): Map&lt;String, Any?&gt;</ID>
    <ID>FunctionMinLength:ContextExt.kt$fun Int.dp(context: Context): Int</ID>
    <ID>FunctionMinLength:CryptoTypeConverters.kt$CryptoTypeConverters$@TypeConverter fun to(name: String): CryptoType</ID>
    <ID>FunctionMinLength:MockitoHelpers.kt$fun &lt;T&gt; eq(obj: T): T</ID>
    <ID>FunctionMinLength:SubqueryExpressions.kt$SubqueryExpressions$fun or(innerExpressions: Collection&lt;String&gt;)</ID>
    <ID>FunctionMinLength:SubqueryExpressions.kt$SubqueryExpressions$fun or(vararg innerExpressions: String): String</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun B0( modifier: Modifier = Modifier, text: String, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE )</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun B1( modifier: Modifier = Modifier, text: AnnotatedString, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE )</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun B1( modifier: Modifier = Modifier, text: String, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE, onTextLayout: (TextLayoutResult) -&gt; Unit = {} )</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun B2( modifier: Modifier = Modifier, text: AnnotatedString, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE )</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun B2( modifier: Modifier = Modifier, text: String, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE )</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun B3( modifier: Modifier = Modifier, text: String, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE )</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun H1( modifier: Modifier = Modifier, text: String, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE )</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun H2( modifier: Modifier = Modifier, text: String, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE )</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun H3( modifier: Modifier = Modifier, text: AnnotatedString, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE )</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun H3( modifier: Modifier = Modifier, text: String, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE )</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun H4( modifier: Modifier = Modifier, text: AnnotatedString, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE )</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun H4( modifier: Modifier = Modifier, text: String, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE )</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun H5( modifier: Modifier = Modifier, text: AnnotatedString, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE )</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun H5( modifier: Modifier = Modifier, text: String, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE )</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun H6( modifier: Modifier = Modifier, text: AnnotatedString, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE )</ID>
    <ID>FunctionMinLength:Text.kt$@Composable fun H6( modifier: Modifier = Modifier, text: String, textAlign: TextAlign? = null, color: Color = Color.Unspecified, overflow: TextOverflow = TextOverflow.Clip, maxLines: Int = Int.MAX_VALUE )</ID>
    <ID>FunctionParameterNaming:BottomSheetScreen.kt$Content: @Composable ColumnScope.() -&gt; Unit</ID>
    <ID>FunctionParameterNaming:FullScreenLoading.kt$BlurredContent: @Composable () -&gt; Unit</ID>
    <ID>FunctionParameterNaming:InputWithHint.kt$Hint: @Composable () -&gt; Unit</ID>
    <ID>FunctionParameterNaming:SelectValidatorsVariantPanel.kt$AdditionalInfo: @Composable (T) -&gt; Unit = {}</ID>
    <ID>FunctionParameterNaming:StakingAssetInfo.kt$GuideInfo: @Composable () -&gt; Unit</ID>
    <ID>FunctionParameterNaming:StakingAssetInfo.kt$MainInfo: @Composable () -&gt; Unit</ID>
    <ID>FunctionParameterNaming:StakingInfoItem.kt$MainInfo: @Composable () -&gt; Unit</ID>
    <ID>FunctionParameterNaming:StakingInfoItem.kt$Status: @Composable () -&gt; Unit</ID>
    <ID>FunctionParameterNaming:TextFieldHint.kt$Hint: @Composable () -&gt; Unit</ID>
    <ID>FunctionReturnTypeSpacing:Mocks.kt$Mocks$fun chain(id: String) : Chain</ID>
    <ID>FunctionReturnTypeSpacing:V2MigrationTest.kt$V2MigrationTest$private fun performMigration(oldDbBuilder: SupportSQLiteDatabase.() -&gt; Unit) : SupportSQLiteDatabase</ID>
    <ID>FunctionSignature:AboutFragment.kt$AboutFragment$@OptIn(ExperimentalMaterialApi::class) @Composable override fun Content(padding: PaddingValues, scrollState: ScrollState, modalBottomSheetState: ModalBottomSheetState)</ID>
    <ID>FunctionSignature:AboutScreen.kt$@Composable fun AboutScreen( viewModel: AboutViewModel = hiltViewModel() )</ID>
    <ID>FunctionSignature:AcalaApi.kt$AcalaApi$@GET("//{apiUrl}/referral/{referral}") suspend fun isReferralValid( @Path("apiUrl") apiUrl: String, @Path("referral") referral: String ): AcalaReferralCheck</ID>
    <ID>FunctionSignature:AcalaApi.kt$AcalaApi$@GET("//{apiUrl}/statement") suspend fun getStatement( @Path("apiUrl") apiUrl: String ): AcalaStatement</ID>
    <ID>FunctionSignature:AcalaContributeFactory.kt$AcalaContributeFactory$override fun createView(context: Context, step: MoonbeamCrowdloanStep?): CustomContributeView</ID>
    <ID>FunctionSignature:AcalaContributeInteractor.kt$AcalaContributeInteractor$private suspend fun performContribute(payload: AcalaBonusPayload, amount: BigDecimal, apiUrl: String, apiKey: String): Result&lt;Unit&gt;</ID>
    <ID>FunctionSignature:AcalaContributeInteractor.kt$AcalaContributeInteractor$private suspend fun performTransfer(payload: AcalaBonusPayload, amount: BigDecimal, apiUrl: String, apiKey: String): Result&lt;Unit&gt;</ID>
    <ID>FunctionSignature:AcalaContributeInteractor.kt$AcalaContributeInteractor$suspend fun isReferralValid(referralCode: String, apiUrl: String)</ID>
    <ID>FunctionSignature:AcalaContributeInteractor.kt$AcalaContributeInteractor$suspend fun submitOffChain(payload: AcalaBonusPayload, amount: BigDecimal, apiUrl: String, apiKey: String): Result&lt;Unit&gt;</ID>
    <ID>FunctionSignature:AcalaContributeInteractor.kt$AcalaContributeInteractor$suspend fun submitRemark(payload: AcalaBonusPayload, extrinsicBuilder: ExtrinsicBuilder)</ID>
    <ID>FunctionSignature:AcalaContributeSubmitter.kt$AcalaContributeSubmitter$override suspend fun submitOffChain(payload: BonusPayload, amount: BigDecimal, metadata: ParachainMetadataParcelModel?): Result&lt;Unit&gt;</ID>
    <ID>FunctionSignature:AcalaContributeSubmitter.kt$AcalaContributeSubmitter$override suspend fun submitOnChain(payload: BonusPayload, amount: BigDecimal, extrinsicBuilder: ExtrinsicBuilder)</ID>
    <ID>FunctionSignature:AcalaContributeView.kt$AcalaContributeView$override fun bind( viewState: CustomContributeViewState, scope: LifecycleCoroutineScope )</ID>
    <ID>FunctionSignature:AcalaContributeViewState.kt$AcalaContributeViewState$override fun createBonusPayload(referralCode: String, email: String?, agreeReceiveEmail: Boolean?): ReferralCodePayload</ID>
    <ID>FunctionSignature:AcalaContributionModule.kt$AcalaContributionModule$@Provides fun provideAcalaSubmitter( interactor: AcalaContributeInteractor )</ID>
    <ID>FunctionSignature:AccountDataSourceImpl.kt$AccountDataSourceImpl$override suspend fun updateAccountPositions(accountOrdering: List&lt;MetaAccountOrdering&gt;)</ID>
    <ID>FunctionSignature:AccountDetailsInteractor.kt$AccountDetailsInteractor$private fun createAccountInChain(metaAccount: MetaAccount, chain: Chain, markedNotNeed: Boolean): AccountInChain</ID>
    <ID>FunctionSignature:AccountDetailsViewModel.kt$AccountDetailsViewModel$fun noNeedAccount(chainId: ChainId, metaId: Long, assetId: String, priceId: String?)</ID>
    <ID>FunctionSignature:AccountFeatureModule.kt$AccountFeatureModule$@Provides fun provideAccountInteractor( accountRepository: AccountRepository, fileProvider: FileProvider ): AccountInteractor</ID>
    <ID>FunctionSignature:AccountFeatureModule.kt$AccountFeatureModule$@Provides fun provideAccountUpdateScope( accountRepository: AccountRepository )</ID>
    <ID>FunctionSignature:AccountFeatureModule.kt$AccountFeatureModule$@Provides fun provideAccountUseCase( accountRepository: AccountRepository )</ID>
    <ID>FunctionSignature:AccountFeatureModule.kt$AccountFeatureModule$@Provides fun provideAddressDisplayUseCase( accountRepository: AccountRepository )</ID>
    <ID>FunctionSignature:AccountFeatureModule.kt$AccountFeatureModule$@Provides fun provideJsonEncoder( jsonMapper: Gson )</ID>
    <ID>FunctionSignature:AccountFeatureModule.kt$AccountFeatureModule$@Provides fun provideKeyPairRepository( secretStoreV2: SecretStoreV2, accountRepository: AccountRepository ): KeypairProvider</ID>
    <ID>FunctionSignature:AccountFeatureModule.kt$AccountFeatureModule$@Provides fun provideShouldShowEducationalStories( preferences: Preferences ): ShouldShowEducationalStoriesUseCase</ID>
    <ID>FunctionSignature:AccountInteractor.kt$AccountInteractor$suspend fun generateRestoreJson(metaId: Long, chainId: ChainId, password: String): Result&lt;String&gt;</ID>
    <ID>FunctionSignature:AccountInteractorImpl.kt$AccountInteractorImpl$override suspend fun generateRestoreJson(metaId: Long, chainId: ChainId, password: String)</ID>
    <ID>FunctionSignature:AccountInteractorImpl.kt$AccountInteractorImpl$override suspend fun getChainAccountSecrets(metaId: Long, chainId: ChainId)</ID>
    <ID>FunctionSignature:AccountRepository.kt$AccountRepository$suspend fun generateRestoreJson(metaId: Long, chainId: ChainId, password: String): String</ID>
    <ID>FunctionSignature:AccountRepositoryImpl.kt$AccountRepositoryImpl$override suspend fun generateRestoreJson(metaId: Long, chainId: ChainId, password: String)</ID>
    <ID>FunctionSignature:AccountRepositoryImpl.kt$AccountRepositoryImpl$override suspend fun getChainAccountSecrets(metaId: Long?, chainId: ChainId): EncodableStruct&lt;ChainAccountSecrets&gt;?</ID>
    <ID>FunctionSignature:AccountRepositoryImpl.kt$AccountRepositoryImpl$private suspend fun insertAccount( metaAccount: MetaAccountLocal )</ID>
    <ID>FunctionSignature:AccountRepositoryImpl.kt$AccountRepositoryImpl$private suspend fun insertChainAccount( chainAccount: ChainAccountLocal )</ID>
    <ID>FunctionSignature:AccountRouter.kt$AccountRouter$@PinRequired fun getExportMnemonicDestination(metaId: Long, chainId: ChainId, isExportWallet: Boolean = false): DelayedNavigation</ID>
    <ID>FunctionSignature:AccountRouter.kt$AccountRouter$@PinRequired fun getExportSeedDestination(metaId: Long, chainId: ChainId, isExportWallet: Boolean = false): DelayedNavigation</ID>
    <ID>FunctionSignature:AccountRouter.kt$AccountRouter$@PinRequired fun openExportJsonPasswordDestination(metaId: Long, chainId: ChainId, isExportWallet: Boolean = false): DelayedNavigation</ID>
    <ID>FunctionSignature:AccountRouter.kt$AccountRouter$fun openMnemonicAgreementsDialog( isFromGoogleBackup: Boolean, accountName: String )</ID>
    <ID>FunctionSignature:AccountRouter.kt$AccountRouter$fun openMnemonicDialog( isFromGoogleBackup: Boolean, accountName: String )</ID>
    <ID>FunctionSignature:AccountRouter.kt$AccountRouter$fun openOnboardingNavGraph(chainId: ChainId, metaId: Long, isImport: Boolean)</ID>
    <ID>FunctionSignature:AccountStakingDao.kt$AccountStakingDao$@Query(SELECT_QUERY) abstract suspend fun get(chainId: String, chainAssetId: String, accountId: ByteArray): AccountStakingLocal?</ID>
    <ID>FunctionSignature:AccountStakingDao.kt$AccountStakingDao$@Query(SELECT_QUERY) protected abstract fun observeInternal(chainId: String, chainAssetId: String, accountId: ByteArray): Flow&lt;AccountStakingLocal&gt;</ID>
    <ID>FunctionSignature:AccountStakingDao.kt$AccountStakingDao$fun observeDistinct(chainId: String, chainAssetId: String, accountId: ByteArray): Flow&lt;AccountStakingLocal&gt;</ID>
    <ID>FunctionSignature:AccountsForExportFragment.kt$AccountsForExportFragment.Companion$fun getBundle(metaAccountId: Long, from: AccountInChain.From)</ID>
    <ID>FunctionSignature:AddressBookRepository.kt$AddressBookRepository$suspend fun saveAddress(name: String, address: String, chainId: String)</ID>
    <ID>FunctionSignature:AddressBookRepositoryImpl.kt$AddressBookRepositoryImpl$override fun observeAddressBook(chainId: ChainId): Flow&lt;List&lt;AddressBookContact&gt;&gt;</ID>
    <ID>FunctionSignature:AddressBookRepositoryImpl.kt$AddressBookRepositoryImpl$override suspend fun saveAddress(name: String, address: String, chainId: String)</ID>
    <ID>FunctionSignature:AddressHistoryContent.kt$@Composable fun AddressHistoryContent( state: LoadingState&lt;AddressHistoryViewState&gt;, callback: AddressHistoryScreenInterface )</ID>
    <ID>FunctionSignature:AddressIconGenerator.kt$@Throws(AddressFormatException::class) suspend fun AddressIconGenerator.createAddressIcon(accountAddress: String, sizeInDp: Int)</ID>
    <ID>FunctionSignature:AddressIconGenerator.kt$@Throws(AddressFormatException::class) suspend fun AddressIconGenerator.createAddressModel(accountAddress: String, sizeInDp: Int, accountName: String? = null): AddressModel</ID>
    <ID>FunctionSignature:AddressIconGenerator.kt$@Throws(AddressFormatException::class) suspend fun AddressIconGenerator.createEthereumAddressIcon(accountAddress: String, sizeInDp: Int)</ID>
    <ID>FunctionSignature:AddressIconGenerator.kt$@Throws(AddressFormatException::class) suspend fun AddressIconGenerator.createEthereumAddressModel(accountAddress: String, sizeInDp: Int, accountName: String? = null): AddressModel</ID>
    <ID>FunctionSignature:AddressIconGenerator.kt$CachingAddressIconGenerator$override suspend fun createEthereumAddressIcon(accountId: AccountId, sizeInDp: Int, backgroundColorRes: Int): PictureDrawable</ID>
    <ID>FunctionSignature:AddressIconGenerator.kt$StatelessAddressIconGenerator$override suspend fun createEthereumAddressIcon(accountId: AccountId, sizeInDp: Int, backgroundColorRes: Int)</ID>
    <ID>FunctionSignature:AlertFragment.kt$AlertFragment.Companion$fun getBundle(payload: AlertViewState, resultKey: String, resultDestinationId: Int)</ID>
    <ID>FunctionSignature:AlertsInteractor.kt$AlertsInteractor$fun getAlertsFlow(stakingState: StakingState): Flow&lt;List&lt;Alert&gt;&gt;</ID>
    <ID>FunctionSignature:AlertsInteractor.kt$AlertsInteractor$private fun produceMinStakeAlert(context: AlertContext)</ID>
    <ID>FunctionSignature:AlertsInteractor.kt$AlertsInteractor$private fun produceRedeemableAlert(context: AlertContext): Alert?</ID>
    <ID>FunctionSignature:AlertsInteractor.kt$AlertsInteractor$private fun produceWaitingNextEraAlert(context: AlertContext)</ID>
    <ID>FunctionSignature:AlertsInteractor.kt$AlertsInteractor$private inline fun &lt;reified T : StakingState, R&gt; requireState( state: StakingState, block: (T) -&gt; R ): R?</ID>
    <ID>FunctionSignature:AlertsInteractor.kt$AlertsInteractor.AlertContext$inline fun &lt;reified T&gt; useMemo( key: Any, lazyProducer: () -&gt; T ): T</ID>
    <ID>FunctionSignature:AmountInput.kt$@Composable private fun RowScope.TokenIcon( url: String?, modifier: Modifier = Modifier )</ID>
    <ID>FunctionSignature:AmountInput.kt$AmountInputViewState.Companion$fun default(resourceManager: ResourceManager, @StringRes totalBalanceFormat: Int = R.string.common_balance_format): AmountInputViewState</ID>
    <ID>FunctionSignature:AppConfig.kt$fun AppConfigRemote.toDomain()</ID>
    <ID>FunctionSignature:AppLinksProvider.kt$AppLinksProvider$fun getTwitterAccountUrl( accountName: String ): String</ID>
    <ID>FunctionSignature:Asset.kt$fun calculateTotalBalance( freeInPlanks: BigInteger?, reservedInPlanks: BigInteger? )</ID>
    <ID>FunctionSignature:AssetCache.kt$AssetCache$suspend fun updateTokenPrice( priceId: String, builder: (local: TokenPriceLocal) -&gt; TokenPriceLocal )</ID>
    <ID>FunctionSignature:AssetChainsBadge.kt$@Composable fun AssetChainsBadge( urls: List&lt;String&gt;, modifier: Modifier = Modifier )</ID>
    <ID>FunctionSignature:AssetDao.kt$AssetDao$@Query("DELETE FROM assets WHERE metaId = :metaId AND accountId = :accountId AND chainId = :chainId AND id = :assetId") abstract fun deleteAsset(metaId: Long, accountId: AccountId, chainId: String, assetId: String)</ID>
    <ID>FunctionSignature:AssetDao.kt$AssetDao$override fun observeAsset(metaId: Long, accountId: AccountId, chainId: String, assetId: String): Flow&lt;AssetWithToken&gt;</ID>
    <ID>FunctionSignature:AssetDao.kt$AssetDao$override suspend fun getAsset(metaId: Long, accountId: AccountId, chainId: String, assetId: String): AssetWithToken?</ID>
    <ID>FunctionSignature:AssetDao.kt$AssetDao$override suspend fun getAssets(metaId: Long, accountId: AccountId, chainId: String, symbol: String): List&lt;AssetWithToken&gt;</ID>
    <ID>FunctionSignature:AssetDao.kt$AssetReadOnlyCache$fun observeAsset(metaId: Long, accountId: AccountId, chainId: String, assetId: String): Flow&lt;AssetWithToken&gt;</ID>
    <ID>FunctionSignature:AssetDao.kt$AssetReadOnlyCache$suspend fun getAsset(metaId: Long, accountId: AccountId, chainId: String, assetId: String): AssetWithToken?</ID>
    <ID>FunctionSignature:AssetDao.kt$AssetReadOnlyCache$suspend fun getAssets(metaId: Long, accountId: AccountId, chainId: String, symbol: String): List&lt;AssetWithToken&gt;</ID>
    <ID>FunctionSignature:AssetListItem.kt$@Composable fun AssetListItemShimmer( state: AssetListItemShimmerViewState, modifier: Modifier = Modifier )</ID>
    <ID>FunctionSignature:AssetMappers.kt$fun combineAssetWithPrices( chainAsset: CoreAsset, tokenPriceLocal: TokenPriceLocal? ): Token</ID>
    <ID>FunctionSignature:AssetNotNeedAccountUseCase.kt$AssetNotNeedAccountUseCase$suspend fun markNotNeed(chainId: ChainId, metaId: Long, assetId: String, priceId: String?)</ID>
    <ID>FunctionSignature:AssetNotNeedAccountUseCaseImpl.kt$AssetNotNeedAccountUseCaseImpl$override suspend fun markNotNeed(chainId: ChainId, metaId: Long, assetId: String, priceId: String?)</ID>
    <ID>FunctionSignature:AssetSelectContent.kt$@Composable fun AssetItem( state: AssetItemState, onSelected: (AssetItemState) -&gt; Unit )</ID>
    <ID>FunctionSignature:AssetSelectContent.kt$@Composable fun AssetSelectContent( state: AssetSelectScreenViewState, callback: AssetSelectContentInterface )</ID>
    <ID>FunctionSignature:AssetSelector.kt$@Composable fun AssetSelector( state: AssetSelectorState, onClick: () -&gt; Unit = {} )</ID>
    <ID>FunctionSignature:AssetSelectorView.kt$AssetSelectorView$fun setState( imageLoader: ImageLoader, assetModel: AssetModel )</ID>
    <ID>FunctionSignature:AssetSelectorView.kt$AssetSelectorView$private fun applyAttributes(attributes: AttributeSet)</ID>
    <ID>FunctionSignature:AssetsList.kt$AssetsListInterface$@OptIn(ExperimentalMaterialApi::class) fun actionItemClicked(actionType: ActionItemType, chainId: ChainId, chainAssetId: String, swipeableState: SwipeableState&lt;SwipeState&gt;)</ID>
    <ID>FunctionSignature:AstarContributeFactory.kt$AstarContributeFactory$override fun createView(context: Context, step: MoonbeamCrowdloanStep?): CustomContributeView</ID>
    <ID>FunctionSignature:AstarContributeSubmitter.kt$AstarContributeSubmitter$override suspend fun submitOnChain(payload: BonusPayload, amount: BigDecimal, extrinsicBuilder: ExtrinsicBuilder)</ID>
    <ID>FunctionSignature:AstarContributeView.kt$AstarContributeView$override fun bind( viewState: CustomContributeViewState, scope: LifecycleCoroutineScope )</ID>
    <ID>FunctionSignature:AstarContributeViewState.kt$AstarContributeViewState$override fun createBonusPayload(referralCode: String, email: String?, agreeReceiveEmail: Boolean?): ReferralCodePayload</ID>
    <ID>FunctionSignature:AstarContributionModule.kt$AstarContributionModule$@Provides fun provideAstarInteractor( accountRepository: AccountRepository )</ID>
    <ID>FunctionSignature:AstarContributionModule.kt$AstarContributionModule$@Provides fun provideAstarSubmitter( interactor: AstarContributeInteractor )</ID>
    <ID>FunctionSignature:BackupMnemonicContent.kt$@Composable internal fun BackupMnemonicContent( state: BackupMnemonicState, callback: BackupMnemonicCallback )</ID>
    <ID>FunctionSignature:BackupMnemonicContent.kt$BackupMnemonicCallback$fun onNextClick( launcher: ActivityResultLauncher&lt;Intent&gt; )</ID>
    <ID>FunctionSignature:BackupMnemonicDialog.kt$BackupMnemonicDialog.Companion$fun getBundle( isFromGoogleBackup: Boolean, accountName: String ): Bundle</ID>
    <ID>FunctionSignature:BackupMnemonicViewModel.kt$BackupMnemonicViewModel$fun onGoogleSignInSuccess( substrateDerivationPath: String, ethereumDerivationPath: String )</ID>
    <ID>FunctionSignature:BackupMnemonicViewModel.kt$BackupMnemonicViewModel$override fun onNextClick( launcher: ActivityResultLauncher&lt;Intent&gt; )</ID>
    <ID>FunctionSignature:BackupMnemonicViewModel.kt$BackupMnemonicViewModel$private fun openConfirmMnemonicOnCreate( substrateDerivationPath: String, ethereumDerivationPath: String )</ID>
    <ID>FunctionSignature:BackupMnemonicViewModel.kt$BackupMnemonicViewModel$private fun openCreateBackupPasswordDialog( substrateDerivationPath: String, ethereumDerivationPath: String )</ID>
    <ID>FunctionSignature:BackupWalletContent.kt$@Composable internal fun BackupWalletContent( state: BackupWalletState, callback: BackupWalletCallback )</ID>
    <ID>FunctionSignature:BackupWalletContent.kt$@Composable private fun SettingsDivider( modifier: Modifier = Modifier )</ID>
    <ID>FunctionSignature:BalanceDetailFragment.kt$BalanceDetailFragment$@OptIn(ExperimentalMaterialApi::class) @Composable override fun Content(padding: PaddingValues, scrollState: ScrollState, modalBottomSheetState: ModalBottomSheetState)</ID>
    <ID>FunctionSignature:BalanceDetailViewModel.kt$BalanceDetailViewModel$override fun actionItemClicked(actionType: ActionItemType, chainId: ChainId, chainAssetId: String)</ID>
    <ID>FunctionSignature:BalanceDetailViewModel.kt$BalanceDetailViewModel$private suspend fun getActionItems( selectedChainId: String, asset: Asset ): List&lt;ActionItemType&gt;</ID>
    <ID>FunctionSignature:BalanceDetailsScreen.kt$&lt;no name provided&gt;$override fun actionItemClicked(actionType: ActionItemType, chainId: ChainId, chainAssetId: String)</ID>
    <ID>FunctionSignature:BalanceDetailsScreen.kt$@Composable fun BalanceDetailsScreen( state: BalanceDetailsState, callback: BalanceDetailsScreenInterface )</ID>
    <ID>FunctionSignature:BalanceDetailsScreen.kt$@Composable private fun ActionBar(actionBarLoadingState: LoadingState&lt;ActionBarViewState&gt;, actionItemClicked: (ActionItemType, String, String) -&gt; Unit)</ID>
    <ID>FunctionSignature:BalanceDetailsScreen.kt$@Composable private fun AssetBalance( balanceLoadingState: LoadingState&lt;AssetBalanceViewState&gt;, onAddressClick: () -&gt; Unit )</ID>
    <ID>FunctionSignature:BalanceDetailsScreen.kt$BalanceDetailsScreenInterface$fun actionItemClicked(actionType: ActionItemType, chainId: ChainId, chainAssetId: String)</ID>
    <ID>FunctionSignature:BalanceListFragment.kt$BalanceListFragment$@OptIn(ExperimentalMaterialApi::class) @Composable override fun Content(padding: PaddingValues, scrollState: ScrollState, modalBottomSheetState: ModalBottomSheetState)</ID>
    <ID>FunctionSignature:BalanceListViewModel.kt$BalanceListViewModel$@OptIn(ExperimentalMaterialApi::class) override fun actionItemClicked(actionType: ActionItemType, chainId: ChainId, chainAssetId: String, swipeableState: SwipeableState&lt;SwipeState&gt;)</ID>
    <ID>FunctionSignature:BaseComposeFragment.kt$BaseComposeFragment$@OptIn(ExperimentalMaterialApi::class) @Composable abstract fun Content(padding: PaddingValues, scrollState: ScrollState, modalBottomSheetState: ModalBottomSheetState)</ID>
    <ID>FunctionSignature:BaseStorageSource.kt$BaseStorageSource$protected abstract suspend fun query(key: String, chainId: String, at: BlockHash?): String?</ID>
    <ID>FunctionSignature:BaseStorageSource.kt$BaseStorageSource$protected abstract suspend fun queryChildState(storageKey: String, childKey: String, chainId: String): String?</ID>
    <ID>FunctionSignature:BaseStorageSource.kt$BaseStorageSource$protected abstract suspend fun queryKeys(keys: List&lt;String&gt;, chainId: String, at: BlockHash?): Map&lt;String, String?&gt;</ID>
    <ID>FunctionSignature:BeaconFragment.kt$BeaconFragment$override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?)</ID>
    <ID>FunctionSignature:BeaconInteractor.kt$BeaconInteractor$suspend fun allowPermissions( forRequest: PermissionSubstrateRequest )</ID>
    <ID>FunctionSignature:BeaconInteractor.kt$BeaconInteractor$suspend fun connectFromQR(qrCode: String): Result&lt;Pair&lt;P2pPeer, Flow&lt;BeaconRequest?&gt;&gt;&gt;</ID>
    <ID>FunctionSignature:BeaconInteractor.kt$BeaconInteractor$suspend fun reportPermissionsDeclined( request: PermissionSubstrateRequest )</ID>
    <ID>FunctionSignature:BeaconInteractor.kt$BeaconInteractor$suspend fun reportSignDeclined( request: SignPayloadSubstrateRequest )</ID>
    <ID>FunctionSignature:BeaconInteractor.kt$BeaconInteractor$suspend fun signPayload( request: SignPayloadSubstrateRequest )</ID>
    <ID>FunctionSignature:BifrostApi.kt$BifrostApi$@POST("/") suspend fun getAccountByReferralCode(@Body body: BifrostReferralCheckRequest): SubQueryResponse&lt;GetAccountByReferralCodeResponse&gt;</ID>
    <ID>FunctionSignature:BifrostApi.kt$suspend fun BifrostApi.getAccountByReferralCode(code: String)</ID>
    <ID>FunctionSignature:BifrostContributeFactory.kt$BifrostContributeFactory$override fun createView(context: Context, step: MoonbeamCrowdloanStep?): CustomContributeView</ID>
    <ID>FunctionSignature:BifrostContributeSubmitter.kt$BifrostContributeSubmitter$override suspend fun submitOnChain(payload: BonusPayload, amount: BigDecimal, extrinsicBuilder: ExtrinsicBuilder)</ID>
    <ID>FunctionSignature:BifrostContributeViewState.kt$BifrostContributeViewState$override fun createBonusPayload(referralCode: String, email: String?, agreeReceiveEmail: Boolean?): ReferralCodePayload</ID>
    <ID>FunctionSignature:BifrostContributionModule.kt$BifrostContributionModule$@Provides fun provideBifrostInteractor( bifrostApi: BifrostApi, httpExceptionHandler: HttpExceptionHandler )</ID>
    <ID>FunctionSignature:BifrostContributionModule.kt$BifrostContributionModule$@Provides fun provideBifrostSubmitter( interactor: BifrostContributeInteractor )</ID>
    <ID>FunctionSignature:BindActiveEraIndex.kt$@UseCaseBinding fun bindActiveEraIndex( scale: String, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:BindStaked.kt$@UseCaseBinding fun bindStaked( scale: String, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:BindTotalIssuance.kt$@UseCaseBinding fun bindTotalIssuance( scale: String, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:BindTotalValidatorEraReward.kt$@UseCaseBinding fun bindTotalValidatorEraReward(scale: String?, runtime: RuntimeSnapshot, type: Type&lt;*&gt;): BigInteger</ID>
    <ID>FunctionSignature:BindingHelpers.kt$fun &lt;T&gt; Type&lt;T&gt;.fromHexOrIncompatible(scale: String, runtime: RuntimeSnapshot)</ID>
    <ID>FunctionSignature:BlockProducer.kt$suspend fun Collection&lt;BlockProducer&gt;.toModels(createIcon: suspend (address: String) -&gt; AddressModel): List&lt;BlockProducerModel&gt;</ID>
    <ID>FunctionSignature:BondMoreInteractor.kt$BondMoreInteractor$suspend fun bondMore( accountAddress: String, formExtrinsic: suspend ExtrinsicBuilder.() -&gt; Unit ): Result&lt;String&gt;</ID>
    <ID>FunctionSignature:BondMoreInteractor.kt$BondMoreInteractor$suspend fun estimateFee( formExtrinsic: suspend ExtrinsicBuilder.() -&gt; Unit ): BigInteger</ID>
    <ID>FunctionSignature:BondMoreValidationFailure.kt$fun bondMoreValidationFailure( reason: BondMoreValidationFailure, resourceManager: ResourceManager ): TitleAndMessage</ID>
    <ID>FunctionSignature:BottomSheetScreen.kt$@Composable fun BottomSheetDialog(modifier: Modifier = Modifier, verticalArrangement: Arrangement.Vertical = Arrangement.Top, Content: @Composable ColumnScope.() -&gt; Unit)</ID>
    <ID>FunctionSignature:BottomSheetScreen.kt$@Composable fun BottomSheetScreen( modifier: Modifier = Modifier, Content: @Composable ColumnScope.() -&gt; Unit )</ID>
    <ID>FunctionSignature:Button.kt$@Composable fun AccentButton(state: ButtonViewState, modifier: Modifier = Modifier, onClick: () -&gt; Unit)</ID>
    <ID>FunctionSignature:Button.kt$@Composable fun AccentButton(text: String, enabled: Boolean = true, modifier: Modifier = Modifier, onClick: () -&gt; Unit)</ID>
    <ID>FunctionSignature:Button.kt$@Composable fun AccentDarkDisabledButton(state: ButtonViewState, modifier: Modifier = Modifier, onClick: () -&gt; Unit)</ID>
    <ID>FunctionSignature:Button.kt$@Composable fun GrayButton(text: String, enabled: Boolean = true, modifier: Modifier = Modifier, onClick: () -&gt; Unit)</ID>
    <ID>FunctionSignature:Button.kt$@Composable fun TransparentButton(text: String, enabled: Boolean = true, modifier: Modifier = Modifier, onClick: () -&gt; Unit)</ID>
    <ID>FunctionSignature:Button.kt$private fun onSingleClick( lastClickTimeState: MutableState&lt;Long&gt;, onClick: () -&gt; Unit )</ID>
    <ID>FunctionSignature:BuyCryptoFragment.kt$BuyCryptoFragment$@ExperimentalMaterialApi @Composable override fun Content(padding: PaddingValues, scrollState: ScrollState, modalBottomSheetState: ModalBottomSheetState)</ID>
    <ID>FunctionSignature:BuyCryptoRepositoryImpl.kt$BuyCryptoRepositoryImpl$override fun subscribePaymentOrderInfo(): Flow&lt;PaymentOrderInfo&gt;</ID>
    <ID>FunctionSignature:BuyCryptoScreen.kt$@Composable fun BuyCryptoScreen( state: BuyCryptoState, onPageFinished: () -&gt; Unit )</ID>
    <ID>FunctionSignature:BuyMixin.kt$BuyMixin.Presentation$fun buyClicked(chainId: ChainId, chainAssetId: String, accountAddress: String)</ID>
    <ID>FunctionSignature:BuyMixinProvider.kt$BuyMixinProvider$override fun buyClicked(chainId: ChainId, chainAssetId: String, accountAddress: String)</ID>
    <ID>FunctionSignature:BuyProviderChooserBottomSheet.kt$BuyProviderHolder$override fun bind(item: BuyProvider, isSelected: Boolean, handler: DynamicListSheetAdapter.Handler&lt;BuyProvider&gt;)</ID>
    <ID>FunctionSignature:Chain.kt$fun Chain.updateNodesActive(localVersion: Chain): Chain</ID>
    <ID>FunctionSignature:Chain.kt$fun List&lt;Chain&gt;.getWithToken(symbol: String, filter: Map&lt;ChainId, List&lt;String&gt;&gt;? = null): List&lt;Chain&gt;</ID>
    <ID>FunctionSignature:ChainDao.kt$ChainDao$@Query("UPDATE chain_nodes SET name = :nodeName, url = :nodeUrl WHERE chainId = :chainId and url = :prevNodeUrl") abstract suspend fun updateNode(chainId: String, prevNodeUrl: String, nodeName: String, nodeUrl: String)</ID>
    <ID>FunctionSignature:ChainDao.kt$ChainDao$@Transaction open suspend fun update( removed: List&lt;ChainLocal&gt;, newOrUpdated: List&lt;JoinedChainInfo&gt; )</ID>
    <ID>FunctionSignature:ChainExt.kt$fun Chain.accountFromMapKey(account: String): String</ID>
    <ID>FunctionSignature:ChainRegistry.kt$ChainRegistry$fun getAsset(chainId: ChainId, chainAssetId: String)</ID>
    <ID>FunctionSignature:ChainRegistry.kt$ChainRegistry$suspend fun addNode(chainId: ChainId, nodeName: String, nodeUrl: String)</ID>
    <ID>FunctionSignature:ChainRegistry.kt$ChainRegistry$suspend fun updateNode(id: NodeId, name: String, url: String)</ID>
    <ID>FunctionSignature:ChainRegistryModule.kt$ChainRegistryModule$@Provides @Singleton fun provideChainSyncService( dao: ChainDao, chainFetcher: ChainFetcher )</ID>
    <ID>FunctionSignature:ChainRegistryModule.kt$ChainRegistryModule$@Provides @Singleton fun provideRuntimeFilesCache( fileProvider: FileProvider )</ID>
    <ID>FunctionSignature:ChainRegistryModule.kt$ChainRegistryModule$@Provides @Singleton fun provideRuntimeVersionSubscriptionPool( chainDao: ChainDao, runtimeSyncService: RuntimeSyncService )</ID>
    <ID>FunctionSignature:ChainRegistryModule.kt$ChainRegistryModule$@Provides @Singleton fun provideTypesFetcher( networkApiCreator: NetworkApiCreator )</ID>
    <ID>FunctionSignature:ChainSelectContent.kt$@Composable fun ChainAllItem( isSelected: Boolean, onSelected: (ChainItemState?) -&gt; Unit )</ID>
    <ID>FunctionSignature:ChainSelectContent.kt$@Composable fun ChainItem( state: ChainItemState, onSelected: (ChainItemState?) -&gt; Unit )</ID>
    <ID>FunctionSignature:ChainSelector.kt$@Composable fun ChainSelector( selectorViewState: ChainSelectorViewState, onChangeChainClick: () -&gt; Unit )</ID>
    <ID>FunctionSignature:ChainStateRepository.kt$ChainStateRepository$private fun currentBlockStorageKey(runtime: RuntimeSnapshot)</ID>
    <ID>FunctionSignature:ChangeBalance.kt$@Composable fun ChangeBalance( state: ChangeBalanceViewState )</ID>
    <ID>FunctionSignature:ChangeRewardDestinationInteractor.kt$ChangeRewardDestinationInteractor$suspend fun estimateFee( stashState: StakingState.Stash, rewardDestination: RewardDestination ): BigInteger</ID>
    <ID>FunctionSignature:ChildStateKey.kt$suspend fun childStateKey( builder: suspend ByteArrayOutputStream.() -&gt; Unit ): String</ID>
    <ID>FunctionSignature:Collator.kt$fun CandidateInfo.toCollator(address: String, identity: Identity?, apy: BigDecimal?)</ID>
    <ID>FunctionSignature:CollatorDetailsViewModel.kt$CollatorDetailsViewModel$private fun mapStatus(status: CandidateInfoStatus)</ID>
    <ID>FunctionSignature:CollatorDetailsViewModel.kt$CollatorDetailsViewModel$private suspend fun calculatePayload(asset: Asset, validatorStake: CollatorStakeParcelModel)</ID>
    <ID>FunctionSignature:CollatorProvider.kt$CollatorProvider$suspend fun getCollators( chain: Chain ): AccountIdMap&lt;Collator&gt;</ID>
    <ID>FunctionSignature:CollatorRecommendator.kt$CollatorRecommendator$override suspend fun recommendations(settings: RecommendationSettings&lt;Collator&gt;)</ID>
    <ID>FunctionSignature:CollatorRecommendatorFactory.kt$CollatorRecommendatorFactory$private suspend fun loadCollators(lifecycle: Lifecycle)</ID>
    <ID>FunctionSignature:CollatorsAdapter.kt$CollatorsAdapter$override fun onBindViewHolder(holder: CollatorViewHolder, position: Int, payloads: MutableList&lt;Any&gt;)</ID>
    <ID>FunctionSignature:Color.kt$fun customButtonColors( backgroundColor: Color )</ID>
    <ID>FunctionSignature:Color.kt$fun customButtonColors( backgroundColor: Color, fontColor: Color )</ID>
    <ID>FunctionSignature:Common.kt$fun testFormatter(formatter: NumberFormatter, expected: String, unformattedValue: String)</ID>
    <ID>FunctionSignature:CommonModule.kt$CommonModule$@Provides @Singleton fun provideContentResolver( context: Context ): ContentResolver</ID>
    <ID>FunctionSignature:CommonModule.kt$CommonModule$@Provides @Singleton fun provideEncryptedPreferences( preferences: Preferences, encryptionUtil: EncryptionUtil ): EncryptedPreferences</ID>
    <ID>FunctionSignature:CommonModule.kt$CommonModule$@Provides @Singleton fun provideSecretStoreV1( encryptedPreferences: EncryptedPreferences ): SecretStoreV1</ID>
    <ID>FunctionSignature:CommonModule.kt$CommonModule$@Provides @Singleton fun provideSecretStoreV2( encryptedPreferences: EncryptedPreferences )</ID>
    <ID>FunctionSignature:CommonModule.kt$CommonModule$@Provides @Singleton fun provideValidationExecutor( resourceManager: ResourceManager ): ValidationExecutor</ID>
    <ID>FunctionSignature:ComposeExt.kt$fun Modifier.toggleableWithNoIndication(value: Boolean, role: Role? = null, onValueChange: (Boolean) -&gt; Unit)</ID>
    <ID>FunctionSignature:ConfirmCreatePoolViewModel.kt$private suspend fun StakingPoolInteractor.createPool(poolSharedStateProvider: StakingPoolSharedStateProvider, address: String): Result&lt;String&gt;</ID>
    <ID>FunctionSignature:ConfirmCreatePoolViewModel.kt$private suspend fun StakingPoolInteractor.estimateCreatePoolFee(poolSharedStateProvider: StakingPoolSharedStateProvider): BigInteger</ID>
    <ID>FunctionSignature:ConfirmJoinPoolScreen.kt$@Composable fun ConfirmJoinPoolScreen(state: ConfirmJoinPoolScreenViewState, onNavigationClick: () -&gt; Unit, onConfirm: () -&gt; Unit)</ID>
    <ID>FunctionSignature:ConfirmMnemonicFragment.kt$ConfirmMnemonicFragment$override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View</ID>
    <ID>FunctionSignature:ConfirmNominationsViewModel.kt$ConfirmNominationsViewModel$private suspend fun convertToModels( validators: List&lt;Validator&gt;, token: Token ): List&lt;ValidatorModel&gt;</ID>
    <ID>FunctionSignature:ConfirmRewardDestinationViewModel.kt$ConfirmRewardDestinationViewModel$private fun sendTransaction( stashState: StakingState.Stash, rewardDestination: RewardDestination )</ID>
    <ID>FunctionSignature:ConfirmScreen.kt$@Composable fun ConfirmScreen(state: ConfirmScreenViewState, onNavigationClick: () -&gt; Unit, onConfirm: () -&gt; Unit)</ID>
    <ID>FunctionSignature:ConfirmSendContent.kt$@OptIn(ExperimentalComposeUiApi::class) @Composable fun ConfirmSendContent( state: ConfirmSendViewState, callback: ConfirmSendScreenInterface )</ID>
    <ID>FunctionSignature:ConnectionPool.kt$ConnectionPool$fun setupConnection(chain: Chain, onSelectedNodeChange: (chainId: ChainId, newNodeUrl: String) -&gt; Unit): ChainConnection</ID>
    <ID>FunctionSignature:Constants.kt$@HelperBinding fun bindNullableNumberConstant( constant: Constant, runtime: RuntimeSnapshot ): BigInteger?</ID>
    <ID>FunctionSignature:Constants.kt$@HelperBinding fun bindNumberConstant( constant: Constant, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:Constants.kt$@UseCaseBinding fun bindMaximumRewardedNominators( constant: Constant, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:Constants.kt$@UseCaseBinding fun bindSlashDeferDuration( constant: Constant, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:ContextExt.kt$fun Context.getDrawableCompat(@DrawableRes drawableRes: Int)</ID>
    <ID>FunctionSignature:ContributeValidationsModule.kt$ContributeValidationsModule$@Provides @IntoSet fun provideExistentialWarningValidation( walletConstants: WalletConstants ): ContributeValidation</ID>
    <ID>FunctionSignature:ContributeValidationsModule.kt$ContributeValidationsModule$@Provides @IntoSet fun provideMinContributionValidation( crowdloanRepository: CrowdloanRepository ): ContributeValidation</ID>
    <ID>FunctionSignature:ContributeValidationsModule.kt$ContributeValidationsModule$@Provides fun provideValidationSystem( contributeValidations: @JvmSuppressWildcards Set&lt;ContributeValidation&gt; )</ID>
    <ID>FunctionSignature:ControllerInteractor.kt$ControllerInteractor$suspend fun setController(stashAccountAddress: String, controllerAccountAddress: String, chainId: ChainId? = null): Result&lt;String&gt;</ID>
    <ID>FunctionSignature:CreateAccountDialogContent.kt$@Composable fun CreateAccountDialogContent( state: CreateAccountState, callback: CreateAccountCallback )</ID>
    <ID>FunctionSignature:CreateBackupPasswordContent.kt$@Composable internal fun CreateBackupPasswordContent( state: CreateBackupPasswordViewState, callback: CreateBackupPasswordCallback )</ID>
    <ID>FunctionSignature:CreateBackupPasswordViewModel.kt$CreateBackupPasswordViewModel$private fun createTextInputViewState( hint: String, password: String ): TextInputViewState</ID>
    <ID>FunctionSignature:CreateContactContent.kt$@Composable fun CreateContactContent( state: CreateContactViewState, callback: CreateContactScreenInterface )</ID>
    <ID>FunctionSignature:CreatePoolSetupScreen.kt$@OptIn(ExperimentalComposeUiApi::class) @Composable fun CreatePoolSetupScreen( state: CreatePoolSetupViewState, screenInterface: CreatePoolSetupScreenInterface )</ID>
    <ID>FunctionSignature:CrossChainConfirmContent.kt$@OptIn(ExperimentalComposeUiApi::class) @Composable fun CrossChainConfirmContent( state: CrossChainConfirmViewState, callback: CrossChainConfirmScreenInterface )</ID>
    <ID>FunctionSignature:CrossChainSetupContent.kt$@OptIn(ExperimentalComposeUiApi::class) @Composable fun CrossChainSetupContent( state: CrossChainSetupViewState, callback: CrossChainSetupScreenInterface )</ID>
    <ID>FunctionSignature:CrowdloanAdapter.kt$CrowdloanAdapter$override fun bindChild(holder: GroupedListHolder, position: Int, child: CrowdloanModel, payloads: List&lt;Any&gt;)</ID>
    <ID>FunctionSignature:CrowdloanAdapter.kt$CrowdloanChildHolder$fun bind( item: CrowdloanModel, handler: CrowdloanAdapter.Handler )</ID>
    <ID>FunctionSignature:CrowdloanContributeInteractor.kt$CrowdloanContributeInteractor$fun crowdloanStateFlow( parachainId: ParaId, parachainMetadata: ParachainMetadata? = null ): Flow&lt;Crowdloan&gt;</ID>
    <ID>FunctionSignature:CrowdloanContributeInteractor.kt$CrowdloanContributeInteractor$suspend fun saveEthAddress(paraId: ParaId, address: String, etheriumAddress: String)</ID>
    <ID>FunctionSignature:CrowdloanContributeViewModel.kt$CrowdloanContributeViewModel$private fun openConfirmScreen( validationPayload: ContributeValidationPayload )</ID>
    <ID>FunctionSignature:CrowdloanFeatureModule.kt$CrowdloanFeatureModule$@Provides @Singleton @Named("CrowdloanTokenUseCase") fun provideTokenUseCase( tokenRepository: TokenRepository, sharedState: CrowdloanSharedState ): TokenUseCase</ID>
    <ID>FunctionSignature:CrowdloanFeatureModule.kt$CrowdloanFeatureModule$@Provides fun provideCrowdloanSharedState( chainRegistry: ChainRegistry, preferences: Preferences )</ID>
    <ID>FunctionSignature:CrowdloanRepository.kt$CrowdloanRepository$suspend fun checkRemark(apiUrl: String, apiKey: String, address: String): Boolean</ID>
    <ID>FunctionSignature:CrowdloanRepository.kt$CrowdloanRepository$suspend fun getContribution(chainId: ChainId, accountId: AccountId, paraId: ParaId, fundIndex: FundIndex): Contribution?</ID>
    <ID>FunctionSignature:CrowdloanRepository.kt$CrowdloanRepository$suspend fun saveEthAddress(paraId: ParaId, address: String, ethAddress: String)</ID>
    <ID>FunctionSignature:CrowdloanRepositoryImpl.kt$CrowdloanRepositoryImpl$override suspend fun checkRemark(apiUrl: String, apiKey: String, address: String)</ID>
    <ID>FunctionSignature:CrowdloanRepositoryImpl.kt$CrowdloanRepositoryImpl$override suspend fun saveEthAddress(paraId: ParaId, address: String, ethAddress: String)</ID>
    <ID>FunctionSignature:CrowdloanStorage.kt$CrowdloanStorage$fun saveEthAddress(paraId: ParaId, address: String, ethAddress: String)</ID>
    <ID>FunctionSignature:CrowdloanViewModel.kt$CrowdloanViewModel$private fun mapCrowdloanStatusToUi(statusClass: KClass&lt;out Crowdloan.State&gt;, statusCount: Int): CrowdloanStatusModel?</ID>
    <ID>FunctionSignature:CurrencyItem.kt$fun FixedListBottomSheet.currencyItem(@StringRes label: Int, valueText: String, fiatValueText: String?)</ID>
    <ID>FunctionSignature:CurrentValidatorsAdapter.kt$CurrentValidatorsDiffCallback$override fun areGroupContentsTheSame(oldItem: NominatedValidatorStatusModel, newItem: NominatedValidatorStatusModel): Boolean</ID>
    <ID>FunctionSignature:CurrentValidatorsAdapter.kt$CurrentValidatorsDiffCallback$override fun areGroupItemsTheSame(oldItem: NominatedValidatorStatusModel, newItem: NominatedValidatorStatusModel): Boolean</ID>
    <ID>FunctionSignature:CurrentValidatorsViewModel.kt$CurrentValidatorsViewModel$private fun mapNominatedValidatorStatusToUiModel(statusGroup: NominatedValidator.Status.Group)</ID>
    <ID>FunctionSignature:CustomBlockProducersAdapter.kt$BlockProducerDiffCallback$override fun areContentsTheSame( oldItem: SearchBlockProducerModel, newItem: SearchBlockProducerModel ): Boolean</ID>
    <ID>FunctionSignature:CustomBlockProducersAdapter.kt$BlockProducerDiffCallback$override fun areItemsTheSame( oldItem: SearchBlockProducerModel, newItem: SearchBlockProducerModel ): Boolean</ID>
    <ID>FunctionSignature:CustomBlockProducersAdapter.kt$BlockProducerDiffCallback$override fun getChangePayload( oldItem: SearchBlockProducerModel, newItem: SearchBlockProducerModel ): Any</ID>
    <ID>FunctionSignature:CustomContributeFragment.kt$CustomContributeFragment$override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View?</ID>
    <ID>FunctionSignature:CustomContributeManager.kt$CustomContributeManager$fun createView(flowType: String, context: Context, step: MoonbeamCrowdloanStep): CustomContributeView</ID>
    <ID>FunctionSignature:CustomContributeManager.kt$CustomContributeManager$private fun noFactoryFound(flowType: String): Nothing</ID>
    <ID>FunctionSignature:CustomContributeManager.kt$CustomContributeManager$private fun relevantFactoryOrNull( flowType: String ): CustomContributeFactory?</ID>
    <ID>FunctionSignature:CustomContributeModule.kt$CustomContributeModule$@Provides fun provideCustomContributionManager( factories: @JvmSuppressWildcards Set&lt;CustomContributeFactory&gt; )</ID>
    <ID>FunctionSignature:CustomContributeViewModel.kt$CustomContributeViewModel$private fun maybeGoToNext(fee: BigDecimal, bonusPayload: BonusPayload? = null, signature: String? = null)</ID>
    <ID>FunctionSignature:DbStorageCache.kt$private fun mapStorageEntryFromLocal( storageEntryLocal: StorageEntryLocal )</ID>
    <ID>FunctionSignature:DbStorageCache.kt$private fun mapStorageEntryToLocal( storageEntry: StorageEntry, chainId: String )</ID>
    <ID>FunctionSignature:DelegationRecyclerViewAdapter.kt$DelegationDiffCallback$override fun areContentsTheSame(oldItem: DelegatorViewState.CollatorDelegationModel, newItem: DelegatorViewState.CollatorDelegationModel): Boolean</ID>
    <ID>FunctionSignature:DelegationRecyclerViewAdapter.kt$DelegationDiffCallback$override fun areItemsTheSame(oldItem: DelegatorViewState.CollatorDelegationModel, newItem: DelegatorViewState.CollatorDelegationModel): Boolean</ID>
    <ID>FunctionSignature:DelegationRecyclerViewAdapter.kt$DelegationViewHolder$fun bind(item: DelegatorViewState.CollatorDelegationModel, itemHandler: DelegationRecyclerViewAdapter.DelegationHandler)</ID>
    <ID>FunctionSignature:DragAndDropTouchHelperCallback.kt$DragAndDropTouchHelperCallback$override fun onMove(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder): Boolean</ID>
    <ID>FunctionSignature:DynamicListSheetAdapter.kt$DynamicListSheetAdapter.Holder$open fun bind(item: T, isSelected: Boolean, handler: Handler&lt;T&gt;)</ID>
    <ID>FunctionSignature:EditPoolConfirmViewModel.kt$EditPoolConfirmViewModel$private suspend fun createRoleState(role: AccountId?, prefix: Short, title: String): TitleValueViewState</ID>
    <ID>FunctionSignature:EncryptionTypeChooserBottomSheetDialog.kt$EncryptionTypeViewHolder$override fun bind(item: CryptoTypeModel, isSelected: Boolean, handler: DynamicListSheetAdapter.Handler&lt;CryptoTypeModel&gt;)</ID>
    <ID>FunctionSignature:Era.kt$@UseCaseBinding fun bindActiveEra( scale: String, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:Era.kt$@UseCaseBinding fun bindCurrentEra( scale: String, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:Era.kt$@UseCaseBinding fun bindCurrentIndex( scale: String, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:Era.kt$@UseCaseBinding fun bindCurrentSlot( scale: String, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:Era.kt$@UseCaseBinding fun bindErasStartSessionIndex( scale: String, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:Error.kt$fun noValidatorPrefs(accountIdHex: String): Nothing</ID>
    <ID>FunctionSignature:Error.kt$fun notElected(accountIdHex: String): Nothing</ID>
    <ID>FunctionSignature:EthereumDerivationPathTransformer.kt$EthereumDerivationPathTransformer$override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int)</ID>
    <ID>FunctionSignature:EthereumDerivationPathTransformer.kt$EthereumDerivationPathTransformer$override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int)</ID>
    <ID>FunctionSignature:Events.kt$@HelperBinding fun &lt;E&gt; bindEventRecord( dynamicInstance: Any?, eventBinder: (GenericEvent.Instance) -&gt; E ): EventRecord&lt;E&gt;</ID>
    <ID>FunctionSignature:ExpandableLazyListNestedScrollConnection.kt$ExpandableLazyListNestedScrollConnection$override fun onPostScroll(consumed: Offset, available: Offset, source: NestedScrollSource): Offset</ID>
    <ID>FunctionSignature:ExperimentalFragment.kt$ExperimentalFragment$override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?)</ID>
    <ID>FunctionSignature:ExportExt.kt$fun &lt;T : Schema&lt;T&gt;&gt; EncodableStruct&lt;T&gt;?.buildChainAccountOptions( isEthereumBased: Boolean ): MutableSet&lt;ExportSource&gt;</ID>
    <ID>FunctionSignature:ExportExt.kt$fun &lt;T : Schema&lt;T&gt;&gt; EncodableStruct&lt;T&gt;?.buildMainAccountOptions( isEthereumBased: Boolean ): MutableSet&lt;ExportSource&gt;</ID>
    <ID>FunctionSignature:ExportExt.kt$inline fun &lt;reified T : Schema&lt;T&gt;&gt; EncodableStruct&lt;T&gt;?.buildExportSourceTypes(isEthereumBased: Boolean): Set&lt;ExportSource&gt;</ID>
    <ID>FunctionSignature:ExportJsonConfirmFragment.kt$ExportJsonConfirmFragment$@Deprecated("Deprecated in Java") override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?)</ID>
    <ID>FunctionSignature:ExportJsonConfirmFragment.kt$ExportJsonConfirmFragment$override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View</ID>
    <ID>FunctionSignature:ExportJsonPasswordFragment.kt$ExportJsonPasswordFragment$override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View</ID>
    <ID>FunctionSignature:ExportJsonPasswordFragment.kt$ExportJsonPasswordFragment.Companion$fun getBundle(metaId: Long, chainId: ChainId, isExportWallet: Boolean)</ID>
    <ID>FunctionSignature:ExportMnemonicFragment.kt$ExportMnemonicFragment$override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View</ID>
    <ID>FunctionSignature:ExportMnemonicFragment.kt$ExportMnemonicFragment.Companion$fun getBundle(metaId: Long, chainId: ChainId, isExportWallet: Boolean)</ID>
    <ID>FunctionSignature:ExportSeedFragment.kt$ExportSeedFragment$override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View?</ID>
    <ID>FunctionSignature:ExportSeedFragment.kt$ExportSeedFragment.Companion$fun getBundle(metaId: Long, chainId: ChainId, isExportWallet: Boolean = false)</ID>
    <ID>FunctionSignature:ExportSeedViewModel.kt$ExportSeedViewModel$private fun seedFromEntropy(secret: EncodableStruct&lt;MetaAccountSecrets&gt;?)</ID>
    <ID>FunctionSignature:Exposure.kt$@UseCaseBinding fun bindExposure(scale: String, runtime: RuntimeSnapshot, type: Type&lt;*&gt;): Exposure?</ID>
    <ID>FunctionSignature:Ext.kt$fun String.camelCaseToCapitalizedWords()</ID>
    <ID>FunctionSignature:Extensions.kt$fun &lt;K&gt; CompoundButton.bindFromMap(key: K, map: Map&lt;out K, MutableStateFlow&lt;Boolean&gt;&gt;, lifecycleScope: LifecycleCoroutineScope)</ID>
    <ID>FunctionSignature:ExternalActionsUi.kt$fun &lt;T&gt; BaseBottomSheetDialogFragment&lt;T&gt;.setupExternalActions(viewModel: T)</ID>
    <ID>FunctionSignature:ExternalActionsUi.kt$fun &lt;T&gt; BaseComposeBottomSheetDialogFragment&lt;T&gt;.setupExternalActions(viewModel: T)</ID>
    <ID>FunctionSignature:Extrinsic.kt$fun ExtrinsicBuilder.swap( dexId: Int, inputAssetId: String, outputAssetId: String, amount: BigInteger, limit: BigInteger, filter: String, markets: List&lt;String&gt;, desired: WithDesired )</ID>
    <ID>FunctionSignature:ExtrinsicBuilderExt.kt$@Deprecated("Replace with createPoolBouncer when polkadot runtime upgrades to 9390", replaceWith = ReplaceWith("ExtrinsicBuilder.createPoolBouncer")) fun ExtrinsicBuilder.createPoolStateToggler(amount: BigInteger, root: MultiAddress, nominator: MultiAddress, stateToggler: MultiAddress): ExtrinsicBuilder</ID>
    <ID>FunctionSignature:ExtrinsicBuilderExt.kt$fun ExtrinsicBuilder.createPoolBouncer(amount: BigInteger, root: MultiAddress, nominator: MultiAddress, stateToggler: MultiAddress): ExtrinsicBuilder</ID>
    <ID>FunctionSignature:ExtrinsicBuilderExt.kt$fun ExtrinsicBuilder.withdrawUnbondedFromPool(memberAccountId: AccountId, numSlashingSpans: BigInteger = BigInteger.ZERO): ExtrinsicBuilder</ID>
    <ID>FunctionSignature:ExtrinsicBuilderExt.kt$fun ExtrinsicBuilder.withdrawUnbondedFromPool(memberAccountId: MultiAddress, numSlashingSpans: BigInteger = BigInteger.ZERO): ExtrinsicBuilder</ID>
    <ID>FunctionSignature:ExtrinsicDetailFragment.kt$ExtrinsicDetailFragment$private fun showExternalAddressActions( address: String )</ID>
    <ID>FunctionSignature:ExtrinsicStatusEvent.kt$@HelperBinding fun bindExtrinsicStatus( dynamicInstance: GenericEvent.Instance, runtime: RuntimeSnapshot ): ExtrinsicStatusEvent</ID>
    <ID>FunctionSignature:ExtrinsicStatusEvent.kt$@UseCaseBinding fun bindExtrinsicStatusEventRecords( scale: String, runtime: RuntimeSnapshot ): List&lt;EventRecord&lt;ExtrinsicStatusEvent&gt;&gt;</ID>
    <ID>FunctionSignature:FearlessCorneredShape.kt$FearlessCorneredShape$override fun createOutline(size: Size, layoutDirection: LayoutDirection, density: Density): Outline</ID>
    <ID>FunctionSignature:FearlessCorneredShape.kt$FearlessCorneredShape$private fun drawPath(size: Size, cornerRadius: Float, cornerCutLength: Float): Path</ID>
    <ID>FunctionSignature:FearlessLibExt.kt$fun Module.numberConstant(name: String, runtimeSnapshot: RuntimeSnapshot)</ID>
    <ID>FunctionSignature:FearlessLibExt.kt$fun Module.optionalNumberConstant(name: String, runtimeSnapshot: RuntimeSnapshot)</ID>
    <ID>FunctionSignature:FearlessLibExt.kt$fun SeedFactory.createSeed32(length: Mnemonic.Length, password: String?)</ID>
    <ID>FunctionSignature:FearlessLibExt.kt$fun String.u32ArgumentFromStorageKey()</ID>
    <ID>FunctionSignature:FearlessLibExt.kt$fun SubstrateSeedFactory.deriveSeed32(mnemonicWords: String, password: String?)</ID>
    <ID>FunctionSignature:FeeInfo.kt$@Composable fun FeeInfo(state: FeeInfoViewState, modifier: Modifier = Modifier, tooltipClick: () -&gt; Unit = emptyClick)</ID>
    <ID>FunctionSignature:FeeLoaderMixin.kt$FeeLoaderMixin.Presentation$fun requireFee( block: (BigDecimal) -&gt; Unit, onError: (title: String, message: String) -&gt; Unit )</ID>
    <ID>FunctionSignature:FeeLoaderMixin.kt$fun FeeLoaderMixin.Presentation.requireFee( viewModel: BaseViewModel, block: (BigDecimal) -&gt; Unit )</ID>
    <ID>FunctionSignature:FeeLoaderProvider.kt$FeeLoaderProvider$override fun requireFee( block: (BigDecimal) -&gt; Unit, onError: (title: String, message: String) -&gt; Unit )</ID>
    <ID>FunctionSignature:FeeUI.kt$fun displayFeeStatus( feeStatus: FeeStatus, feeViews: FeeViews )</ID>
    <ID>FunctionSignature:FeeUI.kt$private fun feeProgressShown( shown: Boolean, feeViews: FeeViews )</ID>
    <ID>FunctionSignature:FixedListBottomSheet.kt$fun FixedListBottomSheet.item(@DrawableRes icon: Int, @StringRes titleRes: Int, onClick: (View) -&gt; Unit)</ID>
    <ID>FunctionSignature:FixedListBottomSheet.kt$fun FixedListBottomSheet.item(@DrawableRes icon: Int, title: String, onClick: (View) -&gt; Unit)</ID>
    <ID>FunctionSignature:FlowExt.kt$inline fun &lt;T&gt; Flow&lt;T&gt;.observe( scope: LifecycleCoroutineScope, noinline collector: suspend (T) -&gt; Unit )</ID>
    <ID>FunctionSignature:FrozenTokensContent.kt$@Composable fun FrozenTokensContent( state: FrozenTokensContentViewState )</ID>
    <ID>FunctionSignature:FrozenTokensFragment.kt$FrozenTokensFragment.Companion$fun getBundle( frozenAssetPayload: FrozenAssetPayload )</ID>
    <ID>FunctionSignature:FundInfo.kt$fun bindFundInfo(scale: String, runtime: RuntimeSnapshot, paraId: ParaId): FundInfo</ID>
    <ID>FunctionSignature:GetMoreXorContent.kt$@OptIn(ExperimentalComposeUiApi::class) @Composable fun GetMoreXorContent( callback: GetMoreXorScreenInterface )</ID>
    <ID>FunctionSignature:GetSoraCardFragment.kt$GetSoraCardFragment$@ExperimentalMaterialApi @Composable override fun Content(padding: PaddingValues, scrollState: ScrollState, modalBottomSheetState: ModalBottomSheetState)</ID>
    <ID>FunctionSignature:GetSoraCardScreen.kt$@Composable private fun BlacklistedCountries( onSeeListClicked: (String) -&gt; Unit )</ID>
    <ID>FunctionSignature:GetSoraCardScreen.kt$@Composable private fun FreeCardIssuance( state: GetSoraCardState )</ID>
    <ID>FunctionSignature:GroupedListAdapter.kt$GroupedListAdapter$@Suppress("UNCHECKED_CAST") override fun onBindViewHolder(holder: GroupedListHolder, position: Int, payloads: List&lt;Any&gt;)</ID>
    <ID>FunctionSignature:GroupedListAdapter.kt$GroupedListAdapter$override fun onCreateViewHolder( parent: ViewGroup, viewType: Int ): GroupedListHolder</ID>
    <ID>FunctionSignature:Helpers.kt$fun ChainLocal.assetOf( assetId: String, symbol: String, )</ID>
    <ID>FunctionSignature:Helpers.kt$fun ChainLocal.nodeOf( link: String, )</ID>
    <ID>FunctionSignature:Helpers.kt$fun chainOf( id: String, name: String = id, )</ID>
    <ID>FunctionSignature:HiddenAssetsItem.kt$@Composable fun HiddenAssetsItem( state: HiddenItemState, onClick: () -&gt; Unit )</ID>
    <ID>FunctionSignature:IdentityRepositoryImpl.kt$IdentityRepositoryImpl$override suspend fun getIdentitiesFromAddresses(chain: Chain, accountAddresses: List&lt;String&gt;): AccountAddressMap&lt;Identity?&gt;</ID>
    <ID>FunctionSignature:IdentityRepositoryImpl.kt$IdentityRepositoryImpl$override suspend fun getIdentitiesFromIds( chain: Chain, accountIdsHex: List&lt;String&gt; ): AccountIdMap&lt;Identity?&gt;</ID>
    <ID>FunctionSignature:IdentityRepositoryImpl.kt$IdentityRepositoryImpl$override suspend fun getIdentitiesFromIdsBytes(chain: Chain, accountIdsBytes: List&lt;ByteArray&gt;): AccountIdMap&lt;Identity?&gt;</ID>
    <ID>FunctionSignature:ImportAccountFragment.kt$ImportAccountFragment$@Deprecated("Deprecated in Java") override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?)</ID>
    <ID>FunctionSignature:ImportAccountFragment.kt$ImportAccountFragment$private fun setupAdvancedBlock(blockchainType: ImportAccountType, sourceType: ImportSource, isChainAccount: Boolean)</ID>
    <ID>FunctionSignature:ImportAccountFragment.kt$ImportAccountFragment.Companion$fun getBundle( blockChainType: Int = 0, importMode: ImportMode = ImportMode.MnemonicPhrase ): Bundle</ID>
    <ID>FunctionSignature:ImportRemoteWalletViewModel.kt$ImportRemoteWalletViewModel$private suspend fun importFromMnemonic( decryptedBackupAccount: DecryptedBackupAccount )</ID>
    <ID>FunctionSignature:InterlayContributeFactory.kt$InterlayContributeFactory$override fun createView(context: Context, step: MoonbeamCrowdloanStep?): CustomContributeView</ID>
    <ID>FunctionSignature:InterlayContributeSubmitter.kt$InterlayContributeSubmitter$override suspend fun submitOnChain(payload: BonusPayload, amount: BigDecimal, extrinsicBuilder: ExtrinsicBuilder)</ID>
    <ID>FunctionSignature:InterlayContributeView.kt$InterlayContributeView$override fun bind( viewState: CustomContributeViewState, scope: LifecycleCoroutineScope )</ID>
    <ID>FunctionSignature:InterlayContributeViewState.kt$InterlayContributeViewState$override fun createBonusPayload(referralCode: String, email: String?, agreeReceiveEmail: Boolean?)</ID>
    <ID>FunctionSignature:InterlayContributionModule.kt$InterlayContributionModule$@Provides fun provideInterlaySubmitter( interactor: InterlayContributeInteractor )</ID>
    <ID>FunctionSignature:KaruraApi.kt$KaruraApi$@GET("//{baseUrl}/referral/{referral}") suspend fun isReferralValid( @Path("baseUrl") baseUrl: String, @Path("referral") referral: String ): ReferralCheck</ID>
    <ID>FunctionSignature:KaruraApi.kt$KaruraApi$@GET("//{baseUrl}/statement") suspend fun getStatement( @Path("baseUrl") baseUrl: String ): KaruraStatement</ID>
    <ID>FunctionSignature:KaruraApi.kt$KaruraApi$@POST("//{baseUrl}/verify") suspend fun applyForBonus( @Path("baseUrl") baseUrl: String, @Body body: VerifyKaruraParticipationRequest ): Any?</ID>
    <ID>FunctionSignature:KaruraContributeFactory.kt$KaruraContributeFactory$override fun createView(context: Context, step: MoonbeamCrowdloanStep?): CustomContributeView</ID>
    <ID>FunctionSignature:KaruraContributeViewState.kt$KaruraContributeViewState$override fun createBonusPayload(referralCode: String, email: String?, agreeReceiveEmail: Boolean?): ReferralCodePayload</ID>
    <ID>FunctionSignature:KaruraContributionModule.kt$KaruraContributionModule$@Provides fun provideKaruraApi( networkApiCreator: NetworkApiCreator )</ID>
    <ID>FunctionSignature:KaruraContributionModule.kt$KaruraContributionModule$@Provides fun provideKaruraSubmitter( interactor: KaruraContributeInteractor )</ID>
    <ID>FunctionSignature:KoltinExt.kt$inline fun &lt;T&gt; Collection&lt;T&gt;.sumByBigDecimal(extractor: (T) -&gt; BigDecimal): BigDecimal</ID>
    <ID>FunctionSignature:KoltinExt.kt$inline fun &lt;T&gt; List&lt;T&gt;.sumByBigInteger(extractor: (T) -&gt; BigInteger): BigInteger</ID>
    <ID>FunctionSignature:LanguagesAdapter.kt$LanguageViewHolder$fun bind(language: LanguageModel, handler: LanguagesAdapter.LanguagesItemHandler, isChecked: Boolean)</ID>
    <ID>FunctionSignature:LeaseIndexFromBlock.kt$fun leaseIndexFromBlock(block: BigInteger, blocksPerLeasePeriod: BigInteger, leaseOffset: BigInteger)</ID>
    <ID>FunctionSignature:LiveDatExt.kt$fun &lt;FROM, TO&gt; LiveData&lt;FROM&gt;.switchMap( mapper: (FROM) -&gt; LiveData&lt;TO&gt; )</ID>
    <ID>FunctionSignature:LiveDatExt.kt$fun &lt;FROM, TO&gt; LiveData&lt;FROM&gt;.switchMap( mapper: (FROM) -&gt; LiveData&lt;TO&gt;, triggerOnSwitch: Boolean ): LiveData&lt;TO&gt;</ID>
    <ID>FunctionSignature:LiveDatExt.kt$fun &lt;R&gt; combine( vararg sources: LiveData&lt;*&gt;, combiner: (ComponentHolder) -&gt; R ): LiveData&lt;R&gt;</ID>
    <ID>FunctionSignature:LiveDatExt.kt$fun &lt;R&gt; mediateWith( vararg sources: LiveData&lt;*&gt;, combiner: (ComponentHolder) -&gt; R? ): LiveData&lt;R&gt;</ID>
    <ID>FunctionSignature:LocalStorageSource.kt$LocalStorageSource$override suspend fun query(key: String, chainId: String, at: BlockHash?): String?</ID>
    <ID>FunctionSignature:LocalStorageSource.kt$LocalStorageSource$override suspend fun queryChildState(storageKey: String, childKey: String, chainId: String): String?</ID>
    <ID>FunctionSignature:LocalStorageSource.kt$LocalStorageSource$override suspend fun queryKeys(keys: List&lt;String&gt;, chainId: String, at: BlockHash?): Map&lt;String, String?&gt;</ID>
    <ID>FunctionSignature:LockBottomSheetBehavior.kt$LockBottomSheetBehavior$override fun onInterceptTouchEvent(parent: CoordinatorLayout, child: V, event: MotionEvent): Boolean</ID>
    <ID>FunctionSignature:LockBottomSheetBehavior.kt$LockBottomSheetBehavior$override fun onTouchEvent(parent: CoordinatorLayout, child: V, event: MotionEvent): Boolean</ID>
    <ID>FunctionSignature:MainFragment.kt$MainFragment$private fun isAtHomeTab(destination: NavDestination)</ID>
    <ID>FunctionSignature:ManagePoolStakeScreen.kt$@OptIn(ExperimentalMaterialApi::class) @Composable fun ManagePoolStakeScreen( state: ManagePoolStakeViewState, screenInterface: ManagePoolStakeScreenInterface )</ID>
    <ID>FunctionSignature:ManualRewardCalculator.kt$ManualRewardCalculator$private fun calculateCompoundReward(amount: Double, days: Int, dailyPercentage: Double): BigDecimal</ID>
    <ID>FunctionSignature:ManualRewardCalculator.kt$ManualRewardCalculator$private fun calculateSimpleReward(amount: Double, days: Int, dailyPercentage: Double): BigDecimal</ID>
    <ID>FunctionSignature:MapFeeToFeeModel.kt$fun mapFeeToFeeModel( fee: BigDecimal, token: Token )</ID>
    <ID>FunctionSignature:MapRewardDestinationModelToRewardDestination.kt$fun mapRewardDestinationModelToRewardDestination( rewardDestinationModel: RewardDestinationModel ): RewardDestination</ID>
    <ID>FunctionSignature:Mappers.kt$fun mapChainAccountToAccount( parent: MetaAccount, chainAccount: MetaAccount.ChainAccount ): Account</ID>
    <ID>FunctionSignature:Mappers.kt$fun mapCryptoTypeToCryptoTypeModel( resourceManager: ResourceManager, encryptionType: CryptoType ): CryptoTypeModel</ID>
    <ID>FunctionSignature:Mappers.kt$fun mapMetaAccountLocalToLightMetaAccount( metaAccountLocal: MetaAccountLocal ): LightMetaAccount</ID>
    <ID>FunctionSignature:Mappers.kt$private fun mapSectionTypeLocalToSectionType(sectionType: String): Chain.ExternalApi.Section.Type</ID>
    <ID>FunctionSignature:Mappers.kt$private fun mapToList(json: String?)</ID>
    <ID>FunctionSignature:Market.kt$fun List&lt;Market&gt;.backStrings(): List&lt;String&gt;</ID>
    <ID>FunctionSignature:Market.kt$fun List&lt;Market&gt;.toFilters(): String</ID>
    <ID>FunctionSignature:MnemonicAgreementsDialog.kt$MnemonicAgreementsDialog.Companion$fun getBundle( isFromGoogleBackupKey: Boolean, accountName: String ): Bundle</ID>
    <ID>FunctionSignature:MnemonicContainerView.kt$MnemonicContainerView$override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int)</ID>
    <ID>FunctionSignature:MnemonicWords.kt$@Composable fun MnemonicWords( mnemonicWords: List&lt;MnemonicWordModel&gt;, modifier: Modifier = Modifier )</ID>
    <ID>FunctionSignature:MnemonicWords.kt$@Composable private fun MnemonicWordNumber( number: String, modifier: Modifier = Modifier )</ID>
    <ID>FunctionSignature:MnemonicWords.kt$@Composable private fun MnemonicWordsColumn( modifier: Modifier = Modifier, mnemonicWords: List&lt;MnemonicWordModel&gt; )</ID>
    <ID>FunctionSignature:MnemonicWords.kt$@Preview @Composable fun MnemonicWordsPreview( modifier: Modifier = Modifier )</ID>
    <ID>FunctionSignature:MockitoHelpers.kt$fun &lt;T&gt; whenever(methodCall: T): OngoingStubbing&lt;T&gt;</ID>
    <ID>FunctionSignature:MoonbeamApi.kt$MoonbeamApi$@GET("//{apiUrl}/health") suspend fun getHealth( @Path("apiUrl") apiUrl: String, @Header("x-api-key") apiKey: String )</ID>
    <ID>FunctionSignature:MoonbeamContributeInteractor.kt$MoonbeamContributeInteractor$suspend fun doSystemRemark(apiUrl: String, apiKey: String, chainId: ChainId): Boolean</ID>
    <ID>FunctionSignature:MoonbeamContributeInteractor.kt$MoonbeamContributeInteractor$suspend fun getContributionSignature(apiUrl: String, apiKey: String, contribution: BigInteger, paraId: ParaId, chainId: ChainId): String</ID>
    <ID>FunctionSignature:MoonbeamContributeInteractor.kt$MoonbeamContributeInteractor$suspend fun getSystemRemarkFee(apiUrl: String, apiKey: String, chainId: ChainId): BigInteger</ID>
    <ID>FunctionSignature:MoonbeamContributeSubmitter.kt$MoonbeamContributeSubmitter$override suspend fun submitOnChain(payload: BonusPayload, amount: BigDecimal, extrinsicBuilder: ExtrinsicBuilder)</ID>
    <ID>FunctionSignature:MoonbeamContributionModule.kt$MoonbeamContributionModule$@Provides fun provideMoonbeamSubmitter( interactor: MoonbeamContributeInteractor )</ID>
    <ID>FunctionSignature:MultiAddress.kt$fun bindMultiAddressId(dynamicInstance: DictEnum.Entry&lt;*&gt;)</ID>
    <ID>FunctionSignature:MultiToggleButton.kt$@Composable fun &lt;T : MultiToggleItem&gt; MultiToggleButton( state: MultiToggleButtonState&lt;T&gt;, onToggleChange: (T) -&gt; Unit )</ID>
    <ID>FunctionSignature:Navigator.kt$Navigator$override fun getExportMnemonicDestination(metaId: Long, chainId: ChainId, isExportWallet: Boolean): DelayedNavigation</ID>
    <ID>FunctionSignature:Navigator.kt$Navigator$override fun getExportSeedDestination(metaId: Long, chainId: ChainId, isExportWallet: Boolean): DelayedNavigation</ID>
    <ID>FunctionSignature:Navigator.kt$Navigator$override fun openAlert(payload: AlertViewState, resultKey: String, resultDestinationId: Int)</ID>
    <ID>FunctionSignature:Navigator.kt$Navigator$override fun openExportJsonPasswordDestination(metaId: Long, chainId: ChainId, isExportWallet: Boolean): DelayedNavigation</ID>
    <ID>FunctionSignature:Navigator.kt$Navigator$override fun openImportAccountScreen( blockChainType: Int, importMode: ImportMode )</ID>
    <ID>FunctionSignature:Navigator.kt$Navigator$override fun openMnemonicAgreementsDialog( isFromGoogleBackup: Boolean, accountName: String )</ID>
    <ID>FunctionSignature:Navigator.kt$Navigator$override fun openMnemonicDialog( isFromGoogleBackup: Boolean, accountName: String )</ID>
    <ID>FunctionSignature:Navigator.kt$Navigator$override fun openOnboardingNavGraph(chainId: ChainId, metaId: Long, isImport: Boolean)</ID>
    <ID>FunctionSignature:Navigator.kt$Navigator$override fun openOperationSuccess(operationHash: String?, chainId: ChainId, customMessage: String?)</ID>
    <ID>FunctionSignature:Navigator.kt$Navigator$override fun openSelectAsset(chainId: ChainId, selectedAssetId: String?, excludeAssetId: String?)</ID>
    <ID>FunctionSignature:Navigator.kt$Navigator$override fun openSelectAsset(chainId: ChainId, selectedAssetId: String?, isFilterXcmAssets: Boolean)</ID>
    <ID>FunctionSignature:Navigator.kt$Navigator$override fun openSend(assetPayload: AssetPayload?, initialSendToAddress: String?, currencyId: String?)</ID>
    <ID>FunctionSignature:Navigator.kt$Navigator$override fun openSwapPreviewDialog(swapDetailsViewState: SwapDetailsViewState, parcelModel: SwapDetailsParcelModel)</ID>
    <ID>FunctionSignature:Navigator.kt$Navigator$override fun openSwapTokensScreen(chainId: String, assetIdFrom: String?, assetIdTo: String?)</ID>
    <ID>FunctionSignature:Navigator.kt$Navigator$override fun setAlertResult(key: String, result: Result&lt;*&gt;, resultDestinationId: Int?)</ID>
    <ID>FunctionSignature:NetworkIssueItem.kt$@Composable fun NetworkIssueItem( state: NetworkIssueItemState, onClick: () -&gt; Unit )</ID>
    <ID>FunctionSignature:NetworkModule.kt$NetworkModule$@Provides @Singleton fun httpExceptionHandler( resourceManager: ResourceManager ): HttpExceptionHandler</ID>
    <ID>FunctionSignature:NetworkModule.kt$NetworkModule$@Provides @Singleton fun provideApiCreator( okHttpClient: OkHttpClient ): NetworkApiCreator</ID>
    <ID>FunctionSignature:NetworkModule.kt$NetworkModule$@Provides @Singleton fun provideOkHttpClient( context: Context ): OkHttpClient</ID>
    <ID>FunctionSignature:NftStub.kt$@Composable fun NftStub( modifier: Modifier = Modifier )</ID>
    <ID>FunctionSignature:NodesSettingsScenario.kt$NodesSettingsScenario$suspend fun addNode(chainId: ChainId, nodeName: String, nodeHost: String): Result&lt;Unit&gt;</ID>
    <ID>FunctionSignature:NodesSettingsScenario.kt$NodesSettingsScenario$suspend fun updateNode(id: NodeId, name: String, url: String): Result&lt;Unit&gt;</ID>
    <ID>FunctionSignature:NodesSettingsScenarioImpl.kt$NodesSettingsScenarioImpl$override suspend fun addNode(chainId: ChainId, nodeName: String, nodeHost: String)</ID>
    <ID>FunctionSignature:NodesSettingsScenarioImpl.kt$NodesSettingsScenarioImpl$override suspend fun updateNode(id: NodeId, name: String, url: String)</ID>
    <ID>FunctionSignature:NominationPools.kt$@UseCaseBinding fun bindBondedPool( scale: String?, runtime: RuntimeSnapshot ): BondedPool?</ID>
    <ID>FunctionSignature:NominationPools.kt$@UseCaseBinding fun bindBondedPoolsMetadata( scale: String, runtime: RuntimeSnapshot ): String</ID>
    <ID>FunctionSignature:NominationPools.kt$@UseCaseBinding fun bindExistingPools( scale: String?, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:NominationPools.kt$@UseCaseBinding fun bindLastPoolId( scale: String?, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:NominationPools.kt$@UseCaseBinding fun bindMaxMembersInPool( scale: String?, runtime: RuntimeSnapshot ): BigInteger?</ID>
    <ID>FunctionSignature:NominationPools.kt$@UseCaseBinding fun bindMaxPoolMembers( scale: String?, runtime: RuntimeSnapshot ): BigInteger?</ID>
    <ID>FunctionSignature:NominationPools.kt$@UseCaseBinding fun bindMaxPools( scale: String?, runtime: RuntimeSnapshot ): BigInteger?</ID>
    <ID>FunctionSignature:NominationPools.kt$@UseCaseBinding fun bindMinCreateBond( scale: String, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:NominationPools.kt$@UseCaseBinding fun bindMinJoinBond( scale: String, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:NominationPools.kt$@UseCaseBinding fun bindPoolsCount( scale: String?, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:NominationPools.kt$@UseCaseBinding fun bindRewardPool( scale: String?, runtime: RuntimeSnapshot ): PoolRewards?</ID>
    <ID>FunctionSignature:NotZeroBalanceValidation.kt$NotZeroBalanceValidation$override suspend fun validate(value: SetControllerValidationPayload): ValidationStatus&lt;SetControllerValidationFailure&gt;</ID>
    <ID>FunctionSignature:NumberFormatters.kt$fun Long.formatDateTime(context: Context)</ID>
    <ID>FunctionSignature:ObserveBrowserEvents.kt$fun &lt;T&gt; BaseComposeBottomSheetDialogFragment&lt;T&gt;.observeBrowserEvents(viewModel: T)</ID>
    <ID>FunctionSignature:ObserveValidations.kt$fun BaseFragment&lt;*&gt;.observeValidations( viewModel: Validatable, dialogContext: Context = requireContext() )</ID>
    <ID>FunctionSignature:OnboardingRouter.kt$OnboardingRouter$fun openMnemonicAgreementsDialog( isFromGoogleBackup: Boolean, accountName: String )</ID>
    <ID>FunctionSignature:OperationMappers.kt$fun TxHistoryItem.toOperation(chain: Chain, chainAsset: Asset, accountAddress: String, filters: Set&lt;TransactionFilter&gt;): Operation?</ID>
    <ID>FunctionSignature:OperationMappers.kt$fun mapNodeToOperation( node: SubqueryHistoryElementResponse.Query.HistoryElements.Node, tokenType: Asset ): Operation</ID>
    <ID>FunctionSignature:OperationMappers.kt$fun mapOperationToOperationLocalDb( operation: Operation, source: OperationLocal.Source ): OperationLocal</ID>
    <ID>FunctionSignature:OperationMappers.kt$fun mapOperationToParcel( operation: Operation, resourceManager: ResourceManager ): OperationParcelizeModel</ID>
    <ID>FunctionSignature:OptionsWalletContent.kt$@Composable fun OptionsWalletContent( state: OptionsWalletScreenViewState, callback: OptionsWalletCallback )</ID>
    <ID>FunctionSignature:ParachainMetadata.kt$fun mapParachainMetadataFlowRemoteToParachainMetadataFlow(flow: ParachainMetadataFlowRemote)</ID>
    <ID>FunctionSignature:ParachainMetadataApi.kt$ParachainMetadataApi$@GET suspend fun getParachainMetadata( @Url url: String ): List&lt;ParachainMetadataRemote&gt;</ID>
    <ID>FunctionSignature:ParachainMetadataParcelModel.kt$fun mapParachainMetadataFlowFromParcel( flowParcel: ParachainMetadataFlowParcelModel )</ID>
    <ID>FunctionSignature:ParachainMetadataParcelModel.kt$fun mapParachainMetadataFlowToParcel( flow: ParachainMetadataFlow )</ID>
    <ID>FunctionSignature:ParachainMetadataParcelModel.kt$fun mapParachainMetadataFromParcel( parcelModel: ParachainMetadataParcelModel )</ID>
    <ID>FunctionSignature:ParachainMetadataParcelModel.kt$fun mapParachainMetadataToParcel( parachainMetadata: ParachainMetadata )</ID>
    <ID>FunctionSignature:PaymentUpdater.kt$PaymentUpdater$private suspend fun fetchTransfers(blockHash: String, chain: Chain, accountId: AccountId)</ID>
    <ID>FunctionSignature:PayoutRepository.kt$PayoutRepository$private fun calculateValidatorReward( rewardCalculationContext: RewardCalculationContext ): BigInteger?</ID>
    <ID>FunctionSignature:PayoutsListViewModel.kt$PayoutsListViewModel$private suspend fun convertToUiModel( statistics: PendingPayoutsStatistics ): PendingPayoutsStatisticsModel</ID>
    <ID>FunctionSignature:PermissionExt.kt$suspend fun Fragment.askPermissionsSafely(vararg permissions: String): Result&lt;RuntimePermission&gt;</ID>
    <ID>FunctionSignature:PincodeFragment.kt$PincodeFragment$override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View</ID>
    <ID>FunctionSignature:Polkaswap.kt$@UseCaseBinding fun bindDexInfos( scale: String, runtime: RuntimeSnapshot ): String</ID>
    <ID>FunctionSignature:PolkaswapInteractor.kt$PolkaswapInteractor$fun observePoolReserves(fromTokenId: String, toTokenId: String, market: Market): Flow&lt;String&gt;</ID>
    <ID>FunctionSignature:PolkaswapInteractor.kt$PolkaswapInteractor$suspend fun fetchAvailableSources(tokenInput: Asset, tokenOutput: Asset, availableDexes: List&lt;Int&gt;): Set&lt;Market&gt;</ID>
    <ID>FunctionSignature:PolkaswapInteractor.kt$PolkaswapInteractor$suspend fun getAvailableDexesForPair(tokenFromId: String, tokenToId: String, dexes: List&lt;BigInteger&gt;): List&lt;Int&gt;</ID>
    <ID>FunctionSignature:PolkaswapInteractorImpl.kt$PolkaswapInteractorImpl$@OptIn(FlowPreview::class) override fun observePoolReserves(fromTokenId: String, toTokenId: String, market: Market): Flow&lt;String&gt;</ID>
    <ID>FunctionSignature:PolkaswapInteractorImpl.kt$PolkaswapInteractorImpl$override suspend fun fetchAvailableSources(tokenInput: Asset, tokenOutput: Asset, availableDexes: List&lt;Int&gt;): Set&lt;Market&gt;</ID>
    <ID>FunctionSignature:PolkaswapInteractorImpl.kt$PolkaswapInteractorImpl$override suspend fun getAvailableDexesForPair(tokenFromId: String, tokenToId: String, dexes: List&lt;BigInteger&gt;): List&lt;Int&gt;</ID>
    <ID>FunctionSignature:PolkaswapRepository.kt$PolkaswapRepository$fun observePoolXYKReserves(chainId: ChainId, fromTokenId: String, toTokenId: String): Flow&lt;String&gt;</ID>
    <ID>FunctionSignature:PolkaswapRepository.kt$PolkaswapRepository$suspend fun getAvailableSources(chainId: ChainId, tokenId1: String, tokenId2: String, dexes: List&lt;Int&gt;): Map&lt;Int, List&lt;Market&gt;&gt;</ID>
    <ID>FunctionSignature:PolkaswapRepositoryImpl.kt$PolkaswapRepositoryImpl$override fun observePoolXYKReserves(chainId: ChainId, fromTokenId: String, toTokenId: String): Flow&lt;String&gt;</ID>
    <ID>FunctionSignature:PolkaswapRepositoryImpl.kt$PolkaswapRepositoryImpl$override suspend fun getAvailableSources(chainId: ChainId, tokenId1: String, tokenId2: String, dexes: List&lt;Int&gt;): Map&lt;Int, List&lt;Market&gt;&gt;</ID>
    <ID>FunctionSignature:Preferences.kt$Preferences$fun stringFlow( field: String, initialValueProducer: InitialValueProducer&lt;String&gt;? = null ): Flow&lt;String?&gt;</ID>
    <ID>FunctionSignature:PreferencesImpl.kt$PreferencesImpl$override fun booleanFlow( field: String, initialValue: Boolean ): Flow&lt;Boolean&gt;</ID>
    <ID>FunctionSignature:PreferencesImpl.kt$PreferencesImpl$override fun intFlow( field: String, initialValue: Int ): Flow&lt;Int&gt;</ID>
    <ID>FunctionSignature:PreferencesImpl.kt$PreferencesImpl$override fun stringFlow( field: String, initialValueProducer: (suspend () -&gt; String)? ): Flow&lt;String?&gt;</ID>
    <ID>FunctionSignature:ProfileModule.kt$ProfileModule$@Provides fun provideTotalBalanceUseCase(accountRepository: AccountRepository, chainRegistry: ChainRegistry, assetDao: AssetDao): TotalBalanceUseCase</ID>
    <ID>FunctionSignature:RebondValidationFailure.kt$fun rebondValidationFailure( reason: RebondValidationFailure, resourceManager: ResourceManager ): TitleAndMessage</ID>
    <ID>FunctionSignature:RebondValidationsModule.kt$RebondValidationsModule$@Provides @Singleton fun provideEnoughToRebondValidation(stakingScenarioInteractor: StakingScenarioInteractor)</ID>
    <ID>FunctionSignature:ReceiveScreen.kt$@Composable fun ReceiveScreen( state: LoadingState&lt;ReceiveScreenViewState&gt;, callback: ReceiveScreenInterface )</ID>
    <ID>FunctionSignature:RecommendedValidatorsViewModel.kt$RecommendedValidatorsViewModel$private suspend fun convertToModels( validators: List&lt;Validator&gt;, token: Token ): List&lt;ValidatorModel&gt;</ID>
    <ID>FunctionSignature:RedeemInteractor.kt$RedeemInteractor$suspend fun estimateFee( stashState: StakingState, formExtrinsic: suspend ExtrinsicBuilder.() -&gt; Unit ): BigInteger</ID>
    <ID>FunctionSignature:RedeemValidationFailure.kt$fun redeemValidationFailure( reason: RedeemValidationFailure, resourceManager: ResourceManager ): TitleAndMessage</ID>
    <ID>FunctionSignature:RedeemValidationsModule.kt$RedeemValidationsModule$@Provides @Singleton fun provideRedeemValidationSystem( feeValidation: RedeemFeeValidation )</ID>
    <ID>FunctionSignature:ReferralContributeView.kt$ReferralContributeView$override fun bind( viewState: CustomContributeViewState, scope: LifecycleCoroutineScope )</ID>
    <ID>FunctionSignature:RemoteConfigFetcher.kt$RemoteConfigFetcher$@GET(BuildConfig.APP_CONFIG_URL) suspend fun getAppConfig( @Header("Cache-Control") noCache: String = "no-cache" ): AppConfigRemote</ID>
    <ID>FunctionSignature:RemoteStorageSource.kt$RemoteStorageSource$override suspend fun query(key: String, chainId: String, at: BlockHash?): String?</ID>
    <ID>FunctionSignature:RemoteStorageSource.kt$RemoteStorageSource$override suspend fun queryChildState(storageKey: String, childKey: String, chainId: String): String?</ID>
    <ID>FunctionSignature:RemoteStorageSource.kt$RemoteStorageSource$override suspend fun queryKeys(keys: List&lt;String&gt;, chainId: String, at: BlockHash?): Map&lt;String, String?&gt;</ID>
    <ID>FunctionSignature:RewardDestinationProvider.kt$RewardDestinationProvider$override suspend fun updateReturns(rewardCalculator: RewardCalculator, asset: Asset, amount: BigDecimal)</ID>
    <ID>FunctionSignature:RewardDestinationProvider.kt$RewardDestinationProvider$private suspend fun mapRewardDestinationToRewardDestinationModel(rewardDestination: RewardDestination): RewardDestinationModel</ID>
    <ID>FunctionSignature:RewardDestinationValidationsModule.kt$RewardDestinationValidationsModule$@Provides @Singleton fun controllerRequiredValidation( stakingScenarioInteractor: StakingScenarioInteractor )</ID>
    <ID>FunctionSignature:RewardDetailViewModel.kt$RewardDetailViewModel$private suspend fun getIcon(address: String)</ID>
    <ID>FunctionSignature:RuntimeModule.kt$RuntimeModule$@Provides @Named(LOCAL_STORAGE_SOURCE) @Singleton fun provideLocalStorageSource( chainRegistry: ChainRegistry, storageCache: StorageCache ): StorageDataSource</ID>
    <ID>FunctionSignature:RuntimeModule.kt$RuntimeModule$@Provides @Named(REMOTE_STORAGE_SOURCE) @Singleton fun provideRemoteStorageSource( chainRegistry: ChainRegistry, bulkRetriever: BulkRetriever ): StorageDataSource</ID>
    <ID>FunctionSignature:RuntimeModule.kt$RuntimeModule$@Provides @Singleton fun provideMortalityProvider( chainRegistry: ChainRegistry, rpcCalls: RpcCalls )</ID>
    <ID>FunctionSignature:RuntimeModule.kt$RuntimeModule$@Provides @Singleton fun provideStorageCache( storageDao: StorageDao ): StorageCache</ID>
    <ID>FunctionSignature:RuntimeModule.kt$RuntimeModule$@Provides @Singleton fun provideSubstrateCalls( chainRegistry: ChainRegistry )</ID>
    <ID>FunctionSignature:RuntimeProviderTest.kt$RuntimeProviderTest$private suspend fun withRuntimeFactoryFailing(exception: Exception = ChainInfoNotInCacheException, block: suspend () -&gt; Unit)</ID>
    <ID>FunctionSignature:ScannerActivity.kt$ScannerActivity$override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;String?&gt;, grantResults: IntArray)</ID>
    <ID>FunctionSignature:ScannerActivityModule.kt$ScannerActivityModule$@Provides fun provideScannerViewModel( resourceManager: ResourceManager, qrBitmapDecoder: QrBitmapDecoder ): ScannerViewModel</ID>
    <ID>FunctionSignature:SearchAssetsFragment.kt$SearchAssetsFragment$@OptIn(ExperimentalMaterialApi::class) @Composable override fun Content(padding: PaddingValues, scrollState: ScrollState, modalBottomSheetState: ModalBottomSheetState)</ID>
    <ID>FunctionSignature:SearchAssetsScreen.kt$&lt;no name provided&gt;$override fun actionItemClicked(actionType: ActionItemType, chainId: ChainId, chainAssetId: String, swipeableState: SwipeableState&lt;SwipeState&gt;)</ID>
    <ID>FunctionSignature:SearchAssetsScreen.kt$@Composable fun SearchAssetsScreen( data: SearchAssetState?, callback: SearchAssetsScreenInterface )</ID>
    <ID>FunctionSignature:SearchAssetsViewModel.kt$SearchAssetsViewModel$@OptIn(ExperimentalMaterialApi::class) override fun actionItemClicked(actionType: ActionItemType, chainId: ChainId, chainAssetId: String, swipeableState: SwipeableState&lt;SwipeState&gt;)</ID>
    <ID>FunctionSignature:SearchCustomBlockProducerInteractor.kt$SearchCustomBlockProducerInteractor$private suspend fun getCollators(lifecycle: Lifecycle)</ID>
    <ID>FunctionSignature:SearchCustomBlockProducerInteractor.kt$SearchCustomBlockProducerInteractor$private suspend fun getValidators(lifecycle: Lifecycle)</ID>
    <ID>FunctionSignature:SearchCustomBlockProducerInteractor.kt$SearchCustomBlockProducerInteractor$suspend fun blockProducerSelected(address: String, setupStakingProcess: SetupStakingSharedState, lifecycle: Lifecycle): Result&lt;Unit&gt;</ID>
    <ID>FunctionSignature:SearchCustomBlockProducerInteractor.kt$SearchCustomBlockProducerInteractor$suspend fun getIcon(address: String, sizeInDp: Int, type: Asset.StakingType): PictureDrawable</ID>
    <ID>FunctionSignature:SecretStoreV1.kt$SecretStoreV1Impl$override suspend fun saveSecuritySource(accountAddress: String, source: SecuritySource)</ID>
    <ID>FunctionSignature:SecretStoreV2.kt$SecretStoreV2$private fun chainAccountKey(metaId: Long, accountId: ByteArray, secretName: String)</ID>
    <ID>FunctionSignature:SecretStoreV2.kt$SecretStoreV2$suspend fun getChainAccountSecrets(metaId: Long, accountId: ByteArray): EncodableStruct&lt;ChainAccountSecrets&gt;?</ID>
    <ID>FunctionSignature:SecretStoreV2.kt$SecretStoreV2$suspend fun getMetaAccountSecrets(metaId: Long): EncodableStruct&lt;MetaAccountSecrets&gt;?</ID>
    <ID>FunctionSignature:SecretStoreV2.kt$SecretStoreV2$suspend fun putChainAccountSecrets(metaId: Long, accountId: ByteArray, secrets: EncodableStruct&lt;ChainAccountSecrets&gt;)</ID>
    <ID>FunctionSignature:SecretStoreV2.kt$SecretStoreV2$suspend fun putMetaAccountSecrets(metaId: Long, secrets: EncodableStruct&lt;MetaAccountSecrets&gt;)</ID>
    <ID>FunctionSignature:SecretStoreV2.kt$suspend fun SecretStoreV2.getChainAccountKeypair( metaId: Long, accountId: ByteArray ): Keypair</ID>
    <ID>FunctionSignature:SecretStoreV2.kt$suspend fun SecretStoreV2.getMetaAccountKeypair( metaId: Long, isEthereum: Boolean ): Keypair</ID>
    <ID>FunctionSignature:SecretStoreV2Test.kt$SecretStoreV2Test$private fun createChainSecrets( derivationPath: String? = null, ): EncodableStruct&lt;ChainAccountSecrets&gt;</ID>
    <ID>FunctionSignature:SecretStoreV2Test.kt$SecretStoreV2Test$private fun createMetaSecrets( derivationPath: String? = null, ): EncodableStruct&lt;MetaAccountSecrets&gt;</ID>
    <ID>FunctionSignature:SelectImportModeContent.kt$@Composable fun SelectImportModeContent( callback: SelectImportModeScreenInterface )</ID>
    <ID>FunctionSignature:SelectRewardDestinationViewModel.kt$SelectRewardDestinationViewModel$private fun goToNextStep( rewardDestination: RewardDestinationModel, fee: BigDecimal )</ID>
    <ID>FunctionSignature:SelectRewardDestinationViewModel.kt$SelectRewardDestinationViewModel$private fun mapRewardDestinationModelToRewardDestinationParcelModel(rewardDestination: RewardDestinationModel): RewardDestinationParcelModel</ID>
    <ID>FunctionSignature:SelectValidatorsScreen.kt$@Composable fun SelectValidatorsScreen( state: SelectValidatorsScreenViewState, callbacks: SelectValidatorsScreenInterface )</ID>
    <ID>FunctionSignature:SelectedValidatorsScreen.kt$@Composable private fun GroupedValidators( groups: List&lt;GroupViewState&gt;, onInfoClick: (SelectableListItemState&lt;String&gt;) -&gt; Unit )</ID>
    <ID>FunctionSignature:SendSetupContent.kt$@OptIn(ExperimentalComposeUiApi::class) @Composable fun SendSetupContent( state: SendSetupViewState, callback: SendSetupScreenInterface )</ID>
    <ID>FunctionSignature:SendSetupFragment.kt$SendSetupFragment.Companion$fun getBundle(payload: AssetPayload?, initSendToAddress: String?, currencyId: String?)</ID>
    <ID>FunctionSignature:SetControllerValidationsModule.kt$SetControllerValidationsModule$@Provides @Singleton fun provideControllerValidation( stakingScenarioInteractor: StakingScenarioInteractor )</ID>
    <ID>FunctionSignature:SetupStakingInteractor.kt$SetupStakingInteractor$suspend fun estimateFinalParachainFee(selectedCollator: Collator, amountInPlanks: BigInteger, delegationCount: Int): BigInteger</ID>
    <ID>FunctionSignature:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit$abstract fun changeBlockProducers(newBlockProducers: List&lt;T&gt;, selectionMethod: SelectionMethod): ReadyToSubmit&lt;T&gt;</ID>
    <ID>FunctionSignature:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Parachain$override fun changeBlockProducers(newBlockProducers: List&lt;Collator&gt;, selectionMethod: SelectionMethod): ReadyToSubmit&lt;Collator&gt;</ID>
    <ID>FunctionSignature:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Payload.ExistingStash$override fun changeBlockProducers(newBlockProducers: List&lt;Validator&gt;, selectionMethod: SelectionMethod): Payload&lt;Validator&gt;</ID>
    <ID>FunctionSignature:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Payload.Full$override fun changeBlockProducers(newBlockProducers: List&lt;T&gt;, selectionMethod: SelectionMethod): Payload&lt;T&gt;</ID>
    <ID>FunctionSignature:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Payload.Parachain$override fun changeBlockProducers(newBlockProducers: List&lt;Collator&gt;, selectionMethod: SelectionMethod): Payload&lt;Collator&gt;</ID>
    <ID>FunctionSignature:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Payload.RelayChain$override fun changeBlockProducers(newBlockProducers: List&lt;Validator&gt;, selectionMethod: SelectionMethod): Payload&lt;Validator&gt;</ID>
    <ID>FunctionSignature:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Stash$override fun changeBlockProducers(newBlockProducers: List&lt;Validator&gt;, selectionMethod: SelectionMethod): ReadyToSubmit&lt;Validator&gt;</ID>
    <ID>FunctionSignature:SetupStakingSharedState.kt$SetupStakingProcess.SetupStep$abstract fun next( payload: Payload ): SetupStakingProcess</ID>
    <ID>FunctionSignature:ShouldShowEducationalStoriesUseCase.kt$ShouldShowEducationalStoriesUseCase$operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: Boolean)</ID>
    <ID>FunctionSignature:SignBeaconTransactionViewModel.kt$SignBeaconTransactionViewModel$private fun mapOperationToOperationModel(operationResult: Result&lt;SignableOperation&gt;, asset: Asset?): SignableOperationModel</ID>
    <ID>FunctionSignature:SingleStorageKeyUpdater.kt$suspend fun StorageCache.insert( storageChange: StorageChange, chainId: String )</ID>
    <ID>FunctionSignature:SocketSingleRequestExecutor.kt$SocketSingleRequestExecutor$private suspend fun executeRequestInternal( request: RpcRequest, url: String ): RpcResponse</ID>
    <ID>FunctionSignature:SocketSingleRequestExecutor.kt$SocketSingleRequestExecutor$suspend fun executeRequest( request: RpcRequest, url: String ): RpcResponse</ID>
    <ID>FunctionSignature:SoraCard.kt$@Composable fun SoraCard( onClick: (() -&gt; Unit) )</ID>
    <ID>FunctionSignature:SoraCardFeatureBindModule.kt$SoraCardFeatureModule$@Provides fun provideBuyCryptoDataSource( clientProvider: SoramitsuHttpClientProvider ): BuyCryptoDataSource</ID>
    <ID>FunctionSignature:SoraCardFeatureBindModule.kt$SoraCardFeatureModule$@Provides fun provideBuyCryptoRepository( dataSource: BuyCryptoDataSource ): BuyCryptoRepository</ID>
    <ID>FunctionSignature:SoraCardFeatureBindModule.kt$SoraCardFeatureModule$@Provides fun provideSoraCardRepositoryImpl( soraCardDao: SoraCardDao, soraCardApi: SoraCardApi ): SoraCardRepositoryImpl</ID>
    <ID>FunctionSignature:SoraCardFeatureBindModule.kt$SoraCardFeatureModule$@Provides fun provideSoramitsuHttpClientProvider(): SoramitsuHttpClientProvider</ID>
    <ID>FunctionSignature:SoraCardInfoMapper.kt$SoraCardInfoMapper$fun map(infoLocal: SoraCardInfoLocal): SoraCardInfo</ID>
    <ID>FunctionSignature:SoraCardInteractorImpl.kt$SoraCardInteractorImpl$override fun subscribeSoraCardInfo(): Flow&lt;SoraCardInfo?&gt;</ID>
    <ID>FunctionSignature:SoraCardInteractorImpl.kt$SoraCardInteractorImpl$override suspend fun updateSoraCardInfo(accessToken: String, refreshToken: String, accessTokenExpirationTime: Long, kycStatus: String)</ID>
    <ID>FunctionSignature:SoraCardRouter.kt$SoraCardRouter$fun openSwapTokensScreen(chainId: String, assetIdFrom: String?, assetIdTo: String?)</ID>
    <ID>FunctionSignature:SoraRewardCalculator.kt$SoraRewardCalculator$override suspend fun calculateReturns(amount: BigDecimal, days: Int, isCompound: Boolean, chainId: ChainId)</ID>
    <ID>FunctionSignature:SoraRewardCalculator.kt$SoraRewardCalculator$override suspend fun calculateReturns(amount: Double, days: Int, isCompound: Boolean, targetIdHex: String)</ID>
    <ID>FunctionSignature:SourceTypeChooserBottomSheetDialog.kt$SourceTypeHolder$override fun bind(item: T, isSelected: Boolean, handler: DynamicListSheetAdapter.Handler&lt;T&gt;)</ID>
    <ID>FunctionSignature:SplashViewModel.kt$SplashViewModel$private fun StoryGroup.Onboarding.transform()</ID>
    <ID>FunctionSignature:StakeInfoViewState.kt$fun StakeInfoViewState.PoolStakeInfoViewState.Companion.default(resourceManager: ResourceManager): StakeInfoViewState.PoolStakeInfoViewState</ID>
    <ID>FunctionSignature:StakingAssetInfoViewState.kt$fun StakingAssetInfoViewState.Parachain.Companion.default(resourceManager: ResourceManager)</ID>
    <ID>FunctionSignature:StakingAssetInfoViewState.kt$fun StakingAssetInfoViewState.Parachain.update(state: StakingNetworkInfoModel.Parachain): StakingAssetInfoViewState.Parachain</ID>
    <ID>FunctionSignature:StakingAssetInfoViewState.kt$fun StakingAssetInfoViewState.RelayChain.Companion.default(resourceManager: ResourceManager)</ID>
    <ID>FunctionSignature:StakingAssetInfoViewState.kt$fun StakingAssetInfoViewState.RelayChain.update(state: StakingNetworkInfoModel.RelayChain): StakingAssetInfoViewState.RelayChain</ID>
    <ID>FunctionSignature:StakingAssetInfoViewState.kt$fun StakingAssetInfoViewState.StakingPool.Companion.default(resourceManager: ResourceManager)</ID>
    <ID>FunctionSignature:StakingAssetInfoViewState.kt$fun StakingAssetInfoViewState.StakingPool.update(state: StakingNetworkInfoModel.Pool): StakingAssetInfoViewState.StakingPool</ID>
    <ID>FunctionSignature:StakingBalanceValidationsModule.kt$StakingBalanceValidationsModule$@Provides @Singleton fun provideControllerValidation( stakingScenarioInteractor: StakingScenarioInteractor )</ID>
    <ID>FunctionSignature:StakingBalanceValidationsModule.kt$StakingBalanceValidationsModule$@Provides @Singleton fun provideStashValidation( stakingScenarioInteractor: StakingScenarioInteractor )</ID>
    <ID>FunctionSignature:StakingBalanceValidationsModule.kt$StakingBalanceValidationsModule$@Provides @Singleton fun provideUnbondingLimitValidation( stakingScenarioInteractor: StakingScenarioInteractor )</ID>
    <ID>FunctionSignature:StakingConstantsRepository.kt$StakingConstantsRepository$suspend fun maxRewardedNominatorPerValidator(chainId: ChainId): Int</ID>
    <ID>FunctionSignature:StakingConstantsRepository.kt$StakingConstantsRepository$suspend fun parachainLeaveCandidatesDelay(chainId: ChainId): BigInteger</ID>
    <ID>FunctionSignature:StakingConstantsRepository.kt$StakingConstantsRepository$suspend fun parachainLockupPeriodInRounds(chainId: ChainId): BigInteger</ID>
    <ID>FunctionSignature:StakingConstantsRepository.kt$StakingConstantsRepository$suspend fun parachainMinimumStaking(chainId: ChainId): BigInteger</ID>
    <ID>FunctionSignature:StakingFeatureModule.kt$StakingFeatureModule$@Provides @Singleton @Named("StakingTokenUseCase") fun provideTokenUseCase( sharedState: StakingSharedState ): TokenUseCase</ID>
    <ID>FunctionSignature:StakingFeatureModule.kt$StakingFeatureModule$@Provides @Singleton fun provideBondMoreInteractor( sharedState: StakingSharedState, extrinsicService: ExtrinsicService )</ID>
    <ID>FunctionSignature:StakingFeatureModule.kt$StakingFeatureModule$@Provides @Singleton fun provideChangeRewardDestinationInteractor( extrinsicService: ExtrinsicService )</ID>
    <ID>FunctionSignature:StakingFeatureModule.kt$StakingFeatureModule$@Provides @Singleton fun provideEraTimeCalculatorFactory( stakingRelayChainScenarioRepository: StakingRelayChainScenarioRepository )</ID>
    <ID>FunctionSignature:StakingFeatureModule.kt$StakingFeatureModule$@Provides @Singleton fun provideIdentityRepository( bulkRetriever: BulkRetriever, chainRegistry: ChainRegistry ): IdentityRepository</ID>
    <ID>FunctionSignature:StakingFeatureModule.kt$StakingFeatureModule$@Provides @Singleton fun providePayoutInteractor( sharedState: StakingSharedState, extrinsicService: ExtrinsicService )</ID>
    <ID>FunctionSignature:StakingFeatureModule.kt$StakingFeatureModule$@Provides @Singleton fun provideRebondInteractor( sharedState: StakingSharedState, extrinsicService: ExtrinsicService )</ID>
    <ID>FunctionSignature:StakingFeatureModule.kt$StakingFeatureModule$@Provides @Singleton fun provideRedeemInteractor( extrinsicService: ExtrinsicService )</ID>
    <ID>FunctionSignature:StakingFeatureModule.kt$StakingFeatureModule$@Provides @Singleton fun provideRewardCalculatorFactory( stakingRelayChainScenarioRepository: StakingRelayChainScenarioRepository, repository: StakingRepository, stakingScenarioInteractor: StakingParachainScenarioInteractor, stakingApi: StakingApi, soraStakingRewardsScenario: SoraStakingRewardsScenario )</ID>
    <ID>FunctionSignature:StakingFeatureModule.kt$StakingFeatureModule$@Provides @Singleton fun provideSearchCustomBlockProducerInteractor( collatorProvider: CollatorProvider, validatorProvider: ValidatorProvider, sharedState: StakingSharedState, computationalCache: ComputationalCache, addressIconGenerator: AddressIconGenerator )</ID>
    <ID>FunctionSignature:StakingFeatureModule.kt$StakingFeatureModule$@Provides @Singleton fun provideSetupStakingInteractor( extrinsicService: ExtrinsicService, sharedState: StakingSharedState )</ID>
    <ID>FunctionSignature:StakingFeatureModule.kt$StakingFeatureModule$@Provides @Singleton fun provideStakingConstantsRepository( chainRegistry: ChainRegistry )</ID>
    <ID>FunctionSignature:StakingFeatureModule.kt$StakingFeatureModule$@Provides @Singleton fun provideStakingRewardsRepository( rewardDataSource: StakingRewardsDataSource ): StakingRewardsRepository</ID>
    <ID>FunctionSignature:StakingFeatureModule.kt$StakingFeatureModule$@Provides @Singleton fun provideUnbondInteractor( extrinsicService: ExtrinsicService )</ID>
    <ID>FunctionSignature:StakingFeatureModule.kt$StakingFeatureModule$@Provides fun soraTokensRateUseCase(rpcCalls: RpcCalls, chainRegistry: ChainRegistry, tokenPriceDao: TokenPriceDao)</ID>
    <ID>FunctionSignature:StakingInteractor.kt$StakingInteractor$suspend fun getAddressModel(accountAddress: String, sizeInDp: Int, accountName: String? = null): AddressModel</ID>
    <ID>FunctionSignature:StakingInteractorExt.kt$fun Exposure.willAccountBeRewarded( accountId: AccountId, rewardedNominatorsPerValidator: Int ): Boolean</ID>
    <ID>FunctionSignature:StakingInteractorExt.kt$fun minimumStake( exposures: Collection&lt;Exposure&gt;, minimumNominatorBond: BigInteger ): BigInteger</ID>
    <ID>FunctionSignature:StakingInteractorExtKtTest.kt$StakingInteractorExtKtTest$private fun runIsActiveTest(expected: Boolean, who: ByteArray, maxRewarded: Int)</ID>
    <ID>FunctionSignature:StakingInteractorExtKtTest.kt$StakingInteractorExtKtTest$private fun runWillBeRewardedTest(expected: Boolean, who: ByteArray, maxRewarded: Int)</ID>
    <ID>FunctionSignature:StakingLedger.kt$fun StakingLedger.sumStaking( condition: (chunk: UnlockChunk) -&gt; Boolean ): BigInteger</ID>
    <ID>FunctionSignature:StakingLedgerUpdater.kt$StakingLedgerUpdater$private suspend fun updateAssetStakingForEmptyLedger( accountId: AccountId, chainAsset: Asset )</ID>
    <ID>FunctionSignature:StakingMinMaxStorages.kt$fun bindDelegationScheduledRequests( scale: String, runtime: RuntimeSnapshot ): List&lt;DelegationScheduledRequest&gt;</ID>
    <ID>FunctionSignature:StakingMinMaxStorages.kt$fun bindMaxNominators(scale: String, runtimeSnapshot: RuntimeSnapshot, type: Type&lt;*&gt;): BigInteger?</ID>
    <ID>FunctionSignature:StakingMinMaxStorages.kt$fun bindMinBond(scale: String, runtimeSnapshot: RuntimeSnapshot, type: Type&lt;*&gt;): BigInteger</ID>
    <ID>FunctionSignature:StakingMinMaxStorages.kt$fun bindNominatorsCount(scale: String, runtimeSnapshot: RuntimeSnapshot, type: Type&lt;*&gt;): BigInteger</ID>
    <ID>FunctionSignature:StakingMinMaxStorages.kt$fun bindRound( scale: String, runtime: RuntimeSnapshot ): Round</ID>
    <ID>FunctionSignature:StakingMinMaxStorages.kt$fun bindRoundNumber( scale: String, runtime: RuntimeSnapshot ): BigInteger</ID>
    <ID>FunctionSignature:StakingMinMaxStorages.kt$fun bindSelectedCandidates( scale: String, runtime: RuntimeSnapshot ): List&lt;ByteArray&gt;</ID>
    <ID>FunctionSignature:StakingMinMaxStorages.kt$private fun bindNumber(scale: String, runtimeSnapshot: RuntimeSnapshot, type: Type&lt;*&gt;): BigInteger</ID>
    <ID>FunctionSignature:StakingMinMaxStorages.kt$private fun bindNumberOrNull(scale: String, runtimeSnapshot: RuntimeSnapshot, type: Type&lt;*&gt;): BigInteger?</ID>
    <ID>FunctionSignature:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$override fun rebond(extrinsicBuilder: ExtrinsicBuilder, amount: BigInteger, candidate: String?): ExtrinsicBuilder</ID>
    <ID>FunctionSignature:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$override suspend fun stakeMore(extrinsicBuilder: ExtrinsicBuilder, amountInPlanks: BigInteger, candidate: String?): ExtrinsicBuilder</ID>
    <ID>FunctionSignature:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$private fun calculateTimeTillTheRoundStart(currentRound: Round, currentBlock: BlockNumber, roundNumber: BigInteger, hoursInRound: Int): Long</ID>
    <ID>FunctionSignature:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$suspend fun getCollatorIdsWithReadyToUnlockingTokens(collatorIds: List&lt;AccountId&gt;, accountId: AccountId): List&lt;AccountId&gt;</ID>
    <ID>FunctionSignature:StakingParachainScenarioRepository.kt$StakingParachainScenarioRepository$fun stakingStateFlow( chain: Chain, accountId: AccountId ): Flow&lt;StakingState&gt;</ID>
    <ID>FunctionSignature:StakingParachainScenarioRepository.kt$StakingParachainScenarioRepository$suspend fun getAtStakeOfCollator(chainId: ChainId, collatorId: AccountId, currentRound: BigInteger): AtStake</ID>
    <ID>FunctionSignature:StakingParachainScenarioViewModel.kt$StakingParachainScenarioViewModel$private suspend fun produceCollatorLeavingAlerts(state: StakingState.Parachain.Delegator): List&lt;Alert.CollatorLeaving&gt;</ID>
    <ID>FunctionSignature:StakingParachainScenarioViewModel.kt$StakingParachainScenarioViewModel$private suspend fun produceReadyForUnlockingAlerts(state: StakingState.Parachain.Delegator): List&lt;Alert.ReadyForUnlocking&gt;</ID>
    <ID>FunctionSignature:StakingPoolApi.kt$StakingPoolApi$suspend fun estimateJoinFee( amountInPlanks: BigInteger, poolId: BigInteger ): BigInteger</ID>
    <ID>FunctionSignature:StakingPoolApi.kt$StakingPoolApi$suspend fun estimateNominatePoolFee( poolId: BigInteger, vararg validators: AccountId ): BigInteger</ID>
    <ID>FunctionSignature:StakingPoolInteractor.kt$StakingPoolInteractor$@Deprecated("Manual calculating is deprecated", replaceWith = ReplaceWith("dataSource.getPendingRewards")) private suspend fun calculatePendingRewards(chain: Chain, poolMember: PoolMember, bondedPool: BondedPool, rewardPool: PoolRewards?): BigInteger</ID>
    <ID>FunctionSignature:StakingPoolInteractor.kt$StakingPoolInteractor$@OptIn(ExperimentalCoroutinesApi::class) fun observeCurrentPool( chain: Chain, accountId: AccountId ): Flow&lt;OwnPool?&gt;</ID>
    <ID>FunctionSignature:StakingPoolInteractor.kt$StakingPoolInteractor$private fun PoolInfo.toOwnPool(poolMember: PoolMember, redeemable: BigInteger, unbonding: BigInteger, pendingRewards: BigInteger): OwnPool</ID>
    <ID>FunctionSignature:StakingPoolInteractor.kt$StakingPoolInteractor$private suspend fun generatePoolAccountId(index: Int, chain: Chain, poolId: BigInteger): ByteArray</ID>
    <ID>FunctionSignature:StakingPoolInteractor.kt$StakingPoolInteractor$suspend fun estimateJoinFee(amount: BigInteger, poolId: BigInteger = BigInteger.ZERO)</ID>
    <ID>FunctionSignature:StakingPoolInteractor.kt$StakingPoolInteractor$suspend fun estimateNominateFee( poolId: BigInteger, vararg validators: AccountId )</ID>
    <ID>FunctionSignature:StakingPoolInteractor.kt$StakingPoolInteractor$suspend fun joinPool(address: String, amount: BigInteger, poolId: BigInteger)</ID>
    <ID>FunctionSignature:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$fun observeNominatorSummary( nominatorState: StakingState.Stash.Nominator ): Flow&lt;StakeSummary&lt;NominatorStatus&gt;&gt;</ID>
    <ID>FunctionSignature:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$fun observeStashSummary( stashState: StakingState.Stash.None ): Flow&lt;StakeSummary&lt;StashNoneStatus&gt;&gt;</ID>
    <ID>FunctionSignature:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$fun observeValidatorSummary( validatorState: StakingState.Stash.Validator ): Flow&lt;StakeSummary&lt;ValidatorStatus&gt;&gt;</ID>
    <ID>FunctionSignature:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$override fun rebond(extrinsicBuilder: ExtrinsicBuilder, amount: BigInteger, candidate: String?)</ID>
    <ID>FunctionSignature:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$override fun selectedAccountStakingStateFlow()</ID>
    <ID>FunctionSignature:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$override suspend fun checkEnoughToRebondValidation(payload: RebondValidationPayload)</ID>
    <ID>FunctionSignature:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$override suspend fun checkEnoughToUnbondValidation(payload: UnbondValidationPayload)</ID>
    <ID>FunctionSignature:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$override suspend fun getRebondingUnbondings(collatorAddress: String?): List&lt;Unbonding&gt;</ID>
    <ID>FunctionSignature:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$override suspend fun getRewardDestination(accountStakingState: StakingState): RewardDestination</ID>
    <ID>FunctionSignature:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$override suspend fun stakeMore(extrinsicBuilder: ExtrinsicBuilder, amountInPlanks: BigInteger, candidate: String?)</ID>
    <ID>FunctionSignature:StakingRelayChainScenarioRepository.kt$StakingRelayChainScenarioRepository$private suspend fun getElectedValidatorsExposure(chainId: ChainId, eraIndex: EraIndex): Map&lt;String, Exposure&gt;</ID>
    <ID>FunctionSignature:StakingRelayChainScenarioRepository.kt$StakingRelayChainScenarioRepository$suspend fun getSlashes(chainId: ChainId, accountIdsHex: List&lt;String&gt;): AccountIdMap&lt;Boolean&gt;</ID>
    <ID>FunctionSignature:StakingRelayChainScenarioRepository.kt$StakingRelayChainScenarioRepository$suspend fun getValidatorPrefs( chainId: ChainId, accountIdsHex: List&lt;String&gt; ): AccountIdMap&lt;ValidatorPrefs?&gt;</ID>
    <ID>FunctionSignature:StakingRewardEstimationBottomSheet.kt$StakingRewardEstimationBottomSheet$private fun addItem( percentage: String, @StringRes titleRes: Int )</ID>
    <ID>FunctionSignature:StakingRouter.kt$StakingRouter$fun openAlert(payload: AlertViewState, resultKey: String, @IdRes resultDestinationId: Int)</ID>
    <ID>FunctionSignature:StakingRouter.kt$StakingRouter$fun openOperationSuccess(operationHash: String?, chainId: ChainId, customMessage: String? = null)</ID>
    <ID>FunctionSignature:StakingRouter.kt$StakingRouter$fun setAlertResult(key: String, result: Result&lt;*&gt;, @IdRes resultDestinationId: Int? = null)</ID>
    <ID>FunctionSignature:StakingScenarioInteractor.kt$StakingScenarioInteractor$fun rebond(extrinsicBuilder: ExtrinsicBuilder, amount: BigInteger, candidate: String?): ExtrinsicBuilder</ID>
    <ID>FunctionSignature:StakingScenarioInteractor.kt$StakingScenarioInteractor$suspend fun confirmRevoke(extrinsicBuilder: ExtrinsicBuilder, candidate: String?, stashState: StakingState)</ID>
    <ID>FunctionSignature:StakingScenarioInteractor.kt$StakingScenarioInteractor$suspend fun stakeMore(extrinsicBuilder: ExtrinsicBuilder, amountInPlanks: BigInteger, candidate: String? = null): ExtrinsicBuilder</ID>
    <ID>FunctionSignature:StakingSharedState.kt$StakingAssetSelection.Companion$fun from(chainId: ChainId, chainAssetId: String, type: String)</ID>
    <ID>FunctionSignature:StakingUpdatersModule.kt$StakingUpdatersModule$@Provides @Singleton @Named("StakingChainUpdateSystem") fun provideStakingUpdaterSystem( activeEraUpdater: ActiveEraUpdater, validatorExposureUpdater: ValidatorExposureUpdater, totalIssuanceUpdater: TotalIssuanceUpdater, currentEraUpdater: CurrentEraUpdater, stakingLedgerUpdater: StakingLedgerUpdater, accountValidatorPrefsUpdater: AccountValidatorPrefsUpdater, accountNominationsUpdater: AccountNominationsUpdater, rewardDestinationUpdater: AccountRewardDestinationUpdater, historyDepthUpdater: HistoryDepthUpdater, historicalUpdateMediator: HistoricalUpdateMediator, accountControllerBalanceUpdater: AccountControllerBalanceUpdater, minBondUpdater: MinBondUpdater, maxNominatorsUpdater: MaxNominatorsUpdater, counterForNominatorsUpdater: CounterForNominatorsUpdater, delegatorStateUpdater: DelegatorStateUpdater, @Named("StakingBlockNumberUpdater") blockNumberUpdater: BlockNumberUpdater, chainRegistry: ChainRegistry, stakingSharedState: StakingSharedState ): UpdateSystem</ID>
    <ID>FunctionSignature:StakingViewModel.kt$StakingViewModel$inline fun &lt;reified T : StakingAssetInfoViewState&gt; Map&lt;StakingType, StakingAssetInfoViewState&gt;.get(type: StakingType): T</ID>
    <ID>FunctionSignature:StakingViewStateOld.kt$DelegatorViewState$private fun calculateTimeTillTheEndOfRound(currentRound: Round, currentBlock: BigInteger, hoursInRound: Int): Long</ID>
    <ID>FunctionSignature:StakingViewStateOld.kt$SoraNominatorViewState$override suspend fun buildStakeSummaryModel(asset: Asset, summary: StakeSummary&lt;NominatorStatus&gt;): StakeSummaryModel&lt;NominatorStatus&gt;</ID>
    <ID>FunctionSignature:StartStakingPoolScreen.kt$@Composable private fun SingleValueInfoCard(@DrawableRes icon: Int, @StringRes text: Int, value: String)</ID>
    <ID>FunctionSignature:StateTransitions.kt$fun SetupStakingSharedState.setCustomCollators( collators: List&lt;Collator&gt; )</ID>
    <ID>FunctionSignature:StateTransitions.kt$fun SetupStakingSharedState.setCustomValidators( validators: List&lt;Validator&gt; )</ID>
    <ID>FunctionSignature:StateTransitions.kt$fun SetupStakingSharedState.setRecommendedCollators( collators: List&lt;Collator&gt; )</ID>
    <ID>FunctionSignature:StateTransitions.kt$fun SetupStakingSharedState.setRecommendedValidators( validators: List&lt;Validator&gt; )</ID>
    <ID>FunctionSignature:StateTransitions.kt$private fun SetupStakingSharedState.setCollators( collators: List&lt;Collator&gt;, selectionMethod: SelectionMethod )</ID>
    <ID>FunctionSignature:StateTransitions.kt$private fun SetupStakingSharedState.setValidators( validators: List&lt;Validator&gt;, selectionMethod: SelectionMethod )</ID>
    <ID>FunctionSignature:SubQueryDelegationHistoryFetcher.kt$SubQueryDelegationHistoryFetcher$suspend fun fetchDelegationHistory(chainId: ChainId, delegatorAddress: String, collatorAddress: String): List&lt;Unbonding&gt;</ID>
    <ID>FunctionSignature:SubqueryRewardCalculator.kt$SubqueryRewardCalculator$override suspend fun calculateReturns(amount: BigDecimal, days: Int, isCompound: Boolean, chainId: ChainId): PeriodReturns</ID>
    <ID>FunctionSignature:SubqueryRewardCalculator.kt$SubqueryRewardCalculator$override suspend fun calculateReturns(amount: Double, days: Int, isCompound: Boolean, targetIdHex: String): PeriodReturns</ID>
    <ID>FunctionSignature:SubqueryRewardCalculator.kt$SubqueryRewardCalculator$private suspend fun getSubsquidRewards(stakingUrl: String, selectedCandidates: List&lt;ByteArray&gt;? = null): Map&lt;String, BigDecimal?&gt;</ID>
    <ID>FunctionSignature:SuccessContent.kt$@Composable fun SuccessContent( state: SuccessViewState, callback: SuccessScreenInterface )</ID>
    <ID>FunctionSignature:SwapPreviewFragment.kt$SwapPreviewFragment.Companion$fun getBundle(swapDetailsViewState: SwapDetailsViewState, detailsParcelModel: SwapDetailsParcelModel)</ID>
    <ID>FunctionSignature:SwapTokensFragment.kt$SwapTokensFragment.Companion$fun getBundle(selectedChainId: String, assetIdFrom: String?, assetIdTo: String?)</ID>
    <ID>FunctionSignature:SwipeableAssetListItem.kt$fun onItemClick(actionType: ActionItemType, chainId: ChainId, chainAssetId: String)</ID>
    <ID>FunctionSignature:TernoaRewardCalculator.kt$TernoaRewardCalculator$override suspend fun calculateReturns(amount: BigDecimal, days: Int, isCompound: Boolean, chainId: ChainId)</ID>
    <ID>FunctionSignature:TernoaRewardCalculator.kt$TernoaRewardCalculator$override suspend fun calculateReturns(amount: Double, days: Int, isCompound: Boolean, targetIdHex: String)</ID>
    <ID>FunctionSignature:TernoaRewardCalculator.kt$TernoaRewardCalculator$private fun calculateSimpleReward(amount: Double, days: Int, dailyPercentage: Double): BigDecimal</ID>
    <ID>FunctionSignature:Theme.kt$@Composable fun FearlessAppTheme( darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable () -&gt; Unit )</ID>
    <ID>FunctionSignature:Theme.kt$@Deprecated("use FearlessAppTheme instead") @Composable fun FearlessTheme( darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable () -&gt; Unit )</ID>
    <ID>FunctionSignature:TitleValue.kt$@Composable fun ChangeToValue(state: TitleValueViewState?, modifier: Modifier = Modifier, testTag: String)</ID>
    <ID>FunctionSignature:TitleValue.kt$@Composable fun TitleToValue(state: TitleValueViewState, modifier: Modifier = Modifier, testTag: String)</ID>
    <ID>FunctionSignature:TitleValue.kt$@Composable private fun TitleToValue(modifier: Modifier = Modifier, state: TitleValueViewState, titleColor: Color, testTag: String)</ID>
    <ID>FunctionSignature:Toolbar.kt$@Composable fun Toolbar(state: ToolbarViewState, modifier: Modifier = Modifier, onNavigationClick: () -&gt; Unit)</ID>
    <ID>FunctionSignature:TransactionDetailViewModel.kt$TransactionDetailViewModel$private suspend fun getIcon(address: String)</ID>
    <ID>FunctionSignature:TransactionHistoryMixin.kt$TransactionHistoryUi$fun transactionClicked( transactionModel: OperationModel, assetPayload: AssetPayload )</ID>
    <ID>FunctionSignature:TransactionItem.kt$@Composable fun TransactionItem( item: OperationModel, transactionClicked: (OperationModel) -&gt; Unit )</ID>
    <ID>FunctionSignature:TransactionSettingsContent.kt$@Composable private fun WarningText( slippageWarningText: String?, modifier: Modifier = Modifier )</ID>
    <ID>FunctionSignature:TransferCursorStorage.kt$TransferCursorStorage$private fun cursorKey(chainId: String, chainAssetId: String, accountId: AccountId)</ID>
    <ID>FunctionSignature:UnbondInteractor.kt$UnbondInteractor$suspend fun estimateFee( stashState: StakingState, formExtrinsic: suspend ExtrinsicBuilder.() -&gt; Unit ): BigInteger</ID>
    <ID>FunctionSignature:UnbondInteractor.kt$UnbondInteractor$suspend fun unbond( stashState: StakingState, formExtrinsic: suspend ExtrinsicBuilder.() -&gt; Unit ): Result&lt;String&gt;</ID>
    <ID>FunctionSignature:UnbondValidationsModule.kt$UnbondValidationsModule$@Provides @Singleton fun provideCrossExistentialValidation( stakingScenarioInteractor: StakingScenarioInteractor )</ID>
    <ID>FunctionSignature:UnbondValidationsModule.kt$UnbondValidationsModule$@Provides @Singleton fun provideEnoughToUnbondValidation( stakingScenarioInteractor: StakingScenarioInteractor )</ID>
    <ID>FunctionSignature:UnbondValidationsModule.kt$UnbondValidationsModule$@Provides @Singleton fun provideUnbondLimitValidation( stakingScenarioInteractor: StakingScenarioInteractor )</ID>
    <ID>FunctionSignature:Updater.kt$Updater$suspend fun listenForUpdates( storageSubscriptionBuilder: SubscriptionBuilder ): Flow&lt;SideEffect&gt;</ID>
    <ID>FunctionSignature:UpdatesMixin.kt$UpdatesProviderUi$suspend fun finishUpdateAsset(metaId: Long, chainId: String, accountId: AccountId, assetId: String)</ID>
    <ID>FunctionSignature:UpdatesMixin.kt$UpdatesProviderUi$suspend fun startUpdateAsset(metaId: Long, chainId: String, accountId: AccountId, assetId: String)</ID>
    <ID>FunctionSignature:UpdatesProvider.kt$UpdatesProvider$override suspend fun finishUpdateAsset(metaId: Long, chainId: String, accountId: AccountId, assetId: String)</ID>
    <ID>FunctionSignature:UpdatesProvider.kt$UpdatesProvider$override suspend fun startUpdateAsset(metaId: Long, chainId: String, accountId: AccountId, assetId: String)</ID>
    <ID>FunctionSignature:V2MigrationTest.kt$V2MigrationTest$private fun assertCorrectKeypair( expected: Keypair?, actual: EncodableStruct&lt;KeyPairSchema&gt;? )</ID>
    <ID>FunctionSignature:ValidateTransferUseCase.kt$fun ValidationException.Companion.fromValidationResult(result: TransferValidationResult, resourceManager: ResourceManager): ValidationException?</ID>
    <ID>FunctionSignature:Validation.kt$ValidationSystem$suspend fun validate( value: T, ignoreUntil: ValidationStatus.NotValid.Level? = null ): Result&lt;ValidationStatus&lt;S&gt;&gt;</ID>
    <ID>FunctionSignature:Validation.kt$fun &lt;S&gt; validOrError( condition: Boolean, lazyReason: () -&gt; S ): ValidationStatus&lt;S&gt;</ID>
    <ID>FunctionSignature:Validation.kt$fun &lt;S&gt; validOrWarning( condition: Boolean, lazyReason: () -&gt; S ): ValidationStatus&lt;S&gt;</ID>
    <ID>FunctionSignature:Validation.kt$suspend fun &lt;S&gt; ValidationSystem&lt;Unit, S&gt;.validate( ignoreUntil: ValidationStatus.NotValid.Level? = null )</ID>
    <ID>FunctionSignature:ValidationFailure.kt$fun unbondValidationFailure( reason: UnbondValidationFailure, resourceManager: ResourceManager ): TitleAndMessage</ID>
    <ID>FunctionSignature:Validator.kt$fun mapValidatorDetailsToErrors( validator: ValidatorDetailsParcelModel ): List&lt;Error&gt;?</ID>
    <ID>FunctionSignature:Validator.kt$fun mapValidatorToValidatorDetailsParcelModel( validator: Validator ): ValidatorDetailsParcelModel</ID>
    <ID>FunctionSignature:Validator.kt$fun mapValidatorToValidatorDetailsWithStakeFlagParcelModel( nominatedValidator: NominatedValidator ): ValidatorDetailsParcelModel</ID>
    <ID>FunctionSignature:ValidatorDetailsViewModel.kt$ValidatorDetailsViewModel$private suspend fun calculatePayload(asset: Asset, validatorStake: ValidatorStakeParcelModel)</ID>
    <ID>FunctionSignature:ValidatorPrefs.kt$@UseCaseBinding fun bindValidatorPrefs(scale: String, runtime: RuntimeSnapshot, type: Type&lt;*&gt;): ValidatorPrefs</ID>
    <ID>FunctionSignature:ValidatorRecommendator.kt$ValidatorRecommendator$override suspend fun recommendations(settings: RecommendationSettings&lt;Validator&gt;)</ID>
    <ID>FunctionSignature:ValidatorRecommendatorFactory.kt$ValidatorRecommendatorFactory$private suspend fun loadValidators(lifecycle: Lifecycle)</ID>
    <ID>FunctionSignature:ValidatorsAdapter.kt$ValidatorsAdapter$override fun onBindViewHolder(holder: ValidatorViewHolder, position: Int, payloads: MutableList&lt;Any&gt;)</ID>
    <ID>FunctionSignature:ValidatorsSettingsScreen.kt$@Composable fun ValidatorsSettingsScreen( state: ValidatorsSettingsViewState, callback: ValidatorsSettingsScreenInterface )</ID>
    <ID>FunctionSignature:ValidatorsSettingsViewModel.kt$ValidatorsSettingsViewModel$private fun SettingsSchema.Filter.toViewState()</ID>
    <ID>FunctionSignature:ValidatorsSettingsViewModel.kt$ValidatorsSettingsViewModel$private fun SettingsSchema.Sorting.toViewState()</ID>
    <ID>FunctionSignature:ViewExt.kt$&lt;no name provided&gt;$override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int)</ID>
    <ID>FunctionSignature:ViewExt.kt$&lt;no name provided&gt;$override fun onItemRangeMoved(fromPosition: Int, toPosition: Int, itemCount: Int)</ID>
    <ID>FunctionSignature:ViewExt.kt$&lt;no name provided&gt;$override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int)</ID>
    <ID>FunctionSignature:ViewExt.kt$inline fun &lt;reified T : Enum&lt;T&gt;&gt; TypedArray.getEnum(index: Int, default: T)</ID>
    <ID>FunctionSignature:WalletFeatureModule.kt$WalletFeatureModule$@Provides @Singleton fun provideAddressBookRepository( addressBookDao: AddressBookDao ): AddressBookRepository</ID>
    <ID>FunctionSignature:WalletFeatureModule.kt$WalletFeatureModule$@Provides @Singleton fun provideBeaconSharedState( chainRegistry: ChainRegistry, preferences: Preferences ): BeaconSharedState</ID>
    <ID>FunctionSignature:WalletFeatureModule.kt$WalletFeatureModule$@Provides fun provideBuyMixin( buyTokenRegistry: BuyTokenRegistry, chainRegistry: ChainRegistry ): BuyMixin.Presentation</ID>
    <ID>FunctionSignature:WalletFeatureModule.kt$WalletFeatureModule$@Provides fun provideChainInteractor( chainDao: ChainDao, xcmEntitiesFetcher: XcmEntitiesFetcher ): ChainInteractor</ID>
    <ID>FunctionSignature:WalletFeatureModule.kt$WalletFeatureModule$@Provides fun provideTokenRepository( tokenPriceDao: TokenPriceDao ): TokenRepository</ID>
    <ID>FunctionSignature:WalletFeatureModule.kt$WalletFeatureModule$@Provides fun provideTokenUseCase( tokenRepository: TokenRepository, sharedState: BeaconSharedState ): TokenUseCase</ID>
    <ID>FunctionSignature:WalletFeatureModule.kt$WalletFeatureModule$@Provides fun provideWalletConstants( chainRegistry: ChainRegistry ): WalletConstants</ID>
    <ID>FunctionSignature:WalletFeatureModule.kt$WalletFeatureModule$@Singleton @Provides fun provideSoramitsuNetworkClient(): SoramitsuNetworkClient</ID>
    <ID>FunctionSignature:WalletInteractor.kt$WalletInteractor$suspend fun saveAddress(name: String, address: String, selectedChainId: String)</ID>
    <ID>FunctionSignature:WalletInteractorImpl.kt$WalletInteractorImpl$override fun isShowGetSoraCard(): Boolean</ID>
    <ID>FunctionSignature:WalletInteractorImpl.kt$WalletInteractorImpl$override suspend fun getChainAddressForSelectedMetaAccount(chainId: ChainId)</ID>
    <ID>FunctionSignature:WalletInteractorImpl.kt$WalletInteractorImpl$override suspend fun saveAddress(name: String, address: String, selectedChainId: String)</ID>
    <ID>FunctionSignature:WalletInteractorImpl.kt$WalletInteractorImpl$override suspend fun validateSendAddress(chainId: ChainId, address: String): Boolean</ID>
    <ID>FunctionSignature:WalletInteractorImpl.kt$WalletInteractorImpl$private fun defaultAssetListSort()</ID>
    <ID>FunctionSignature:WalletInteractorImpl.kt$WalletInteractorImpl$private suspend fun manageAssetHidden(chainId: ChainId, chainAssetId: String, isHidden: Boolean)</ID>
    <ID>FunctionSignature:WalletRepository.kt$WalletRepository$fun assetFlow(metaId: Long, accountId: AccountId, chainAsset: CoreAsset, minSupportedVersion: String?): Flow&lt;Asset&gt;</ID>
    <ID>FunctionSignature:WalletRepository.kt$WalletRepository$suspend fun getAsset(metaId: Long, accountId: AccountId, chainAsset: CoreAsset, minSupportedVersion: String?): Asset?</ID>
    <ID>FunctionSignature:WalletRepositoryImpl.kt$WalletRepositoryImpl$override fun assetFlow(metaId: Long, accountId: AccountId, chainAsset: CoreAsset, minSupportedVersion: String?): Flow&lt;Asset&gt;</ID>
    <ID>FunctionSignature:WalletRepositoryImpl.kt$WalletRepositoryImpl$override suspend fun getAsset(metaId: Long, accountId: AccountId, chainAsset: CoreAsset, minSupportedVersion: String?): Asset?</ID>
    <ID>FunctionSignature:WalletRepositoryImpl.kt$WalletRepositoryImpl$private fun createOperation( hash: String, transfer: Transfer, senderAddress: String, fee: BigDecimal, source: OperationLocal.Source )</ID>
    <ID>FunctionSignature:WalletRepositoryImpl.kt$WalletRepositoryImpl$private fun mapAssetLocalToAsset( chainsById: Map&lt;ChainId, Chain&gt;, assetLocal: AssetWithToken ): Asset?</ID>
    <ID>FunctionSignature:WalletRepositoryImpl.kt$WalletRepositoryImpl$private suspend fun getAssetPriceCoingecko(vararg priceId: String, currencyId: String): Map&lt;String, Map&lt;String, BigDecimal&gt;&gt;</ID>
    <ID>FunctionSignature:WalletRouter.kt$WalletRouter$fun openOnboardingNavGraph(chainId: ChainId, metaId: Long, isImport: Boolean)</ID>
    <ID>FunctionSignature:WalletRouter.kt$WalletRouter$fun openSelectAsset(chainId: ChainId, selectedAssetId: String?, isFilterXcmAssets: Boolean)</ID>
    <ID>FunctionSignature:WalletRouter.kt$WalletRouter$fun openSend(assetPayload: AssetPayload?, initialSendToAddress: String? = null, currencyId: String? = null)</ID>
    <ID>FunctionSignature:WalletRouter.kt$WalletRouter$fun openSwapTokensScreen(chainId: String, assetIdFrom: String?, assetIdTo: String?)</ID>
    <ID>FunctionSignature:WalletRouter.kt$WalletRouter$fun openWalletSelectorForResult( selectedWalletId: Long?, walletSelectionMode: WalletSelectionMode ): Flow&lt;Long&gt;</ID>
    <ID>FunctionSignature:WalletScreen.kt$&lt;no name provided&gt;$override fun actionItemClicked(actionType: ActionItemType, chainId: ChainId, chainAssetId: String, swipeableState: SwipeableState&lt;SwipeState&gt;)</ID>
    <ID>FunctionSignature:WalletScreen.kt$@Composable fun WalletScreen( data: WalletState, callback: WalletScreenInterface )</ID>
    <ID>FunctionSignature:WalletScreen.kt$@Composable fun WalletScreenWithRefresh( data: WalletState, callback: WalletScreenInterface )</ID>
    <ID>FunctionSignature:WarningInfo.kt$@Composable fun WarningInfo( state: WarningInfoState, onClick: () -&gt; Unit = {} )</ID>
    <ID>FunctionSignature:WelcomeFragment.kt$WelcomeFragment$private fun configureTermsAndPrivacy(sourceText: String, terms: String, privacy: String)</ID>
    <ID>FunctionSignature:WelcomeFragment.kt$WelcomeFragment.Companion$fun getBundle( displayBack: Boolean, chainAccountData: ChainAccountCreatePayload? = null ): Bundle</ID>
    <ID>FunctionSignature:WssSubstrateSource.kt$WssSubstrateSource$override suspend fun getAssetsAccountInfo( asset: Asset, accountId: AccountId ): AssetsAccountInfo?</ID>
    <ID>FunctionSignature:WssSubstrateSource.kt$WssSubstrateSource$override suspend fun getEquilibriumAccountInfo( asset: Asset, accountId: AccountId ): EqAccountInfo?</ID>
    <ID>FunctionSignature:WssSubstrateSource.kt$WssSubstrateSource$private fun ExtrinsicBuilder.assetsAssetTransfer( accountId: AccountId, transfer: Transfer ): ExtrinsicBuilder</ID>
    <ID>FunctionSignature:WssSubstrateSource.kt$WssSubstrateSource$private fun ExtrinsicBuilder.equilibriumAssetTransfer( accountId: AccountId, transfer: Transfer ): ExtrinsicBuilder</ID>
    <ID>FunctionSignature:WssSubstrateSource.kt$WssSubstrateSource$private fun ExtrinsicBuilder.ormlAssetTransfer( accountId: AccountId, transfer: Transfer )</ID>
    <ID>FunctionSignature:WssSubstrateSource.kt$WssSubstrateSource$private fun ExtrinsicBuilder.ormlChainTransfer( accountId: AccountId, transfer: Transfer )</ID>
    <ID>FunctionSignature:WssSubstrateSource.kt$WssSubstrateSource$private fun ExtrinsicBuilder.soraAssetTransfer( accountId: AccountId, transfer: Transfer )</ID>
    <ID>FunctionSignature:WssSubstrateSource.kt$WssSubstrateSource$private fun ExtrinsicBuilder.transfer(chain: Chain, transfer: Transfer, typeRegistry: TypeRegistry): ExtrinsicBuilder</ID>
    <ID>FunctionSignature:WssSubstrateSource.kt$WssSubstrateSource$private suspend fun getDefaultAccountInfo( chainId: ChainId, accountId: AccountId ): AccountInfo</ID>
    <ID>FunctionSignature:XcmInteractor.kt$XcmInteractor$suspend fun getDestinationFee( destinationChainId: ChainId, tokenConfiguration: Asset ): BigDecimal?</ID>
    <ID>FunctionSignature:kotlin-runtimepermissions-coroutines.kt$suspend fun FragmentActivity.askPermission(vararg permissions: String): PermissionResult</ID>
    <ID>FunctionSignature:kotlin-runtimepermissions.kt$fun Fragment.askPermission(vararg permissions: String, acceptedblock: (PermissionResult) -&gt; Unit): KotlinRuntimePermission</ID>
    <ID>FunctionSignature:kotlin-runtimepermissions.kt$fun FragmentActivity.askPermission(vararg permissions: String, acceptedblock: (PermissionResult) -&gt; Unit): KotlinRuntimePermission</ID>
    <ID>GlobalCoroutineUsage:AccountDataSourceImpl.kt$AccountDataSourceImpl$GlobalScope.launch(Dispatchers.Default) { action() }</ID>
    <ID>IfElseWrapping:MetaAccount.kt$MetaAccount$if (other.ethereumAddress != null) return false</ID>
    <ID>IfElseWrapping:MetaAccount.kt$MetaAccount$if (other.ethereumPublicKey != null) return false</ID>
    <ID>IfElseWrapping:StakingPoolSharedState.kt$EditPoolFlowState$if (other.initialNominator != null) return false</ID>
    <ID>IfElseWrapping:StakingPoolSharedState.kt$EditPoolFlowState$if (other.initialRoot != null) return false</ID>
    <ID>IfElseWrapping:StakingPoolSharedState.kt$EditPoolFlowState$if (other.initialStateToggler != null) return false</ID>
    <ID>IfElseWrapping:StakingPoolSharedState.kt$EditPoolFlowState$if (other.newNominator != null) return false</ID>
    <ID>IfElseWrapping:StakingPoolSharedState.kt$EditPoolFlowState$if (other.newRoot != null) return false</ID>
    <ID>IfElseWrapping:StakingPoolSharedState.kt$EditPoolFlowState$if (other.newStateToggler != null) return false</ID>
    <ID>ImportOrdering:AboutViewModel.kt$import android.content.Context import android.content.pm.PackageManager import android.os.Build import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.account.impl.presentation.about.model.AboutItemModel import jp.co.soramitsu.account.impl.presentation.about.model.AboutSectionModel import jp.co.soramitsu.common.BuildConfig import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.AppLinksProvider import jp.co.soramitsu.common.mixin.api.Browserable import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.feature_account_impl.R import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.flowOf import kotlinx.coroutines.flow.stateIn</ID>
    <ID>ImportOrdering:AcalaContributeView.kt$import android.content.Context import android.graphics.drawable.Drawable import android.util.AttributeSet import androidx.appcompat.content.res.AppCompatResources import androidx.lifecycle.LifecycleCoroutineScope import com.google.android.material.switchmaterial.SwitchMaterial import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.common.view.InputField import jp.co.soramitsu.common.view.Toolbar import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.feature_crowdloan_impl.databinding.AcalaReferralFlowBinding import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeViewState import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.referral.ReferralContributeView</ID>
    <ID>ImportOrdering:AcalaContributeViewState.kt$import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_API_URL import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_BONUS_RATE import jp.co.soramitsu.crowdloan.impl.domain.contribute.custom.acala.AcalaContributeInteractor import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.ApplyActionState import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.model.CustomContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.referral.ReferralCodePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.referral.ReferralContributeViewState import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.getAsBigDecimal import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.getString import kotlinx.coroutines.flow.combine</ID>
    <ID>ImportOrdering:AcalaContributionModule.kt$import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import dagger.multibindings.IntoSet import jp.co.soramitsu.common.data.network.HttpExceptionHandler import jp.co.soramitsu.common.data.network.NetworkApiCreator import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.crowdloan.impl.data.network.api.acala.AcalaApi import jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.CustomContributeFactory import jp.co.soramitsu.crowdloan.impl.domain.contribute.custom.acala.AcalaContributeInteractor import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.acala.AcalaContributeSubmitter import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry</ID>
    <ID>ImportOrdering:AccountDetailsFragment.kt$import android.content.ActivityNotFoundException import android.content.Intent import android.net.Uri import android.os.Bundle import androidx.fragment.app.viewModels import androidx.lifecycle.lifecycleScope import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import javax.inject.Inject import jp.co.soramitsu.account.api.presentation.accountSource.SourceTypeChooserBottomSheetDialog import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.account.api.presentation.actions.copyAddressClicked import jp.co.soramitsu.account.api.presentation.exporting.ExportSourceChooserPayload import jp.co.soramitsu.common.PLAY_MARKET_APP_URI import jp.co.soramitsu.common.PLAY_MARKET_BROWSER_URI import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.mixin.impl.observeBrowserEvents import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.common.utils.nameInputFilters import jp.co.soramitsu.common.view.bottomSheet.AlertBottomSheet import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListBottomSheet import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.feature_account_impl.databinding.FragmentAccountDetailsBinding</ID>
    <ID>ImportOrdering:AccountDetailsViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.AssetNotNeedAccountUseCase import jp.co.soramitsu.account.api.domain.model.hasChainAccount import jp.co.soramitsu.account.api.presentation.actions.AddAccountBottomSheet import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.account.api.presentation.exporting.ExportSource import jp.co.soramitsu.account.api.presentation.exporting.ExportSourceChooserPayload import jp.co.soramitsu.account.api.presentation.exporting.buildExportSourceTypes import jp.co.soramitsu.account.impl.domain.account.details.AccountDetailsInteractor import jp.co.soramitsu.account.impl.domain.account.details.AccountInChain import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createAddressIcon import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.list.headers.TextHeader import jp.co.soramitsu.common.list.toListWithHeaders import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import kotlin.time.DurationUnit import kotlin.time.toDuration import kotlinx.coroutines.FlowPreview import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.debounce import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:AccountFeatureModule.kt$import com.google.gson.Gson import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import javax.inject.Singleton import jp.co.soramitsu.account.api.domain.interfaces.AccountInteractor import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.domain.interfaces.AssetNotNeedAccountUseCase import jp.co.soramitsu.account.api.domain.interfaces.SelectedAccountUseCase import jp.co.soramitsu.account.api.domain.updaters.AccountUpdateScope import jp.co.soramitsu.account.api.presentation.account.AddressDisplayUseCase import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActionsProvider import jp.co.soramitsu.account.impl.data.repository.AccountRepositoryImpl import jp.co.soramitsu.account.impl.data.repository.KeyPairRepository import jp.co.soramitsu.account.impl.data.repository.datasource.AccountDataSource import jp.co.soramitsu.account.impl.data.repository.datasource.AccountDataSourceImpl import jp.co.soramitsu.account.impl.data.repository.datasource.migration.AccountDataMigration import jp.co.soramitsu.account.impl.domain.AccountInteractorImpl import jp.co.soramitsu.account.impl.domain.AssetNotNeedAccountUseCaseImpl import jp.co.soramitsu.account.impl.domain.BeaconConnectedUseCase import jp.co.soramitsu.account.impl.domain.NodeHostValidator import jp.co.soramitsu.account.impl.domain.account.details.AccountDetailsInteractor import jp.co.soramitsu.account.impl.presentation.common.mixin.api.CryptoTypeChooserMixin import jp.co.soramitsu.account.impl.presentation.common.mixin.impl.CryptoTypeChooser import jp.co.soramitsu.common.data.OnboardingStoriesDataSource import jp.co.soramitsu.common.data.network.AppLinksProvider import jp.co.soramitsu.common.data.network.NetworkApiCreator import jp.co.soramitsu.common.data.network.coingecko.CoingeckoApi import jp.co.soramitsu.common.data.secrets.v1.SecretStoreV1 import jp.co.soramitsu.common.data.secrets.v2.SecretStoreV2 import jp.co.soramitsu.common.data.storage.Preferences import jp.co.soramitsu.common.data.storage.encrypt.EncryptedPreferences import jp.co.soramitsu.common.domain.GetAvailableFiatCurrencies import jp.co.soramitsu.common.domain.GetEducationalStoriesUseCase import jp.co.soramitsu.common.domain.SelectedFiat import jp.co.soramitsu.common.domain.ShouldShowEducationalStoriesUseCase import jp.co.soramitsu.common.interfaces.FileProvider import jp.co.soramitsu.common.resources.ClipboardManager import jp.co.soramitsu.common.resources.LanguagesHolder import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.core.extrinsic.keypair_provider.KeypairProvider import jp.co.soramitsu.coredb.dao.AccountDao import jp.co.soramitsu.coredb.dao.AssetDao import jp.co.soramitsu.coredb.dao.MetaAccountDao import jp.co.soramitsu.coredb.dao.TokenPriceDao import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.shared_utils.encrypt.json.JsonSeedDecoder import jp.co.soramitsu.shared_utils.encrypt.json.JsonSeedEncoder</ID>
    <ID>ImportOrdering:AccountInfo.kt$import java.math.BigInteger import jp.co.soramitsu.common.utils.Modules import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.utils.system import jp.co.soramitsu.core.runtime.storage.returnType import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.shared_utils.runtime.RuntimeSnapshot import jp.co.soramitsu.shared_utils.runtime.definitions.types.composite.DictEnum import jp.co.soramitsu.shared_utils.runtime.definitions.types.composite.Struct import jp.co.soramitsu.shared_utils.runtime.definitions.types.fromHexOrNull import jp.co.soramitsu.shared_utils.runtime.metadata.module import jp.co.soramitsu.shared_utils.runtime.metadata.storage</ID>
    <ID>ImportOrdering:AccountsForExportFragment.kt$import androidx.core.os.bundleOf import androidx.fragment.app.viewModels import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListBottomSheet import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.account.api.presentation.accountSource.SourceTypeChooserBottomSheetDialog import jp.co.soramitsu.account.api.presentation.exporting.ExportSourceChooserPayload import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.feature_account_impl.databinding.FragmentAccountsForExportBinding import jp.co.soramitsu.account.impl.domain.account.details.AccountInChain import jp.co.soramitsu.account.impl.presentation.account.details.AccountInChainUi import jp.co.soramitsu.account.impl.presentation.account.details.ChainAccountsAdapter import javax.inject.Inject</ID>
    <ID>ImportOrdering:AccountsForExportViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.list.headers.TextHeader import jp.co.soramitsu.common.list.toListWithHeaders import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.account.api.presentation.exporting.ExportSource import jp.co.soramitsu.account.api.presentation.exporting.ExportSourceChooserPayload import jp.co.soramitsu.account.api.presentation.exporting.buildExportSourceTypes import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.account.impl.domain.account.details.AccountDetailsInteractor import jp.co.soramitsu.account.impl.domain.account.details.AccountInChain import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.account.impl.presentation.account.details.AccountInChainUi import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.polkadotChainId import kotlinx.coroutines.flow.map import kotlinx.coroutines.launch import javax.inject.Inject</ID>
    <ID>ImportOrdering:AdditionalOnChainSubmission.kt$import java.math.BigDecimal import jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.CustomContributeManager import jp.co.soramitsu.crowdloan.impl.domain.contribute.AdditionalOnChainSubmission import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.BonusPayload</ID>
    <ID>ImportOrdering:AdvancedBlockView.kt$import android.content.Context import android.util.AttributeSet import android.view.View import android.view.View.OnClickListener import android.widget.EditText import android.widget.LinearLayout import android.widget.TextView import jp.co.soramitsu.common.utils.makeGone import jp.co.soramitsu.common.utils.makeVisible import jp.co.soramitsu.common.view.InputField import jp.co.soramitsu.common.view.LabeledTextView import jp.co.soramitsu.account.api.presentation.importing.ImportAccountType import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.feature_account_impl.databinding.ViewAdvancedBlockBinding</ID>
    <ID>ImportOrdering:AlertFragment.kt$import android.annotation.SuppressLint import android.os.Build import android.os.Bundle import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import android.widget.FrameLayout import androidx.compose.ui.platform.ComposeView import androidx.core.os.bundleOf import com.google.android.material.bottomsheet.BottomSheetBehavior import com.google.android.material.bottomsheet.BottomSheetDialog import com.google.android.material.bottomsheet.BottomSheetDialogFragment import dagger.hilt.android.AndroidEntryPoint import javax.inject.Inject import jp.co.soramitsu.app.root.navigation.Navigator import jp.co.soramitsu.common.AlertViewState import jp.co.soramitsu.common.R import jp.co.soramitsu.common.compose.component.AlertSheet import jp.co.soramitsu.common.compose.theme.FearlessTheme</ID>
    <ID>ImportOrdering:AmountModel.kt$import androidx.annotation.StringRes import java.math.BigDecimal import java.math.BigInteger import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks</ID>
    <ID>ImportOrdering:Asset.kt$import java.math.BigDecimal import java.math.BigInteger import jp.co.soramitsu.account.api.domain.model.MetaAccount import jp.co.soramitsu.common.model.AssetKey import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.core.models.Asset as CoreAsset</ID>
    <ID>ImportOrdering:AssetCacheExt.kt$import java.math.BigInteger import jp.co.soramitsu.common.data.network.runtime.binding.AccountData import jp.co.soramitsu.common.data.network.runtime.binding.AccountInfo import jp.co.soramitsu.common.data.network.runtime.binding.AssetBalanceData import jp.co.soramitsu.common.data.network.runtime.binding.AssetsAccountInfo import jp.co.soramitsu.common.data.network.runtime.binding.EmptyBalance import jp.co.soramitsu.common.data.network.runtime.binding.EqAccountInfo import jp.co.soramitsu.common.data.network.runtime.binding.OrmlTokensAccountData import jp.co.soramitsu.common.data.network.runtime.binding.bindAccountInfo import jp.co.soramitsu.common.data.network.runtime.binding.bindAssetsAccountInfo import jp.co.soramitsu.common.data.network.runtime.binding.bindEquilibriumAccountInfo import jp.co.soramitsu.common.data.network.runtime.binding.bindNonce import jp.co.soramitsu.common.data.network.runtime.binding.bindOrmlTokensAccountData import jp.co.soramitsu.common.data.network.runtime.binding.cast import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.utils.system import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.core.runtime.storage.returnType import jp.co.soramitsu.coredb.model.AssetLocal import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.shared_utils.runtime.RuntimeSnapshot import jp.co.soramitsu.shared_utils.runtime.definitions.types.composite.Struct import jp.co.soramitsu.shared_utils.runtime.definitions.types.fromHexOrNull import jp.co.soramitsu.shared_utils.runtime.metadata.storage</ID>
    <ID>ImportOrdering:AssetSelectViewModel.kt$import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.mapList import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.wallet.impl.data.mappers.mapAssetToAssetModel import jp.co.soramitsu.wallet.impl.domain.XcmInteractor import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.model.AssetModel import jp.co.soramitsu.wallet.impl.presentation.send.SendSharedState import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import jp.co.soramitsu.wallet.api.presentation.WalletRouter as WalletRouterApi</ID>
    <ID>ImportOrdering:AssetSelectorFactory.kt$import androidx.lifecycle.MutableLiveData import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListBottomSheet import jp.co.soramitsu.wallet.api.data.mappers.mapAssetToAssetModel import jp.co.soramitsu.wallet.api.domain.AssetUseCase import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.api.presentation.model.AssetModel import jp.co.soramitsu.runtime.state.SingleAssetSharedState import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.shareIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:AssetSelectorMixin.kt$import androidx.lifecycle.LiveData import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListBottomSheet import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.api.presentation.model.AssetModel import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.flow.Flow</ID>
    <ID>ImportOrdering:AstarContributeView.kt$import android.content.Context import android.util.AttributeSet import androidx.lifecycle.LifecycleCoroutineScope import jp.co.soramitsu.common.view.InputField import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeViewState import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.referral.ReferralContributeView</ID>
    <ID>ImportOrdering:AstarContributeViewState.kt$import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_BONUS_RATE import jp.co.soramitsu.crowdloan.impl.domain.contribute.custom.astar.AstarContributeInteractor import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.ApplyActionState import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.model.CustomContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.referral.ReferralCodePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.referral.ReferralContributeViewState import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.getAsBigDecimal import kotlinx.coroutines.flow.map</ID>
    <ID>ImportOrdering:AstarContributionModule.kt$import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import dagger.multibindings.IntoSet import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.CustomContributeFactory import jp.co.soramitsu.crowdloan.impl.domain.contribute.custom.astar.AstarContributeInteractor import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.astar.AstarContributeSubmitter</ID>
    <ID>ImportOrdering:BackupMnemonicViewModel.kt$import android.content.Intent import androidx.activity.result.ActivityResultLauncher import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.asFlow import androidx.lifecycle.liveData import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.AccountInteractor import jp.co.soramitsu.account.api.presentation.create_backup_password.CreateBackupPasswordPayload import jp.co.soramitsu.account.api.presentation.importing.ImportAccountType import jp.co.soramitsu.account.api.presentation.importing.importAccountType import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.account.impl.presentation.common.mixin.api.CryptoTypeChooserMixin import jp.co.soramitsu.account.impl.presentation.mnemonic.backup.exceptions.NotValidDerivationPath import jp.co.soramitsu.account.impl.presentation.mnemonic.confirm.ConfirmMnemonicPayload import jp.co.soramitsu.account.impl.presentation.mnemonic.confirm.ConfirmMnemonicPayload.CreateExtras import jp.co.soramitsu.backup.BackupService import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.MnemonicWordModel import jp.co.soramitsu.common.compose.component.mapMnemonicToMnemonicWords import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.flow import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:BalanceDetailOptionsBottomSheet.kt$import android.content.Context import android.os.Bundle import jp.co.soramitsu.common.R import jp.co.soramitsu.common.view.bottomSheet.list.fixed.FixedListBottomSheet import jp.co.soramitsu.common.view.bottomSheet.list.fixed.item import jp.co.soramitsu.account.api.presentation.actions.CopyCallback</ID>
    <ID>ImportOrdering:BalanceDetailViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import javax.inject.Inject import jp.co.soramitsu.account.api.presentation.account.AddressDisplayUseCase import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.account.api.presentation.exporting.ExportSource import jp.co.soramitsu.account.api.presentation.exporting.ExportSourceChooserPayload import jp.co.soramitsu.account.api.presentation.exporting.buildExportSourceTypes import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.ActionBarViewState import jp.co.soramitsu.common.compose.component.ActionItemType import jp.co.soramitsu.common.compose.component.AssetBalanceViewState import jp.co.soramitsu.common.compose.component.ChainSelectorViewState import jp.co.soramitsu.common.compose.component.ChangeBalanceViewState import jp.co.soramitsu.common.compose.component.MainToolbarViewState import jp.co.soramitsu.common.compose.component.TitleValueViewState import jp.co.soramitsu.common.compose.component.ToolbarHomeIconState import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.resources.ClipboardManager import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.formatAsChange import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.mapList import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.soraMainChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.soraTestChainId import jp.co.soramitsu.wallet.impl.data.mappers.mapAssetToAssetModel import jp.co.soramitsu.wallet.impl.domain.ChainInteractor import jp.co.soramitsu.wallet.impl.domain.CurrentAccountAddressUseCase import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.presentation.AssetPayload import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.balance.assetActions.buy.BuyMixin import jp.co.soramitsu.wallet.impl.presentation.balance.chainselector.toChainItemState import jp.co.soramitsu.wallet.impl.presentation.balance.detail.frozen.FrozenAssetPayload import jp.co.soramitsu.wallet.impl.presentation.model.AssetModel import jp.co.soramitsu.wallet.impl.presentation.model.OperationModel import jp.co.soramitsu.wallet.impl.presentation.transaction.filter.HistoryFiltersProvider import jp.co.soramitsu.wallet.impl.presentation.transaction.history.mixin.TransactionHistoryProvider import jp.co.soramitsu.wallet.impl.presentation.transaction.history.mixin.TransactionHistoryUi import jp.co.soramitsu.xcm.XcmService import kotlinx.coroutines.async import kotlinx.coroutines.cancel import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.firstOrNull import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:BalanceListItemModel.kt$import java.math.BigDecimal import jp.co.soramitsu.common.compose.viewstate.AssetListItemViewState import jp.co.soramitsu.common.utils.formatAsChange import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.runtime.multiNetwork.chain.ChainEcosystem import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.wallet.impl.domain.model.Token</ID>
    <ID>ImportOrdering:BalanceListViewModel.kt$import androidx.compose.material.ExperimentalMaterialApi import androidx.compose.material.SwipeableState import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import java.util.Locale import java.util.concurrent.TimeUnit import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.presentation.actions.AddAccountBottomSheet import jp.co.soramitsu.common.AlertViewState import jp.co.soramitsu.common.BuildConfig import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.ActionItemType import jp.co.soramitsu.common.compose.component.AssetBalanceViewState import jp.co.soramitsu.common.compose.component.ChainSelectorViewState import jp.co.soramitsu.common.compose.component.ChangeBalanceViewState import jp.co.soramitsu.common.compose.component.MainToolbarViewState import jp.co.soramitsu.common.compose.component.MultiToggleButtonState import jp.co.soramitsu.common.compose.component.NetworkIssueItemState import jp.co.soramitsu.common.compose.component.SwipeState import jp.co.soramitsu.common.compose.component.ToolbarHomeIconState import jp.co.soramitsu.common.compose.viewstate.AssetListItemViewState import jp.co.soramitsu.common.data.network.OptionsProvider import jp.co.soramitsu.common.data.network.coingecko.FiatChooserEvent import jp.co.soramitsu.common.data.network.coingecko.FiatCurrency import jp.co.soramitsu.common.domain.FiatCurrencies import jp.co.soramitsu.common.domain.GetAvailableFiatCurrencies import jp.co.soramitsu.common.domain.SelectedFiat import jp.co.soramitsu.common.mixin.api.NetworkStateMixin import jp.co.soramitsu.common.mixin.api.NetworkStateUi import jp.co.soramitsu.common.mixin.api.UpdatesMixin import jp.co.soramitsu.common.mixin.api.UpdatesProviderUi import jp.co.soramitsu.common.model.AssetKey import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.resources.ClipboardManager import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.formatAsChange import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.isZero import jp.co.soramitsu.common.utils.mapList import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.utils.sumByBigDecimal import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListBottomSheet import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.oauth.base.sdk.SoraCardEnvironmentType import jp.co.soramitsu.oauth.base.sdk.SoraCardInfo import jp.co.soramitsu.oauth.base.sdk.SoraCardKycCredentials import jp.co.soramitsu.oauth.base.sdk.contract.SoraCardCommonVerification import jp.co.soramitsu.oauth.base.sdk.contract.SoraCardContractData import jp.co.soramitsu.oauth.common.domain.KycRepository import jp.co.soramitsu.runtime.ext.ecosystem import jp.co.soramitsu.runtime.multiNetwork.chain.ChainEcosystem import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.defaultChainSort import jp.co.soramitsu.runtime.multiNetwork.chain.model.getWithToken import jp.co.soramitsu.runtime.multiNetwork.chain.model.polkadotChainId import jp.co.soramitsu.shared_utils.ss58.SS58Encoder.addressByteOrNull import jp.co.soramitsu.soracard.api.domain.SoraCardInteractor import jp.co.soramitsu.soracard.impl.presentation.SoraCardItemViewState import jp.co.soramitsu.wallet.impl.data.mappers.mapAssetToAssetModel import jp.co.soramitsu.wallet.impl.domain.ChainInteractor import jp.co.soramitsu.wallet.impl.domain.CurrentAccountAddressUseCase import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.domain.model.AssetWithStatus import jp.co.soramitsu.wallet.impl.domain.model.WalletAccount import jp.co.soramitsu.wallet.impl.presentation.AssetPayload import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.balance.chainselector.toChainItemState import jp.co.soramitsu.wallet.impl.presentation.balance.list.model.AssetType import jp.co.soramitsu.wallet.impl.presentation.balance.list.model.BalanceListItemModel import jp.co.soramitsu.wallet.impl.presentation.balance.list.model.BalanceModel import jp.co.soramitsu.wallet.impl.presentation.balance.list.model.toAssetState import jp.co.soramitsu.wallet.impl.presentation.model.AssetModel import jp.co.soramitsu.wallet.impl.presentation.model.AssetUpdateState import jp.co.soramitsu.wallet.impl.presentation.model.AssetWithStateModel import jp.co.soramitsu.wallet.impl.presentation.model.ControllerDeprecationWarningModel import jp.co.soramitsu.wallet.impl.presentation.model.toModel import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.FlowPreview import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.catch import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.debounce import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.flowOf import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.flow.onStart import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch import kotlinx.coroutines.withContext import jp.co.soramitsu.oauth.R as SoraCardR</ID>
    <ID>ImportOrdering:BalancesUpdateSystem.kt$import android.util.Log import java.util.concurrent.ConcurrentHashMap import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.domain.model.accountId import jp.co.soramitsu.common.data.network.StorageSubscriptionBuilder import jp.co.soramitsu.common.data.network.rpc.BulkRetriever import jp.co.soramitsu.common.utils.diffed import jp.co.soramitsu.core.updater.UpdateSystem import jp.co.soramitsu.core.updater.Updater import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.getSocket import jp.co.soramitsu.runtime.multiNetwork.getSocketOrNull import jp.co.soramitsu.shared_utils.wsrpc.SocketService import jp.co.soramitsu.shared_utils.wsrpc.request.runtime.storage.subscribeUsing import jp.co.soramitsu.wallet.api.data.cache.AssetCache import jp.co.soramitsu.wallet.api.data.cache.updateAsset import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.catch import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.emitAll import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.flow import kotlinx.coroutines.flow.flowOn import kotlinx.coroutines.flow.merge import kotlinx.coroutines.flow.onCompletion import kotlinx.coroutines.flow.onStart import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:BaseConfirmViewModel.kt$import androidx.annotation.DrawableRes import androidx.annotation.StringRes import androidx.lifecycle.viewModelScope import java.math.BigInteger import jp.co.soramitsu.common.AlertViewState import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.base.errors.TitledException import jp.co.soramitsu.common.base.errors.ValidationException import jp.co.soramitsu.common.compose.component.ConfirmScreenViewState import jp.co.soramitsu.common.compose.component.GradientIconState import jp.co.soramitsu.common.compose.component.TitleValueViewState import jp.co.soramitsu.common.compose.component.ToolbarViewState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.applyFiatRate import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.validation.FeeInsufficientBalanceException import jp.co.soramitsu.common.validation.WaitForFeeCalculationException import jp.co.soramitsu.feature_wallet_api.R import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.wallet.api.domain.ExistentialDepositUseCase import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.filterNotNull import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:BaseEnterAmountViewModel.kt$import androidx.annotation.StringRes import androidx.lifecycle.viewModelScope import java.math.BigDecimal import java.math.BigInteger import jp.co.soramitsu.common.AlertViewState import jp.co.soramitsu.common.R import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.base.errors.ValidationException import jp.co.soramitsu.common.compose.component.AmountInputViewState import jp.co.soramitsu.common.compose.component.ButtonViewState import jp.co.soramitsu.common.compose.component.EnterAmountViewState import jp.co.soramitsu.common.compose.component.FeeInfoViewState import jp.co.soramitsu.common.compose.component.ToolbarViewState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.applyFiatRate import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:BeaconViewModel.kt$import android.os.Parcelable import android.util.Log import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import it.airgap.beaconsdk.blockchain.substrate.data.SubstrateNetwork import it.airgap.beaconsdk.blockchain.substrate.message.request.PermissionSubstrateRequest import it.airgap.beaconsdk.blockchain.substrate.message.request.SignPayloadSubstrateRequest import it.airgap.beaconsdk.core.data.P2pPeer import it.airgap.beaconsdk.core.message.BeaconRequest import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.TotalBalanceUseCase import jp.co.soramitsu.account.api.domain.model.MetaAccount import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.wallet.impl.domain.beacon.BeaconInteractor import jp.co.soramitsu.wallet.impl.domain.beacon.SignStatus import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.beacon.main.BeaconStateMachine.SideEffect import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.distinctUntilChanged import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.launch import kotlinx.parcelize.Parcelize</ID>
    <ID>ImportOrdering:BifrostContributeViewState.kt$import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.crowdloan.impl.domain.contribute.custom.bifrost.BifrostContributeInteractor import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.model.CustomContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.referral.ReferralCodePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.referral.ReferralContributeViewState</ID>
    <ID>ImportOrdering:BlockProducersSorting.kt$import java.math.BigDecimal import jp.co.soramitsu.staking.api.domain.model.Collator import jp.co.soramitsu.staking.api.domain.model.Validator import jp.co.soramitsu.staking.impl.domain.recommendations.settings.notElected</ID>
    <ID>ImportOrdering:BondMoreValidationsModule.kt$import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import jp.co.soramitsu.common.validation.CompositeValidation import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.impl.domain.validations.bond.BondMoreFeeValidation import jp.co.soramitsu.staking.impl.domain.validations.bond.BondMoreValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.bond.BondMoreValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.bond.BondMoreValidationSystem import jp.co.soramitsu.staking.impl.domain.validations.bond.NotZeroBondValidation import jp.co.soramitsu.staking.impl.domain.validations.setup.SetupStakingFeeValidation import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletRepository import jp.co.soramitsu.wallet.impl.domain.validation.EnoughToPayFeesValidation import jp.co.soramitsu.wallet.impl.domain.validation.assetBalanceProducer import javax.inject.Singleton</ID>
    <ID>ImportOrdering:CandidateInfo.kt$import android.os.Parcelable import java.math.BigInteger import kotlinx.parcelize.Parcelize</ID>
    <ID>ImportOrdering:ChainAccountsAdapter.kt$import android.view.View import android.view.ViewGroup import android.widget.ImageView import android.widget.TextView import androidx.core.view.children import androidx.core.view.isVisible import coil.ImageLoader import coil.load import jp.co.soramitsu.common.list.BaseGroupedDiffCallback import jp.co.soramitsu.common.list.GroupedListAdapter import jp.co.soramitsu.common.list.GroupedListHolder import jp.co.soramitsu.common.list.headers.TextHeader import jp.co.soramitsu.common.list.headers.TextHeaderHolder import jp.co.soramitsu.common.utils.castOrNull import jp.co.soramitsu.common.utils.inflateChild import jp.co.soramitsu.common.view.shape.getCutLeftBottomCornerDrawableFromColors import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.account.impl.domain.account.details.AccountInChain</ID>
    <ID>ImportOrdering:ChainAssetsManager.kt$import javax.inject.Inject import jp.co.soramitsu.common.compose.component.SelectorState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.core.models.ChainId import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.balance.chainselector.ChainItemState import jp.co.soramitsu.xcm.domain.XcmEntitiesFetcher import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Job import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.catch import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.onEach import jp.co.soramitsu.wallet.api.presentation.WalletRouter as WalletRouterApi</ID>
    <ID>ImportOrdering:ChainRegistry.kt$import javax.inject.Inject import jp.co.soramitsu.common.mixin.api.UpdatesMixin import jp.co.soramitsu.common.mixin.api.UpdatesProviderUi import jp.co.soramitsu.common.utils.diffed import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.mapList import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.core.models.IChain import jp.co.soramitsu.core.runtime.ChainConnection import jp.co.soramitsu.core.runtime.IChainRegistry import jp.co.soramitsu.coredb.dao.ChainDao import jp.co.soramitsu.coredb.model.chain.ChainNodeLocal import jp.co.soramitsu.runtime.multiNetwork.chain.ChainSyncService import jp.co.soramitsu.runtime.multiNetwork.chain.mapChainLocalToChain import jp.co.soramitsu.runtime.multiNetwork.chain.mapNodeLocalToNode import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.NodeId import jp.co.soramitsu.runtime.multiNetwork.connection.ConnectionPool import jp.co.soramitsu.runtime.multiNetwork.runtime.RuntimeProvider import jp.co.soramitsu.runtime.multiNetwork.runtime.RuntimeProviderPool import jp.co.soramitsu.runtime.multiNetwork.runtime.RuntimeSubscriptionPool import jp.co.soramitsu.runtime.multiNetwork.runtime.RuntimeSyncService import jp.co.soramitsu.shared_utils.runtime.RuntimeSnapshot import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.flow.MutableSharedFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.distinctUntilChanged import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.shareIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:ChainRegistryModule.kt$import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import javax.inject.Provider import javax.inject.Singleton import jp.co.soramitsu.common.data.network.NetworkApiCreator import jp.co.soramitsu.common.data.storage.Preferences import jp.co.soramitsu.common.interfaces.FileProvider import jp.co.soramitsu.common.mixin.api.NetworkStateMixin import jp.co.soramitsu.common.mixin.api.UpdatesMixin import jp.co.soramitsu.core.network.JsonFactory import jp.co.soramitsu.core.runtime.ChainConnection import jp.co.soramitsu.core.runtime.RuntimeFactory import jp.co.soramitsu.coredb.dao.ChainDao import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.ChainSyncService import jp.co.soramitsu.runtime.multiNetwork.chain.remote.ChainFetcher import jp.co.soramitsu.runtime.multiNetwork.connection.ConnectionPool import jp.co.soramitsu.runtime.multiNetwork.runtime.RuntimeFilesCache import jp.co.soramitsu.runtime.multiNetwork.runtime.RuntimeProviderPool import jp.co.soramitsu.runtime.multiNetwork.runtime.RuntimeSubscriptionPool import jp.co.soramitsu.runtime.multiNetwork.runtime.RuntimeSyncService import jp.co.soramitsu.runtime.multiNetwork.runtime.types.TypesFetcher import jp.co.soramitsu.runtime.storage.NodesSettingsStorage import jp.co.soramitsu.shared_utils.wsrpc.SocketService import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.serialization.json.Json</ID>
    <ID>ImportOrdering:ChainSelectViewModel.kt$import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.AccountInteractor import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.runtime.ext.ecosystem import jp.co.soramitsu.runtime.multiNetwork.chain.ChainEcosystem import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.defaultChainSort import jp.co.soramitsu.wallet.api.domain.model.XcmChainType import jp.co.soramitsu.wallet.impl.domain.ChainInteractor import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.send.SendSharedState import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch import jp.co.soramitsu.wallet.api.presentation.WalletRouter as WalletRouterApi</ID>
    <ID>ImportOrdering:ChangeRewardDestinationInteractor.kt$import java.math.BigInteger import jp.co.soramitsu.core.extrinsic.ExtrinsicService import jp.co.soramitsu.staking.api.domain.model.RewardDestination import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.data.network.blockhain.calls.setPayee import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:Collator.kt$import java.math.BigDecimal import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.address.createEthereumAddressModel import jp.co.soramitsu.common.utils.formatAsPercentage import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.staking.api.domain.model.CandidateInfo import jp.co.soramitsu.staking.api.domain.model.Collator import jp.co.soramitsu.staking.api.domain.model.Identity import jp.co.soramitsu.staking.impl.domain.recommendations.settings.sortings.BlockProducersSorting import jp.co.soramitsu.staking.impl.presentation.validators.change.CollatorModel import jp.co.soramitsu.wallet.impl.domain.model.Token import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks</ID>
    <ID>ImportOrdering:CollatorDetailsFragment.kt$import android.os.Bundle import androidx.fragment.app.viewModels import dagger.hilt.android.AndroidEntryPoint import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.mixin.impl.observeBrowserEvents import jp.co.soramitsu.common.utils.createSendEmailIntent import jp.co.soramitsu.common.utils.makeGone import jp.co.soramitsu.common.utils.makeVisible import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.account.api.presentation.actions.setupExternalActions import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.feature_staking_impl.databinding.FragmentCollatorDetailsBinding import jp.co.soramitsu.staking.impl.presentation.validators.parcel.CollatorDetailsParcelModel</ID>
    <ID>ImportOrdering:CollatorDetailsViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createEthereumAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.AppLinksProvider import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.formatAsPercentage import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import jp.co.soramitsu.shared_utils.extensions.fromHex import jp.co.soramitsu.staking.api.domain.model.CandidateInfoStatus import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.rewards.RewardCalculatorFactory import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.validators.details.CollatorDetailsFragment.Companion.KEY_COLLATOR import jp.co.soramitsu.staking.impl.presentation.validators.details.model.CollatorDetailsModel import jp.co.soramitsu.staking.impl.presentation.validators.details.model.IdentityModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.CollatorDetailsParcelModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.CollatorStakeParcelModel import jp.co.soramitsu.wallet.api.presentation.formatters.formatCryptoDetailFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.launch import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:CollatorProvider.kt$import jp.co.soramitsu.common.utils.mapValuesNotNull import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.domain.model.accountId import jp.co.soramitsu.staking.api.domain.api.AccountIdMap import jp.co.soramitsu.staking.api.domain.api.IdentityRepository import jp.co.soramitsu.staking.api.domain.model.Collator import jp.co.soramitsu.staking.impl.data.repository.StakingConstantsRepository import jp.co.soramitsu.staking.impl.domain.rewards.RewardCalculatorFactory import jp.co.soramitsu.staking.impl.presentation.mappers.toCollator import jp.co.soramitsu.staking.impl.scenarios.parachain.StakingParachainScenarioRepository import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain</ID>
    <ID>ImportOrdering:CollatorRecommendator.kt$import java.math.BigInteger import jp.co.soramitsu.staking.api.domain.model.Collator import jp.co.soramitsu.staking.impl.domain.recommendations.settings.RecommendationSettings import jp.co.soramitsu.staking.impl.domain.recommendations.settings.filters.applyFilters import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:CollatorRecommendatorFactory.kt$import androidx.lifecycle.Lifecycle import jp.co.soramitsu.common.data.memory.ComputationalCache import jp.co.soramitsu.staking.api.domain.model.Collator import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.impl.domain.validators.CollatorProvider import jp.co.soramitsu.runtime.state.chain import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:CommonModule.kt$import android.content.ContentResolver import android.content.Context import android.content.SharedPreferences import android.graphics.Color import android.os.Vibrator import coil.ImageLoader import coil.decode.SvgDecoder import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import java.security.SecureRandom import java.util.Random import javax.inject.Qualifier import javax.inject.Singleton import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.CachingAddressIconGenerator import jp.co.soramitsu.common.address.StatelessAddressIconGenerator import jp.co.soramitsu.common.data.FileProviderImpl import jp.co.soramitsu.common.data.memory.ComputationalCache import jp.co.soramitsu.common.data.network.rpc.BulkRetriever import jp.co.soramitsu.common.data.secrets.v1.SecretStoreV1 import jp.co.soramitsu.common.data.secrets.v1.SecretStoreV1Impl import jp.co.soramitsu.common.data.secrets.v2.SecretStoreV2 import jp.co.soramitsu.common.data.storage.Preferences import jp.co.soramitsu.common.data.storage.PreferencesImpl import jp.co.soramitsu.common.data.storage.encrypt.EncryptedPreferences import jp.co.soramitsu.common.data.storage.encrypt.EncryptedPreferencesImpl import jp.co.soramitsu.common.data.storage.encrypt.EncryptionUtil import jp.co.soramitsu.common.interfaces.FileProvider import jp.co.soramitsu.common.mixin.api.NetworkStateMixin import jp.co.soramitsu.common.mixin.api.UpdatesMixin import jp.co.soramitsu.common.mixin.impl.NetworkStateProvider import jp.co.soramitsu.common.mixin.impl.UpdatesProvider import jp.co.soramitsu.common.resources.ClipboardManager import jp.co.soramitsu.common.resources.ContextManager import jp.co.soramitsu.common.resources.LanguagesHolder import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.resources.ResourceManagerImpl import jp.co.soramitsu.common.utils.QrCodeGenerator import jp.co.soramitsu.common.validation.ValidationExecutor import jp.co.soramitsu.common.vibration.DeviceVibrator import jp.co.soramitsu.core.extrinsic.ExtrinsicBuilderFactory import jp.co.soramitsu.core.extrinsic.ExtrinsicService import jp.co.soramitsu.core.extrinsic.keypair_provider.KeypairProvider import jp.co.soramitsu.core.rpc.RpcCalls import jp.co.soramitsu.shared_utils.encrypt.Signer import jp.co.soramitsu.shared_utils.icon.IconGenerator</ID>
    <ID>ImportOrdering:ConfirmBondMoreFragment.kt$import android.os.Bundle import androidx.fragment.app.viewModels import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import dev.chrisbanes.insetter.applyInsetter import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.mixin.impl.observeValidations import jp.co.soramitsu.common.view.setProgress import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.account.api.presentation.actions.setupExternalActions import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.feature_staking_impl.databinding.FragmentConfirmBondMoreBinding import javax.inject.Inject</ID>
    <ID>ImportOrdering:ConfirmBondMoreViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.liveData import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.mixin.api.Validatable import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.requireException import jp.co.soramitsu.common.validation.ValidationExecutor import jp.co.soramitsu.common.validation.progressConsumer import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.staking.bond.BondMoreInteractor import jp.co.soramitsu.staking.impl.domain.validations.bond.BondMoreValidationPayload import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.staking.bond.bondMoreValidationFailure import jp.co.soramitsu.staking.impl.scenarios.StakingScenarioInteractor import jp.co.soramitsu.wallet.api.data.mappers.mapAssetToAssetModel import jp.co.soramitsu.wallet.api.data.mappers.mapFeeToFeeModel import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeStatus import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:ConfirmContributeFragment.kt$import android.os.Bundle import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import androidx.fragment.app.viewModels import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import dev.chrisbanes.insetter.applyInsetter import java.math.BigDecimal import javax.inject.Inject import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.mixin.impl.observeBrowserEvents import jp.co.soramitsu.common.mixin.impl.observeValidations import jp.co.soramitsu.common.utils.setVisible import jp.co.soramitsu.common.view.setProgress import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.feature_crowdloan_impl.databinding.FragmentContributeConfirmBinding import jp.co.soramitsu.account.api.presentation.actions.setupExternalActions import jp.co.soramitsu.crowdloan.impl.presentation.contribute.confirm.parcel.ConfirmContributePayload import jp.co.soramitsu.wallet.api.presentation.mixin.observeTransferChecks</ID>
    <ID>ImportOrdering:ConfirmContributePayload.kt$import android.os.Parcelable import java.math.BigDecimal import jp.co.soramitsu.crowdloan.api.data.network.blockhain.binding.ParaId import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.BonusPayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.acala.AcalaContributionType import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.acala.AcalaContributionType.DirectDOT import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.ParachainMetadataParcelModel import kotlinx.parcelize.Parcelize</ID>
    <ID>ImportOrdering:ConfirmCreatePoolViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigInteger import javax.inject.Inject import jp.co.soramitsu.common.compose.component.TitleValueViewState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.impl.presentation.StakingConfirmViewModel import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SelectValidatorFlowState import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.wallet.api.domain.ExistentialDepositUseCase import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.stateIn</ID>
    <ID>ImportOrdering:ConfirmJoinPoolViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.GradientIconState import jp.co.soramitsu.common.compose.component.TitleValueViewState import jp.co.soramitsu.common.compose.component.ToolbarViewState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.staking.api.domain.model.PoolInfo import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:ConfirmMnemonicViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.combine import jp.co.soramitsu.common.utils.map import jp.co.soramitsu.common.utils.requireException import jp.co.soramitsu.common.utils.sendEvent import jp.co.soramitsu.common.vibration.DeviceVibrator import jp.co.soramitsu.account.api.domain.interfaces.AccountInteractor import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.account.impl.presentation.mnemonic.confirm.ConfirmMnemonicFragment.Companion.KEY_PAYLOAD import kotlinx.coroutines.launch import javax.inject.Inject</ID>
    <ID>ImportOrdering:ConfirmNominationsViewModel.kt$import androidx.lifecycle.liveData import androidx.lifecycle.map import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import javax.inject.Named import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.api.domain.model.Validator import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.getSelectedChain import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingSharedState import jp.co.soramitsu.staking.impl.presentation.mappers.mapValidatorToValidatorDetailsParcelModel import jp.co.soramitsu.staking.impl.presentation.mappers.mapValidatorToValidatorModel import jp.co.soramitsu.staking.impl.presentation.validators.change.ValidatorModel import jp.co.soramitsu.staking.impl.presentation.validators.findSelectedValidator import jp.co.soramitsu.wallet.impl.domain.TokenUseCase import jp.co.soramitsu.wallet.impl.domain.model.Token import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:ConfirmPayoutFragment.kt$import android.os.Bundle import androidx.fragment.app.viewModels import dagger.hilt.android.AndroidEntryPoint import dev.chrisbanes.insetter.applyInsetter import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.mixin.impl.observeValidations import jp.co.soramitsu.common.view.setProgress import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.account.api.presentation.actions.setupExternalActions import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.feature_staking_impl.databinding.FragmentConfirmPayoutBinding import jp.co.soramitsu.staking.impl.presentation.payouts.confirm.model.ConfirmPayoutPayload import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeViews import jp.co.soramitsu.wallet.api.presentation.mixin.fee.displayFeeStatus</ID>
    <ID>ImportOrdering:ConfirmPayoutViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import javax.inject.Named import jp.co.soramitsu.account.api.presentation.account.AddressDisplayUseCase import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.base.TitleAndMessage import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.mixin.api.Validatable import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.requireException import jp.co.soramitsu.common.validation.ValidationExecutor import jp.co.soramitsu.common.validation.ValidationSystem import jp.co.soramitsu.common.validation.progressConsumer import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import jp.co.soramitsu.shared_utils.ss58.SS58Encoder.addressByte import jp.co.soramitsu.shared_utils.ss58.SS58Encoder.toAddress import jp.co.soramitsu.staking.api.domain.model.RewardDestination import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.data.model.Payout import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.payout.PayoutInteractor import jp.co.soramitsu.staking.impl.domain.validations.payout.MakePayoutPayload import jp.co.soramitsu.staking.impl.domain.validations.payout.PayoutValidationFailure import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.payouts.confirm.model.ConfirmPayoutPayload import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioInteractor import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeLoaderMixin import jp.co.soramitsu.wallet.api.presentation.mixin.fee.requireFee import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:ConfirmPoolBondMoreViewModel.kt$import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.impl.presentation.StakingConfirmViewModel import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.wallet.api.domain.ExistentialDepositUseCase import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:ConfirmPoolClaimViewModel.kt$import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigInteger import javax.inject.Inject import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.validation.FeeInsufficientBalanceException import jp.co.soramitsu.common.validation.WaitForFeeCalculationException import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.impl.presentation.StakingConfirmViewModel import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.wallet.api.domain.ExistentialDepositUseCase</ID>
    <ID>ImportOrdering:ConfirmPoolRedeemViewModel.kt$import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigInteger import javax.inject.Inject import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.validation.FeeInsufficientBalanceException import jp.co.soramitsu.common.validation.WaitForFeeCalculationException import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.impl.presentation.StakingConfirmViewModel import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.wallet.api.domain.ExistentialDepositUseCase</ID>
    <ID>ImportOrdering:ConfirmPoolUnbondViewModel.kt$import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigInteger import javax.inject.Inject import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.validation.FeeInsufficientBalanceException import jp.co.soramitsu.common.validation.WaitForFeeCalculationException import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.impl.presentation.StakingConfirmViewModel import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.wallet.api.domain.ExistentialDepositUseCase</ID>
    <ID>ImportOrdering:ConfirmRebondFragment.kt$import androidx.core.os.bundleOf import androidx.fragment.app.viewModels import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import dev.chrisbanes.insetter.applyInsetter import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.mixin.impl.observeRetries import jp.co.soramitsu.common.mixin.impl.observeValidations import jp.co.soramitsu.common.view.setProgress import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.account.api.presentation.actions.setupExternalActions import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.feature_staking_impl.databinding.FragmentConfirmRebondBinding import javax.inject.Inject</ID>
    <ID>ImportOrdering:ConfirmRewardDestinationFragment.kt$import android.os.Bundle import androidx.fragment.app.viewModels import dagger.hilt.android.AndroidEntryPoint import dev.chrisbanes.insetter.applyInsetter import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.mixin.impl.observeValidations import jp.co.soramitsu.common.view.setProgress import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.account.api.presentation.actions.setupExternalActions import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.feature_staking_impl.databinding.FragmentConfirmRewardDestinationBinding import jp.co.soramitsu.staking.impl.presentation.staking.rewardDestination.confirm.parcel.ConfirmRewardDestinationPayload</ID>
    <ID>ImportOrdering:ConfirmRewardDestinationPayload.kt$import android.os.Parcelable import java.math.BigDecimal import kotlinx.parcelize.Parcelize</ID>
    <ID>ImportOrdering:ConfirmRewardDestinationViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import dagger.hilt.android.lifecycle.HiltViewModel import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.mixin.api.Validatable import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.requireException import jp.co.soramitsu.common.validation.ValidationExecutor import jp.co.soramitsu.common.validation.progressConsumer import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.account.api.presentation.account.AddressDisplayUseCase import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.staking.api.domain.model.RewardDestination import jp.co.soramitsu.staking.api.domain.model.StakingAccount import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.data.mappers.mapRewardDestinationModelToRewardDestination import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.staking.rewardDestination.ChangeRewardDestinationInteractor import jp.co.soramitsu.staking.impl.domain.validations.rewardDestination.RewardDestinationValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.rewardDestination.RewardDestinationValidationSystem import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.rewardDestination.RewardDestinationModel import jp.co.soramitsu.staking.impl.presentation.staking.rewardDestination.confirm.parcel.ConfirmRewardDestinationPayload import jp.co.soramitsu.staking.impl.presentation.staking.rewardDestination.confirm.parcel.RewardDestinationParcelModel import jp.co.soramitsu.staking.impl.presentation.staking.rewardDestination.select.rewardDestinationValidationFailure import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioInteractor import jp.co.soramitsu.wallet.api.data.mappers.mapFeeToFeeModel import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeStatus import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import kotlinx.coroutines.flow.filterIsInstance import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.flowOf import kotlinx.coroutines.flow.map import kotlinx.coroutines.launch import javax.inject.Inject</ID>
    <ID>ImportOrdering:ConfirmSelectValidatorsViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.compose.component.TitleValueViewState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.impl.presentation.StakingConfirmViewModel import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.wallet.api.domain.ExistentialDepositUseCase import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.stateIn</ID>
    <ID>ImportOrdering:ConfirmSendViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.common.AlertViewState import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.base.errors.ValidationException import jp.co.soramitsu.common.base.errors.ValidationWarning import jp.co.soramitsu.common.compose.component.ButtonViewState import jp.co.soramitsu.common.compose.component.TitleValueViewState import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.combine import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatting.shortenAddress import jp.co.soramitsu.common.utils.requireException import jp.co.soramitsu.common.utils.requireValue import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import jp.co.soramitsu.wallet.api.domain.TransferValidationResult import jp.co.soramitsu.wallet.api.domain.ValidateTransferUseCase import jp.co.soramitsu.wallet.api.domain.fromValidationResult import jp.co.soramitsu.wallet.api.presentation.mixin.TransferValidityChecks import jp.co.soramitsu.wallet.impl.data.mappers.mapAssetToAssetModel import jp.co.soramitsu.wallet.impl.domain.CurrentAccountAddressUseCase import jp.co.soramitsu.wallet.impl.domain.interfaces.NotValidTransferStatus import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletConstants import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.domain.model.PhishingType import jp.co.soramitsu.wallet.impl.domain.model.Transfer import jp.co.soramitsu.wallet.impl.domain.model.TransferValidityLevel import jp.co.soramitsu.wallet.impl.domain.model.TransferValidityStatus import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.send.TransferDraft import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.ExperimentalCoroutinesApi import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.firstOrNull import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:ConfirmSetControllerFragment.kt$import android.os.Bundle import androidx.fragment.app.viewModels import dagger.hilt.android.AndroidEntryPoint import dev.chrisbanes.insetter.applyInsetter import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.mixin.impl.observeValidations import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.account.api.presentation.actions.setupExternalActions import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.feature_staking_impl.databinding.FragmentConfirmSetControllerBinding</ID>
    <ID>ImportOrdering:ConfirmSetControllerPayload.kt$import android.os.Parcelable import kotlinx.parcelize.Parcelize import java.math.BigDecimal import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId</ID>
    <ID>ImportOrdering:ConfirmSetControllerViewModel.kt$import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.liveData import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.mixin.api.Validatable import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.validation.ValidationExecutor import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.staking.controller.ControllerInteractor import jp.co.soramitsu.staking.impl.domain.validations.controller.SetControllerValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.controller.SetControllerValidationSystem import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.staking.controller.set.bondSetControllerValidationFailure import jp.co.soramitsu.wallet.api.data.mappers.mapFeeToFeeModel import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeStatus import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:ConfirmStakingViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.liveData import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import javax.inject.Inject import javax.inject.Named import jp.co.soramitsu.account.api.presentation.account.AddressDisplayUseCase import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.mixin.api.Retriable import jp.co.soramitsu.common.mixin.api.Validatable import jp.co.soramitsu.common.resources.ClipboardManager import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.requireException import jp.co.soramitsu.common.validation.ValidationExecutor import jp.co.soramitsu.common.validation.progressConsumer import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.ext.addressOf import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import jp.co.soramitsu.staking.api.domain.model.RewardDestination import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.api.domain.model.Validator import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.getSelectedChain import jp.co.soramitsu.staking.impl.domain.setup.BondPayload import jp.co.soramitsu.staking.impl.domain.setup.SetupStakingInteractor import jp.co.soramitsu.staking.impl.domain.validations.setup.SetupStakingPayload import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess.ReadyToSubmit.Payload import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingSharedState import jp.co.soramitsu.staking.impl.presentation.common.rewardDestination.RewardDestinationModel import jp.co.soramitsu.staking.impl.presentation.common.validation.stakingValidationFailure import jp.co.soramitsu.staking.impl.scenarios.StakingScenarioInteractor import jp.co.soramitsu.staking.impl.scenarios.relaychain.HOURS_IN_DAY import jp.co.soramitsu.wallet.api.data.mappers.mapAssetToAssetModel import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeLoaderMixin import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.flow.emitAll import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.flow import kotlinx.coroutines.flow.flowOf import kotlinx.coroutines.flow.flowOn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.flow.transform import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:ConfirmUnbondFragment.kt$import android.os.Bundle import androidx.fragment.app.viewModels import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import dev.chrisbanes.insetter.applyInsetter import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.mixin.impl.observeValidations import jp.co.soramitsu.common.view.setProgress import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.account.api.presentation.actions.setupExternalActions import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.feature_staking_impl.databinding.FragmentConfirmUnbondBinding import javax.inject.Inject</ID>
    <ID>ImportOrdering:ConnectionPool.kt$import java.util.concurrent.ConcurrentHashMap import javax.inject.Inject import javax.inject.Provider import jp.co.soramitsu.common.compose.component.NetworkIssueItemState import jp.co.soramitsu.common.compose.component.NetworkIssueType import jp.co.soramitsu.common.mixin.api.NetworkStateMixin import jp.co.soramitsu.common.mixin.api.NetworkStateUi import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.core.runtime.ChainConnection import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.storage.NodesSettingsStorage import jp.co.soramitsu.shared_utils.wsrpc.SocketService import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.distinctUntilChanged import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.onEach</ID>
    <ID>ImportOrdering:ContributeValidationPayload.kt$import java.math.BigDecimal import jp.co.soramitsu.crowdloan.impl.domain.main.Crowdloan import jp.co.soramitsu.wallet.impl.domain.model.Asset</ID>
    <ID>ImportOrdering:ControllerInteractor.kt$import java.math.BigInteger import jp.co.soramitsu.common.utils.staking import jp.co.soramitsu.core.extrinsic.ExtrinsicService import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.runtime.ext.accountIdOf import jp.co.soramitsu.runtime.ext.multiAddressOf import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.state.SingleAssetSharedState import jp.co.soramitsu.shared_utils.ss58.SS58Encoder.toAccountId import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.api.data.SyntheticStakingType import jp.co.soramitsu.staking.api.data.syntheticStakingType import jp.co.soramitsu.staking.impl.data.network.blockhain.calls.setController import jp.co.soramitsu.staking.impl.data.network.blockhain.calls.setControllerSora import jp.co.soramitsu.staking.impl.domain.StakingInteractor import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.flow.first import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:CreateAccountViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.presentation.account.create.ChainAccountCreatePayload import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.common.BuildConfig import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.TextInputViewState import jp.co.soramitsu.common.utils.Event import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn</ID>
    <ID>ImportOrdering:CreateBackupPasswordViewModel.kt$import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.util.UUID import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.AccountInteractor import jp.co.soramitsu.account.api.presentation.create_backup_password.CreateBackupPasswordPayload import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.backup.BackupService import jp.co.soramitsu.backup.domain.models.DecryptedBackupAccount import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.TextInputViewState import jp.co.soramitsu.common.compose.component.TextSelectableItemState import jp.co.soramitsu.feature_account_impl.R import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch import jp.co.soramitsu.common.utils.combine as combineFlows</ID>
    <ID>ImportOrdering:CreateContactViewModel.kt$import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.SelectorState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.validation.AddressNotValidException import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.balance.chainselector.ChainItemState import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:CreatePoolSetupViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import java.math.BigInteger import javax.inject.Inject import jp.co.soramitsu.account.api.domain.model.address import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.AmountInputViewState import jp.co.soramitsu.common.compose.component.ButtonViewState import jp.co.soramitsu.common.compose.component.FeeInfoViewState import jp.co.soramitsu.common.compose.component.TextInputViewState import jp.co.soramitsu.common.navigation.payload.WalletSelectorPayload import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.applyFiatRate import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.isNotZero import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.validation.MinPoolCreationThresholdException import jp.co.soramitsu.common.validation.StakeInsufficientBalanceException import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.wallet.api.presentation.formatters.formatCryptoDetailFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:CrossChainConfirmViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.common.AlertViewState import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.base.errors.ValidationException import jp.co.soramitsu.common.base.errors.ValidationWarning import jp.co.soramitsu.common.compose.component.ButtonViewState import jp.co.soramitsu.common.compose.component.TitleValueViewState import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.combine import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatting.shortenAddress import jp.co.soramitsu.common.utils.requireException import jp.co.soramitsu.common.utils.requireValue import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import jp.co.soramitsu.wallet.api.domain.TransferValidationResult import jp.co.soramitsu.wallet.api.domain.ValidateTransferUseCase import jp.co.soramitsu.wallet.api.domain.fromValidationResult import jp.co.soramitsu.wallet.api.presentation.mixin.TransferValidityChecks import jp.co.soramitsu.wallet.impl.data.mappers.mapAssetToAssetModel import jp.co.soramitsu.wallet.impl.domain.CurrentAccountAddressUseCase import jp.co.soramitsu.wallet.impl.domain.XcmInteractor import jp.co.soramitsu.wallet.impl.domain.interfaces.NotValidTransferStatus import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.domain.model.CrossChainTransfer import jp.co.soramitsu.wallet.impl.domain.model.PhishingType import jp.co.soramitsu.wallet.impl.domain.model.TransferValidityLevel import jp.co.soramitsu.wallet.impl.domain.model.TransferValidityStatus import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.cross_chain.CrossChainTransferDraft import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.ExperimentalCoroutinesApi import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.firstOrNull import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:CrossChainSetupContent.kt$import android.graphics.drawable.Drawable import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.Column import androidx.compose.foundation.layout.Row import androidx.compose.foundation.layout.Spacer import androidx.compose.foundation.layout.defaultMinSize import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.foundation.layout.fillMaxWidth import androidx.compose.foundation.layout.height import androidx.compose.foundation.layout.padding import androidx.compose.foundation.layout.widthIn import androidx.compose.foundation.rememberScrollState import androidx.compose.foundation.verticalScroll import androidx.compose.runtime.Composable import androidx.compose.ui.Alignment import androidx.compose.ui.ExperimentalComposeUiApi import androidx.compose.ui.Modifier import androidx.compose.ui.platform.LocalSoftwareKeyboardController import androidx.compose.ui.res.stringResource import androidx.compose.ui.tooling.preview.Preview import androidx.compose.ui.unit.Dp import androidx.compose.ui.unit.dp import java.math.BigDecimal import jp.co.soramitsu.common.compose.component.AccentButton import jp.co.soramitsu.common.compose.component.AddressInput import jp.co.soramitsu.common.compose.component.AddressInputState import jp.co.soramitsu.common.compose.component.AmountInput import jp.co.soramitsu.common.compose.component.AmountInputViewState import jp.co.soramitsu.common.compose.component.Badge import jp.co.soramitsu.common.compose.component.BottomSheetScreen import jp.co.soramitsu.common.compose.component.ButtonViewState import jp.co.soramitsu.common.compose.component.FeeInfo import jp.co.soramitsu.common.compose.component.FeeInfoViewState import jp.co.soramitsu.common.compose.component.MarginHorizontal import jp.co.soramitsu.common.compose.component.MarginVertical import jp.co.soramitsu.common.compose.component.QuickAmountInput import jp.co.soramitsu.common.compose.component.QuickInput import jp.co.soramitsu.common.compose.component.SelectorState import jp.co.soramitsu.common.compose.component.SelectorWithBorder import jp.co.soramitsu.common.compose.component.ToolbarBottomSheet import jp.co.soramitsu.common.compose.component.ToolbarViewState import jp.co.soramitsu.common.compose.component.WarningInfo import jp.co.soramitsu.common.compose.component.WarningInfoState import jp.co.soramitsu.common.compose.theme.FearlessTheme import jp.co.soramitsu.common.compose.theme.colorAccentDark import jp.co.soramitsu.feature_wallet_impl.R</ID>
    <ID>ImportOrdering:CrossChainSetupViewModel.kt$import androidx.compose.ui.unit.Dp import androidx.compose.ui.unit.dp import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import java.math.BigInteger import java.math.RoundingMode import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.AccountInteractor import jp.co.soramitsu.account.api.domain.model.address import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.address.createAddressIcon import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.base.errors.ValidationException import jp.co.soramitsu.common.base.errors.ValidationWarning import jp.co.soramitsu.common.compose.component.AddressInputState import jp.co.soramitsu.common.compose.component.AmountInputViewState import jp.co.soramitsu.common.compose.component.ButtonViewState import jp.co.soramitsu.common.compose.component.FeeInfoViewState import jp.co.soramitsu.common.compose.component.SelectorState import jp.co.soramitsu.common.compose.component.ToolbarViewState import jp.co.soramitsu.common.compose.component.WarningInfoState import jp.co.soramitsu.common.resources.ClipboardManager import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.applyFiatRate import jp.co.soramitsu.common.utils.combine import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.isNotZero import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.utils.requireValue import jp.co.soramitsu.core.models.ChainId import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.wallet.api.domain.TransferValidationResult import jp.co.soramitsu.wallet.api.domain.ValidateTransferUseCase import jp.co.soramitsu.wallet.api.domain.fromValidationResult import jp.co.soramitsu.wallet.api.domain.model.XcmChainType import jp.co.soramitsu.wallet.impl.domain.CurrentAccountAddressUseCase import jp.co.soramitsu.wallet.impl.domain.XcmInteractor import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletConstants import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.PhishingType import jp.co.soramitsu.wallet.impl.domain.model.Transfer import jp.co.soramitsu.wallet.impl.domain.model.WalletAccount import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import jp.co.soramitsu.wallet.impl.presentation.AssetPayload import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.balance.walletselector.light.WalletSelectionMode import jp.co.soramitsu.wallet.impl.presentation.cross_chain.CrossChainTransferDraft import kotlinx.coroutines.ExperimentalCoroutinesApi import kotlinx.coroutines.FlowPreview import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableSharedFlow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.asSharedFlow import kotlinx.coroutines.flow.catch import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.filterNotNull import kotlinx.coroutines.flow.firstOrNull import kotlinx.coroutines.flow.flatMapConcat import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.flowOf import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:CrowdloanAdapter.kt$import android.view.View import android.view.ViewGroup import android.widget.ImageView import android.widget.LinearLayout import android.widget.TextView import coil.ImageLoader import coil.dispose import coil.load import jp.co.soramitsu.common.list.BaseGroupedDiffCallback import jp.co.soramitsu.common.list.GroupedListAdapter import jp.co.soramitsu.common.list.GroupedListHolder import jp.co.soramitsu.common.list.PayloadGenerator import jp.co.soramitsu.common.list.resolvePayload import jp.co.soramitsu.common.utils.inflateChild import jp.co.soramitsu.common.utils.makeGone import jp.co.soramitsu.common.utils.makeVisible import jp.co.soramitsu.common.utils.setTextColorRes import jp.co.soramitsu.common.utils.setVisible import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.crowdloan.api.data.network.blockhain.binding.ParaId import jp.co.soramitsu.crowdloan.impl.presentation.main.model.CrowdloanModel import jp.co.soramitsu.crowdloan.impl.presentation.main.model.CrowdloanStatusModel import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId</ID>
    <ID>ImportOrdering:CrowdloanContributeViewModel.kt$import androidx.lifecycle.MediatorLiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import java.math.RoundingMode import javax.inject.Inject import javax.inject.Named import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.mixin.api.Browserable import jp.co.soramitsu.common.mixin.api.Validatable import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.formatAsPercentage import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.fractionToPercentage import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.validation.ValidationExecutor import jp.co.soramitsu.common.validation.progressConsumer import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_CROWDLOAN_INFO_URL import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_TERMS_URL import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_TOTAL_REWARD import jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.CustomContributeManager import jp.co.soramitsu.crowdloan.impl.domain.contribute.CrowdloanContributeInteractor import jp.co.soramitsu.crowdloan.impl.domain.contribute.validations.ContributeValidationPayload import jp.co.soramitsu.crowdloan.impl.domain.contribute.validations.ContributeValidationSystem import jp.co.soramitsu.crowdloan.impl.domain.main.Crowdloan import jp.co.soramitsu.crowdloan.impl.presentation.CrowdloanRouter import jp.co.soramitsu.crowdloan.impl.presentation.contribute.additionalOnChainSubmission import jp.co.soramitsu.crowdloan.impl.presentation.contribute.confirm.parcel.ConfirmContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.contributeValidationFailure import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.ApplyActionState import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.BonusPayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.acala.AcalaBonusPayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.acala.AcalaContributionType import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.acala.AcalaContributionType.DirectDOT import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.acala.AcalaContributionType.LcDOT import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.astar.AstarBonusPayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.interlay.InterlayBonusPayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.model.CustomContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.model.CrowdloanDetailsModel import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.model.LearnMoreModel import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.ContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.getString import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.mapParachainMetadataFromParcel import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.wallet.api.data.mappers.mapAssetToAssetModel import jp.co.soramitsu.wallet.api.domain.AssetUseCase import jp.co.soramitsu.wallet.api.presentation.formatters.formatCryptoDetailFromPlanks import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeLoaderMixin import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlin.time.Duration.Companion.milliseconds import kotlinx.coroutines.FlowPreview import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.debounce import kotlinx.coroutines.flow.distinctUntilChanged import kotlinx.coroutines.flow.emitAll import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.firstOrNull import kotlinx.coroutines.flow.flow import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.flow.onStart import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:CrowdloanFragment.kt$import android.content.Intent import androidx.fragment.app.viewModels import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import dev.chrisbanes.insetter.applyInsetter import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.mixin.impl.observeBrowserEvents import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.utils.setVisible import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.crowdloan.api.data.network.blockhain.binding.ParaId import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.feature_crowdloan_impl.databinding.FragmentCrowdloansBinding import jp.co.soramitsu.wallet.api.presentation.mixin.assetSelector.setupAssetSelector import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import javax.inject.Inject</ID>
    <ID>ImportOrdering:CrowdloanReferralActionsSheet.kt$import android.content.Context import android.os.Bundle import jp.co.soramitsu.common.view.bottomSheet.list.fixed.FixedListBottomSheet import jp.co.soramitsu.common.view.bottomSheet.list.fixed.item import jp.co.soramitsu.account.api.presentation.actions.CopyCallback import jp.co.soramitsu.feature_crowdloan_impl.R</ID>
    <ID>ImportOrdering:CrowdloanUpdatersModule.kt$import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import javax.inject.Named import javax.inject.Singleton import jp.co.soramitsu.core.storage.StorageCache import jp.co.soramitsu.core.updater.UpdateSystem import jp.co.soramitsu.crowdloan.impl.data.CrowdloanSharedState import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.network.updaters.BlockNumberUpdater import jp.co.soramitsu.runtime.network.updaters.SingleChainUpdateSystem import kotlinx.coroutines.flow.map</ID>
    <ID>ImportOrdering:CrowdloanViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import javax.inject.Inject import javax.inject.Named import jp.co.soramitsu.account.api.domain.interfaces.SelectedAccountUseCase import jp.co.soramitsu.common.BuildConfig import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createAddressIcon import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.list.toListWithHeaders import jp.co.soramitsu.common.list.toValueList import jp.co.soramitsu.common.mixin.api.Browserable import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.presentation.mapLoading import jp.co.soramitsu.common.resources.ClipboardManager import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.resources.formatTimeLeft import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.withLoading import jp.co.soramitsu.core.updater.UpdateSystem import jp.co.soramitsu.crowdloan.api.data.network.blockhain.binding.ParaId import jp.co.soramitsu.crowdloan.impl.data.CrowdloanSharedState import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_API_KEY import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_API_URL import jp.co.soramitsu.crowdloan.impl.domain.main.Crowdloan import jp.co.soramitsu.crowdloan.impl.domain.main.CrowdloanInteractor import jp.co.soramitsu.crowdloan.impl.presentation.CrowdloanRouter import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.model.CustomContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.CONTRIBUTE import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.TERMS import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.ContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.getString import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.mapParachainMetadataToParcel import jp.co.soramitsu.crowdloan.impl.presentation.main.model.CrowdloanModel import jp.co.soramitsu.crowdloan.impl.presentation.main.model.CrowdloanStatusModel import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.runtime.ext.addressOf import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.state.chain import jp.co.soramitsu.runtime.state.selectedChainFlow import jp.co.soramitsu.shared_utils.extensions.toHexString import jp.co.soramitsu.shared_utils.hash.Hasher.blake2b256 import jp.co.soramitsu.wallet.api.domain.AssetUseCase import jp.co.soramitsu.wallet.api.presentation.formatters.formatCryptoDetailFromPlanks import jp.co.soramitsu.wallet.api.presentation.formatters.formatCryptoFromPlanks import jp.co.soramitsu.wallet.api.presentation.mixin.assetSelector.AssetSelectorMixin import jp.co.soramitsu.wallet.api.presentation.mixin.assetSelector.WithAssetSelector import jp.co.soramitsu.wallet.impl.domain.model.Asset import kotlin.reflect.KClass import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.firstOrNull import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:CryptoTypeChooser.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.liveData import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.mediatorLiveData import jp.co.soramitsu.common.utils.updateFrom import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListBottomSheet.Payload import jp.co.soramitsu.account.api.domain.interfaces.AccountInteractor import jp.co.soramitsu.account.impl.data.mappers.mapCryptoTypeToCryptoTypeModel import jp.co.soramitsu.account.impl.presentation.common.mixin.api.CryptoTypeChooserMixin import jp.co.soramitsu.account.impl.presentation.view.advanced.encryption.model.CryptoTypeModel</ID>
    <ID>ImportOrdering:CryptoTypeChooserMixin.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListBottomSheet.Payload import jp.co.soramitsu.account.impl.presentation.view.advanced.encryption.model.CryptoTypeModel</ID>
    <ID>ImportOrdering:CustomContributeFragment.kt$import android.graphics.Paint import android.os.Bundle import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import android.widget.TextView import androidx.activity.OnBackPressedCallback import androidx.fragment.app.viewModels import androidx.lifecycle.lifecycleScope import coil.ImageLoader import coil.load import dagger.hilt.android.AndroidEntryPoint import dev.chrisbanes.insetter.applyInsetter import javax.inject.Inject import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.mixin.impl.observeBrowserEvents import jp.co.soramitsu.common.mixin.impl.observeValidations import jp.co.soramitsu.common.presentation.ErrorDialog import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.common.utils.setVisible import jp.co.soramitsu.common.view.AmountView import jp.co.soramitsu.common.view.ButtonState import jp.co.soramitsu.common.view.GoNextView import jp.co.soramitsu.common.view.LabeledTextView import jp.co.soramitsu.common.view.TableCellView import jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.CustomContributeManager import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.model.CustomContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamContributeViewState import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.CONTRIBUTE import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.TERMS import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.TERMS_CONFIRM import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.TERMS_CONFIRM_SUCCESS import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.feature_crowdloan_impl.databinding.FragmentCustomContributeBinding import jp.co.soramitsu.wallet.api.presentation.view.FeeView import kotlinx.coroutines.flow.first</ID>
    <ID>ImportOrdering:CustomContributeViewModel.kt$import androidx.lifecycle.MediatorLiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import javax.inject.Inject import javax.inject.Named import jp.co.soramitsu.account.api.domain.interfaces.SelectedAccountUseCase import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.mixin.api.Browserable import jp.co.soramitsu.common.mixin.api.Validatable import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.formatAsPercentage import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.fractionToPercentage import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.map import jp.co.soramitsu.common.utils.switchMap import jp.co.soramitsu.common.validation.CompositeValidation import jp.co.soramitsu.common.validation.ValidationExecutor import jp.co.soramitsu.common.validation.progressConsumer import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_API_KEY import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_API_URL import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_BONUS_URL import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_CROWDLOAN_INFO_URL import jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.CustomContributeManager import jp.co.soramitsu.crowdloan.impl.domain.contribute.CrowdloanContributeInteractor import jp.co.soramitsu.crowdloan.impl.domain.contribute.validations.ContributeValidationPayload import jp.co.soramitsu.crowdloan.impl.domain.contribute.validations.ContributeValidationSystem import jp.co.soramitsu.crowdloan.impl.domain.contribute.validations.CrowdloanNotEndedValidation import jp.co.soramitsu.crowdloan.impl.domain.main.Crowdloan import jp.co.soramitsu.crowdloan.impl.presentation.CrowdloanRouter import jp.co.soramitsu.crowdloan.impl.presentation.contribute.additionalOnChainSubmission import jp.co.soramitsu.crowdloan.impl.presentation.contribute.confirm.parcel.ConfirmContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.contributeValidationFailure import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.model.CustomContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamContributeViewState import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.CONTRIBUTE import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.CONTRIBUTE_CONFIRM import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.TERMS import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.TERMS_CONFIRM import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.TERMS_CONFIRM_SUCCESS import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.model.CrowdloanDetailsModel import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.model.LearnMoreModel import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.getString import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.mapParachainMetadataFromParcel import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.wallet.api.data.mappers.mapAssetToAssetModel import jp.co.soramitsu.wallet.api.domain.AssetUseCase import jp.co.soramitsu.wallet.api.presentation.formatters.formatCryptoDetailFromPlanks import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeLoaderMixin import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeStatus import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import jp.co.soramitsu.wallet.impl.domain.validation.EnoughToPayFeesValidation import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.filterIsInstance import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.firstOrNull import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.mapLatest import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:DynamicPrecisionFormatter.kt$import java.lang.Integer.max import java.math.BigDecimal import jp.co.soramitsu.common.utils.decimalFormatterFor import jp.co.soramitsu.common.utils.patternWith</ID>
    <ID>ImportOrdering:EncryptionTypeChooserBottomSheetDialog.kt$import android.content.Context import android.os.Bundle import android.view.View import android.widget.ImageView import android.widget.TextView import androidx.recyclerview.widget.DiffUtil import jp.co.soramitsu.common.utils.inflateChild import jp.co.soramitsu.common.utils.makeInvisible import jp.co.soramitsu.common.utils.makeVisible import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.ClickHandler import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListBottomSheet import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListSheetAdapter import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.HolderCreator import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.account.impl.presentation.view.advanced.encryption.model.CryptoTypeModel</ID>
    <ID>ImportOrdering:EncryptionUtil.kt$import android.content.Context import android.os.Build import android.security.KeyPairGeneratorSpec import android.security.keystore.KeyGenParameterSpec import android.security.keystore.KeyProperties import java.math.BigInteger import java.security.InvalidAlgorithmParameterException import java.security.InvalidKeyException import java.security.Key import java.security.KeyPairGenerator import java.security.KeyStore import java.security.NoSuchAlgorithmException import java.security.PrivateKey import java.security.PublicKey import java.security.SecureRandom import java.security.spec.AlgorithmParameterSpec import java.util.Calendar import javax.crypto.BadPaddingException import javax.crypto.Cipher import javax.crypto.IllegalBlockSizeException import javax.crypto.KeyGenerator import javax.crypto.NoSuchPaddingException import javax.crypto.SecretKey import javax.crypto.spec.IvParameterSpec import javax.crypto.spec.SecretKeySpec import javax.inject.Inject import javax.security.auth.x500.X500Principal import org.bouncycastle.util.Arrays import org.bouncycastle.util.encoders.Base64</ID>
    <ID>ImportOrdering:EraCalculatorFactory.kt$import java.math.BigInteger import jp.co.soramitsu.staking.api.domain.model.EraIndex import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioRepository import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId</ID>
    <ID>ImportOrdering:ExampleInstrumentedTest.kt$import androidx.test.platform.app.InstrumentationRegistry import androidx.test.ext.junit.runners.AndroidJUnit4 import org.junit.Test import org.junit.runner.RunWith import org.junit.Assert.*</ID>
    <ID>ImportOrdering:ExampleUnitTest.kt$import org.junit.Test import org.junit.Assert.*</ID>
    <ID>ImportOrdering:ExistentialDepositUseCaseImpl.kt$import android.util.Log import java.math.BigInteger import jp.co.soramitsu.common.data.network.runtime.binding.bindNumber import jp.co.soramitsu.common.data.network.runtime.binding.getTyped import jp.co.soramitsu.common.utils.Modules import jp.co.soramitsu.common.utils.balances import jp.co.soramitsu.common.utils.numberConstant import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.core.models.ChainAssetType import jp.co.soramitsu.core.models.ChainId import jp.co.soramitsu.core.rpc.RpcCalls import jp.co.soramitsu.core.rpc.calls.getExistentialDeposit import jp.co.soramitsu.core.runtime.storage.incompatible import jp.co.soramitsu.core.runtime.storage.returnType import jp.co.soramitsu.core.utils.orZero import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.storage.source.StorageDataSource import jp.co.soramitsu.shared_utils.runtime.definitions.types.composite.Struct import jp.co.soramitsu.shared_utils.runtime.definitions.types.fromHexOrNull import jp.co.soramitsu.shared_utils.runtime.metadata.module import jp.co.soramitsu.shared_utils.runtime.metadata.storage import jp.co.soramitsu.shared_utils.runtime.metadata.storageKey import jp.co.soramitsu.wallet.api.domain.ExistentialDepositUseCase</ID>
    <ID>ImportOrdering:ExperimentalViewModel.kt$import androidx.annotation.DrawableRes import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.impl.domain.BeaconConnectedUseCase import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.base.ViewState import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.sendEvent import jp.co.soramitsu.feature_account_impl.R</ID>
    <ID>ImportOrdering:ExportJsonConfirmFragment.kt$import android.app.Activity import android.content.Intent import android.os.Bundle import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import androidx.core.content.FileProvider import androidx.core.os.bundleOf import androidx.core.view.isVisible import androidx.fragment.app.viewModels import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import jp.co.soramitsu.feature_account_impl.databinding.FragmentExportJsonConfirmBinding import jp.co.soramitsu.account.impl.presentation.exporting.ExportFragment import jp.co.soramitsu.account.impl.presentation.view.advanced.AdvancedBlockView.FieldState import java.io.File import javax.inject.Inject</ID>
    <ID>ImportOrdering:ExportJsonPasswordFragment.kt$import android.os.Bundle import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import androidx.core.os.bundleOf import androidx.core.view.isVisible import androidx.fragment.app.viewModels import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import jp.co.soramitsu.common.utils.hideKeyboard import jp.co.soramitsu.common.utils.setDrawableStart import jp.co.soramitsu.common.utils.setVisible import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.feature_account_impl.databinding.FragmentExportJsonPasswordBinding import jp.co.soramitsu.account.impl.presentation.exporting.ExportFragment import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import javax.inject.Inject</ID>
    <ID>ImportOrdering:ExportMnemonicFragment.kt$import android.os.Bundle import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import androidx.core.os.bundleOf import androidx.core.view.isVisible import androidx.fragment.app.viewModels import dagger.hilt.android.AndroidEntryPoint import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.feature_account_impl.databinding.FragmentExportMnemonicBinding import jp.co.soramitsu.account.impl.presentation.exporting.ExportFragment import jp.co.soramitsu.account.impl.presentation.view.advanced.AdvancedBlockView.FieldState import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId</ID>
    <ID>ImportOrdering:ExportSeedFragment.kt$import android.os.Bundle import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import androidx.core.os.bundleOf import androidx.core.view.isGone import androidx.core.view.isVisible import androidx.fragment.app.viewModels import dagger.hilt.android.AndroidEntryPoint import jp.co.soramitsu.common.utils.ComponentHolder import jp.co.soramitsu.common.utils.mediateWith import jp.co.soramitsu.core.BuildConfig import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.feature_account_impl.databinding.FragmentExportSeedBinding import jp.co.soramitsu.account.impl.presentation.exporting.ExportFragment import jp.co.soramitsu.account.impl.presentation.view.advanced.AdvancedBlockView.FieldState import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId</ID>
    <ID>ImportOrdering:ExportSource.kt$import androidx.annotation.DrawableRes import androidx.annotation.StringRes import jp.co.soramitsu.feature_account_api.R import jp.co.soramitsu.account.api.presentation.accountSource.AccountSource</ID>
    <ID>ImportOrdering:Ext.kt$import android.app.Activity import android.content.Context import android.content.Intent import android.net.Uri import android.view.View import android.widget.Toast import androidx.annotation.ColorInt import androidx.fragment.app.Fragment import androidx.lifecycle.MutableLiveData import java.net.URLEncoder import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Job import kotlinx.coroutines.SupervisorJob import kotlinx.coroutines.flow.Flow</ID>
    <ID>ImportOrdering:Extensions.kt$import android.annotation.SuppressLint import android.os.CountDownTimer import android.widget.CompoundButton import android.widget.TextView import androidx.lifecycle.Lifecycle import androidx.lifecycle.LifecycleCoroutineScope import androidx.lifecycle.LifecycleEventObserver import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import jp.co.soramitsu.common.R import jp.co.soramitsu.common.utils.bindTo import kotlin.time.DurationUnit import kotlin.time.toDuration import kotlinx.coroutines.flow.MutableStateFlow</ID>
    <ID>ImportOrdering:ExtrinsicDetailFragment.kt$import androidx.annotation.StringRes import androidx.core.os.bundleOf import androidx.fragment.app.viewModels import dagger.hilt.android.AndroidEntryPoint import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.utils.formatDateTime import jp.co.soramitsu.common.utils.showBrowser import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.account.api.presentation.actions.ExternalActionsSheet import jp.co.soramitsu.account.api.presentation.actions.ExternalViewCallback import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.feature_wallet_impl.databinding.FragmentExtrinsicDetailsBinding import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain</ID>
    <ID>ImportOrdering:ExtrinsicDetailViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.liveData import dagger.hilt.android.lifecycle.HiltViewModel import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.mixin.api.Browserable import jp.co.soramitsu.common.resources.ClipboardManager import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.account.api.presentation.account.AddressDisplayUseCase import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.transaction.detail.extrinsic.ExtrinsicDetailFragment.Companion.PAYLOAD_KEY import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import kotlinx.coroutines.flow.flow import javax.inject.Inject</ID>
    <ID>ImportOrdering:ExtrinsicDetailsPayload.kt$import android.os.Parcelable import jp.co.soramitsu.wallet.impl.presentation.model.OperationParcelizeModel import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import kotlinx.parcelize.Parcelize</ID>
    <ID>ImportOrdering:FeeLoaderMixin.kt$import androidx.lifecycle.LiveData import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.mixin.api.Retriable import jp.co.soramitsu.wallet.impl.domain.model.Token import jp.co.soramitsu.wallet.api.presentation.model.FeeModel import kotlinx.coroutines.CoroutineScope import java.math.BigDecimal import java.math.BigInteger</ID>
    <ID>ImportOrdering:FeeLoaderProvider.kt$import androidx.lifecycle.MutableLiveData import java.math.BigDecimal import java.math.BigInteger import jp.co.soramitsu.common.mixin.api.RetryPayload import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.feature_wallet_api.R import jp.co.soramitsu.wallet.api.data.mappers.mapFeeToFeeModel import jp.co.soramitsu.wallet.impl.domain.TokenUseCase import jp.co.soramitsu.wallet.impl.domain.model.Token import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.CancellationException import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.launch import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:Filters.kt$import java.math.BigInteger import jp.co.soramitsu.staking.api.domain.model.CandidateCapacity import jp.co.soramitsu.staking.api.domain.model.Collator import jp.co.soramitsu.staking.api.domain.model.Validator import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.impl.presentation.validators.change.custom.settings.SettingsSchema</ID>
    <ID>ImportOrdering:Formatters.kt$import java.math.BigInteger import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.core.utils.amountFromPlanks import jp.co.soramitsu.core.models.Asset as CoreAsset</ID>
    <ID>ImportOrdering:GetSoraCardScreen.kt$import androidx.compose.foundation.Image import androidx.compose.foundation.ScrollState import androidx.compose.foundation.background import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.Column import androidx.compose.foundation.layout.Row import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.foundation.layout.fillMaxWidth import androidx.compose.foundation.layout.height import androidx.compose.foundation.layout.padding import androidx.compose.foundation.layout.wrapContentHeight import androidx.compose.foundation.rememberScrollState import androidx.compose.foundation.shape.RoundedCornerShape import androidx.compose.foundation.verticalScroll import androidx.compose.material.Icon import androidx.compose.material.MaterialTheme import androidx.compose.material.Text import androidx.compose.runtime.Composable import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.draw.shadow import androidx.compose.ui.graphics.Color import androidx.compose.ui.layout.ContentScale import androidx.compose.ui.platform.testTag import androidx.compose.ui.res.painterResource import androidx.compose.ui.res.stringResource import androidx.compose.ui.text.AnnotatedString import androidx.compose.ui.text.SpanStyle import androidx.compose.ui.text.font.FontWeight import androidx.compose.ui.text.style.TextAlign import androidx.compose.ui.tooling.preview.Preview import androidx.compose.ui.unit.Dp import androidx.compose.ui.unit.dp import androidx.compose.ui.unit.sp import java.lang.Integer.max import java.math.BigDecimal import jp.co.soramitsu.common.compose.component.AccentButton import jp.co.soramitsu.common.compose.component.MarginHorizontal import jp.co.soramitsu.common.compose.component.MarginVertical import jp.co.soramitsu.common.compose.component.Toolbar import jp.co.soramitsu.common.compose.component.ToolbarViewState import jp.co.soramitsu.common.compose.component.TransparentButton import jp.co.soramitsu.common.compose.theme.FearlessAppTheme import jp.co.soramitsu.common.compose.theme.errorRed import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.feature_soracard_impl.R import jp.co.soramitsu.soracard.api.presentation.models.SoraCardInfo import jp.co.soramitsu.ui_core.component.text.HtmlText import jp.co.soramitsu.ui_core.resources.Dimens import jp.co.soramitsu.ui_core.theme.borderRadius import jp.co.soramitsu.ui_core.theme.customColors import jp.co.soramitsu.ui_core.theme.customTypography import jp.co.soramitsu.ui_core.theme.elevation import jp.co.soramitsu.oauth.R as SoraCardR</ID>
    <ID>ImportOrdering:IdentityRepository.kt$import jp.co.soramitsu.staking.api.domain.model.Identity import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain</ID>
    <ID>ImportOrdering:ImportAccountFragment.kt$import android.content.Intent import android.os.Bundle import android.text.method.DigitsKeyListener import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import androidx.core.os.bundleOf import androidx.fragment.app.viewModels import dagger.hilt.android.AndroidEntryPoint import jp.co.soramitsu.account.api.presentation.account.create.ChainAccountCreatePayload import jp.co.soramitsu.account.api.presentation.accountSource.SourceTypeChooserBottomSheetDialog import jp.co.soramitsu.account.api.presentation.importing.ImportAccountType import jp.co.soramitsu.account.impl.presentation.importing.source.model.FileRequester import jp.co.soramitsu.account.api.domain.model.ImportMode import jp.co.soramitsu.account.impl.presentation.importing.source.model.ImportSource import jp.co.soramitsu.account.impl.presentation.importing.source.model.JsonImportSource import jp.co.soramitsu.account.impl.presentation.importing.source.model.MnemonicImportSource import jp.co.soramitsu.account.impl.presentation.importing.source.model.RawSeedImportSource import jp.co.soramitsu.account.impl.presentation.importing.source.model.RequestCode import jp.co.soramitsu.account.impl.presentation.importing.source.view.ImportSourceView import jp.co.soramitsu.account.impl.presentation.importing.source.view.JsonImportView import jp.co.soramitsu.account.impl.presentation.importing.source.view.MnemonicImportView import jp.co.soramitsu.account.impl.presentation.importing.source.view.SeedImportView import jp.co.soramitsu.account.impl.presentation.mnemonic.backup.EthereumDerivationPathTransformer import jp.co.soramitsu.account.impl.presentation.view.advanced.AdvancedBlockView.FieldState import jp.co.soramitsu.account.impl.presentation.view.advanced.encryption.EncryptionTypeChooserBottomSheetDialog import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.presentation.ErrorDialog import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.common.utils.makeGone import jp.co.soramitsu.common.utils.makeVisible import jp.co.soramitsu.common.utils.mediateWith import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListBottomSheet.Payload import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.feature_account_impl.databinding.FragmentImportAccountBinding</ID>
    <ID>ImportOrdering:ImportAccountModule.kt$import android.content.Context import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import javax.inject.Singleton import jp.co.soramitsu.account.impl.presentation.importing.FileReader import jp.co.soramitsu.backup.BackupService import jp.co.soramitsu.common.BuildConfig import jp.co.soramitsu.common.di.viewmodel.ViewModelModule</ID>
    <ID>ImportOrdering:ImportRemoteWalletContent.kt$import android.app.Activity import androidx.compose.runtime.Composable import jp.co.soramitsu.account.impl.presentation.importing.remote_backup.screens.EnterBackupPasswordCallback import jp.co.soramitsu.account.impl.presentation.importing.remote_backup.screens.EnterBackupPasswordScreen import jp.co.soramitsu.account.impl.presentation.importing.remote_backup.screens.EnterBackupPasswordState import jp.co.soramitsu.account.impl.presentation.importing.remote_backup.screens.RemoteWalletListScreen import jp.co.soramitsu.account.impl.presentation.importing.remote_backup.screens.RemoteWalletListCallback import jp.co.soramitsu.account.impl.presentation.importing.remote_backup.screens.RemoteWalletListState import jp.co.soramitsu.account.impl.presentation.importing.remote_backup.screens.WalletImportedCallback import jp.co.soramitsu.account.impl.presentation.importing.remote_backup.screens.WalletImportedScreen import jp.co.soramitsu.account.impl.presentation.importing.remote_backup.screens.WalletImportedState import jp.co.soramitsu.common.compose.component.BottomSheetScreen</ID>
    <ID>ImportOrdering:ImportRemoteWalletViewModel.kt$import android.app.Activity import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.AccountInteractor import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.account.impl.presentation.importing.remote_backup.screens.EnterBackupPasswordState import jp.co.soramitsu.account.impl.presentation.importing.remote_backup.screens.RemoteWalletListState import jp.co.soramitsu.account.impl.presentation.importing.remote_backup.screens.WalletImportedState import jp.co.soramitsu.backup.BackupService import jp.co.soramitsu.backup.domain.models.BackupAccountMeta import jp.co.soramitsu.backup.domain.models.DecryptedBackupAccount import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.TextInputViewState import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:ImportSourceView.kt$import android.content.Context import android.util.AttributeSet import android.view.View import androidx.annotation.LayoutRes import androidx.constraintlayout.widget.ConstraintLayout import androidx.lifecycle.LifecycleOwner import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.common.view.InputField import jp.co.soramitsu.account.impl.presentation.importing.ImportAccountViewModel import jp.co.soramitsu.account.impl.presentation.importing.source.model.ImportSource</ID>
    <ID>ImportOrdering:InputWithHint.kt$import androidx.compose.foundation.background import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.Row import androidx.compose.foundation.layout.fillMaxWidth import androidx.compose.foundation.text.BasicTextField import androidx.compose.foundation.text.KeyboardOptions import androidx.compose.material.MaterialTheme import androidx.compose.runtime.Composable import androidx.compose.runtime.getValue import androidx.compose.runtime.mutableStateOf import androidx.compose.runtime.remember import androidx.compose.runtime.setValue import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.focus.onFocusChanged import androidx.compose.ui.graphics.Brush import androidx.compose.ui.graphics.Color import androidx.compose.ui.graphics.SolidColor import androidx.compose.ui.text.input.ImeAction import androidx.compose.ui.text.input.KeyboardType import androidx.compose.ui.text.style.TextAlign import androidx.compose.ui.tooling.preview.Preview import androidx.compose.ui.unit.dp import jp.co.soramitsu.common.utils.formatting.shortenAddress import jp.co.soramitsu.common.compose.theme.colorAccentDark import jp.co.soramitsu.common.compose.theme.customTypography import jp.co.soramitsu.common.compose.theme.white import jp.co.soramitsu.common.utils.withNoFontPadding</ID>
    <ID>ImportOrdering:InterlayBonusPayload.kt$import java.math.BigDecimal import jp.co.soramitsu.crowdloan.api.data.network.blockhain.binding.ParaId import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.referral.ReferralCodePayload import kotlinx.parcelize.Parcelize</ID>
    <ID>ImportOrdering:InterlayContributeView.kt$import android.content.Context import android.util.AttributeSet import androidx.lifecycle.LifecycleCoroutineScope import jp.co.soramitsu.common.utils.observe import jp.co.soramitsu.common.utils.setVisible import jp.co.soramitsu.common.view.TableCellView import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeViewState import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.referral.ReferralContributeView</ID>
    <ID>ImportOrdering:IsWaiting.kt$import java.math.BigInteger import jp.co.soramitsu.staking.api.domain.model.Nominations</ID>
    <ID>ImportOrdering:JsonImportView.kt$import android.content.Context import android.util.AttributeSet import androidx.core.view.isVisible import androidx.lifecycle.LifecycleOwner import androidx.lifecycle.Observer import jp.co.soramitsu.common.utils.EventObserver import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.common.utils.nameInputFilters import jp.co.soramitsu.common.view.InputField import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.feature_account_impl.databinding.ImportSourceJsonBinding import jp.co.soramitsu.account.api.presentation.importing.ImportAccountType import jp.co.soramitsu.account.impl.presentation.importing.source.model.ImportSource import jp.co.soramitsu.account.impl.presentation.importing.source.model.JsonImportSource</ID>
    <ID>ImportOrdering:KaruraContributeInteractor.kt$import java.math.BigDecimal import jp.co.soramitsu.common.base.BaseException import jp.co.soramitsu.common.data.network.HttpExceptionHandler import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.crowdloan.impl.data.network.api.karura.KaruraApi import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId</ID>
    <ID>ImportOrdering:KaruraContributeSubmitter.kt$import java.math.BigDecimal import jp.co.soramitsu.crowdloan.impl.domain.contribute.custom.karura.KaruraContributeInteractor import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.BonusPayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeSubmitter import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.ParachainMetadataParcelModel</ID>
    <ID>ImportOrdering:KaruraContributeViewState.kt$import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.crowdloan.impl.domain.contribute.custom.karura.KaruraContributeInteractor import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.model.CustomContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.referral.ReferralCodePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.referral.ReferralContributeViewState</ID>
    <ID>ImportOrdering:KaruraContributionModule.kt$import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import dagger.multibindings.IntoSet import jp.co.soramitsu.common.data.network.HttpExceptionHandler import jp.co.soramitsu.common.data.network.NetworkApiCreator import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.crowdloan.impl.data.network.api.karura.KaruraApi import jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.CustomContributeFactory import jp.co.soramitsu.crowdloan.impl.domain.contribute.custom.karura.KaruraContributeInteractor import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.karura.KaruraContributeSubmitter</ID>
    <ID>ImportOrdering:LabeledTextView.kt$import android.content.Context import android.graphics.drawable.Drawable import android.graphics.drawable.PictureDrawable import android.util.AttributeSet import android.view.View import androidx.annotation.DrawableRes import androidx.annotation.StringRes import androidx.constraintlayout.widget.ConstraintLayout import coil.ImageLoader import coil.load import jp.co.soramitsu.common.R import jp.co.soramitsu.common.databinding.ViewLabeledTextBinding import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.utils.getDrawableCompat import jp.co.soramitsu.common.utils.makeVisible import jp.co.soramitsu.common.utils.setVisible import jp.co.soramitsu.common.view.shape.addRipple import jp.co.soramitsu.common.view.shape.getCutCornersStateDrawable</ID>
    <ID>ImportOrdering:LanguagesAdapter.kt$import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import android.widget.ImageView import android.widget.TextView import androidx.recyclerview.widget.DiffUtil import androidx.recyclerview.widget.ListAdapter import androidx.recyclerview.widget.RecyclerView import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.account.impl.presentation.language.model.LanguageModel</ID>
    <ID>ImportOrdering:LanguagesFragment.kt$import android.os.Bundle import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import androidx.fragment.app.viewModels import dagger.hilt.android.AndroidEntryPoint import jp.co.soramitsu.common.base.BaseActivity import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.feature_account_impl.databinding.FragmentLanguagesBinding import jp.co.soramitsu.account.impl.presentation.language.model.LanguageModel</ID>
    <ID>ImportOrdering:LanguagesViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.liveData import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.core.model.Language import jp.co.soramitsu.account.api.domain.interfaces.AccountInteractor import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.account.impl.presentation.language.mapper.mapLanguageToLanguageModel import jp.co.soramitsu.account.impl.presentation.language.model.LanguageModel import kotlinx.coroutines.launch import javax.inject.Inject</ID>
    <ID>ImportOrdering:MakePayoutValidationsModule.kt$import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import jp.co.soramitsu.common.validation.CompositeValidation import jp.co.soramitsu.common.validation.ValidationSystem import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.impl.domain.validations.payout.PayoutFeeValidation import jp.co.soramitsu.staking.impl.domain.validations.payout.PayoutValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.payout.ProfitablePayoutValidation import jp.co.soramitsu.staking.impl.domain.validations.setup.SetupStakingFeeValidation import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletRepository import jp.co.soramitsu.wallet.impl.domain.validation.EnoughToPayFeesValidation import jp.co.soramitsu.wallet.impl.domain.validation.assetBalanceProducer import javax.inject.Singleton</ID>
    <ID>ImportOrdering:ManagePoolStakeViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigInteger import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.NotificationState import jp.co.soramitsu.common.compose.component.TitleValueViewState import jp.co.soramitsu.common.compose.theme.colorAccent import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.applyFiatRate import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.api.domain.model.NominationPoolState import jp.co.soramitsu.staking.api.domain.model.getUserRole import jp.co.soramitsu.staking.api.domain.model.toPoolInfo import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SelectValidatorFlowState import jp.co.soramitsu.staking.impl.presentation.common.SelectedValidatorsFlowState import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolManageFlowState import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.presentation.staking.balance.compose.ManagePoolStakeScreenInterface import jp.co.soramitsu.staking.impl.presentation.staking.balance.compose.ManagePoolStakeViewState import jp.co.soramitsu.staking.impl.presentation.staking.balance.compose.PoolStakeManagementOptions import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.staking.impl.scenarios.relaychain.HOURS_IN_DAY import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioInteractor import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.filterNotNull import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:ManualRewardCalculator.kt$import java.math.BigDecimal import java.math.BigInteger import jp.co.soramitsu.common.utils.fractionToPercentage import jp.co.soramitsu.common.utils.median import jp.co.soramitsu.common.utils.sumByBigInteger import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.shared_utils.extensions.toHexString import kotlin.math.pow import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:MapAssetToAssetModel.kt$import androidx.annotation.StringRes import java.math.BigDecimal import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.feature_wallet_api.R import jp.co.soramitsu.wallet.api.presentation.model.AssetModel import jp.co.soramitsu.wallet.impl.domain.model.Asset</ID>
    <ID>ImportOrdering:MapFeeToFeeModel.kt$import java.math.BigDecimal import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.wallet.api.presentation.model.FeeModel import jp.co.soramitsu.wallet.impl.domain.model.Token</ID>
    <ID>ImportOrdering:MapFundInfoToCrowdloan.kt$import java.math.BigInteger import java.math.MathContext import jp.co.soramitsu.common.data.network.runtime.binding.BlockNumber import jp.co.soramitsu.crowdloan.api.data.network.blockhain.binding.Contribution import jp.co.soramitsu.crowdloan.api.data.network.blockhain.binding.FundInfo import jp.co.soramitsu.crowdloan.api.data.repository.ParachainMetadata import jp.co.soramitsu.crowdloan.impl.domain.common.leaseIndexFromBlock import jp.co.soramitsu.crowdloan.impl.domain.main.Crowdloan</ID>
    <ID>ImportOrdering:MnemonicImportView.kt$import android.content.Context import android.util.AttributeSet import androidx.core.view.isVisible import androidx.lifecycle.LifecycleOwner import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.common.utils.nameInputFilters import jp.co.soramitsu.common.view.InputField import jp.co.soramitsu.common.view.shape.getIdleDrawable import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.feature_account_impl.databinding.ImportSourceMnemonicBinding import jp.co.soramitsu.account.impl.presentation.importing.source.model.ImportSource import jp.co.soramitsu.account.impl.presentation.importing.source.model.MnemonicImportSource</ID>
    <ID>ImportOrdering:MoonbeamBonusPayload.kt$import java.math.BigDecimal import jp.co.soramitsu.crowdloan.api.data.network.blockhain.binding.ParaId import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.referral.ReferralCodePayload import kotlinx.parcelize.Parcelize</ID>
    <ID>ImportOrdering:MoonbeamContributeFactory.kt$import android.content.Context import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.account.api.domain.interfaces.SelectedAccountUseCase import jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.CustomContributeFactory import jp.co.soramitsu.crowdloan.impl.domain.contribute.custom.moonbeam.MoonbeamContributeInteractor import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeView import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.model.CustomContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamContributeSubmitter import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamContributeViewState import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.CONTRIBUTE import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.TERMS import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.TERMS_CONFIRM import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.TERMS_CONFIRM_SUCCESS import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamStep1Terms import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamStep2Registration import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamStep3Signed import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamStep4Contribute import kotlinx.coroutines.CoroutineScope</ID>
    <ID>ImportOrdering:MoonbeamContributeViewState.kt$import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.asLiveData import jp.co.soramitsu.account.api.domain.interfaces.SelectedAccountUseCase import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_API_KEY import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_API_URL import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_BONUS_RATE import jp.co.soramitsu.crowdloan.impl.data.network.api.parachain.FLOW_TERMS_URL import jp.co.soramitsu.crowdloan.impl.domain.contribute.custom.moonbeam.MoonbeamContributeInteractor import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.ApplyActionState import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.BonusPayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeViewState import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.model.CustomContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.CONTRIBUTE import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.moonbeam.MoonbeamCrowdloanStep.TERMS import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.referral.ReferralCodePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.getAsBigDecimal import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.getString import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.flow import kotlinx.coroutines.flow.map import java.math.BigInteger import java.util.regex.Pattern</ID>
    <ID>ImportOrdering:MoonbeamStep1Terms.kt$import android.content.Context import android.util.AttributeSet import androidx.lifecycle.LifecycleCoroutineScope import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.feature_crowdloan_impl.databinding.ViewMoonbeamStep1Binding import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeView import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeViewState import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:MoonbeamStep2Registration.kt$import android.content.Context import android.util.AttributeSet import androidx.lifecycle.LifecycleCoroutineScope import jp.co.soramitsu.common.utils.createSpannable import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.feature_crowdloan_impl.databinding.ViewMoonbeamStep2Binding import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeView import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeViewState</ID>
    <ID>ImportOrdering:MoonbeamStep3Signed.kt$import android.content.Context import android.util.AttributeSet import androidx.lifecycle.LifecycleCoroutineScope import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.feature_crowdloan_impl.databinding.ViewMoonbeamStep3Binding import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeView import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeViewState</ID>
    <ID>ImportOrdering:MoonbeamStep4Contribute.kt$import android.content.Context import android.text.InputFilter import android.text.InputFilter.LengthFilter import android.util.AttributeSet import androidx.lifecycle.LifecycleCoroutineScope import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.feature_crowdloan_impl.databinding.ViewMoonbeamStep4Binding import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeView import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeViewState</ID>
    <ID>ImportOrdering:NavigationModule.kt$import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import javax.inject.Singleton import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.app.root.navigation.Navigator import jp.co.soramitsu.crowdloan.impl.presentation.CrowdloanRouter import jp.co.soramitsu.onboarding.impl.OnboardingRouter import jp.co.soramitsu.polkaswap.api.presentation.PolkaswapRouter import jp.co.soramitsu.soracard.api.presentation.SoraCardRouter import jp.co.soramitsu.splash.SplashRouter import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.success.presentation.SuccessRouter import jp.co.soramitsu.wallet.impl.presentation.WalletRouter</ID>
    <ID>ImportOrdering:Navigator.kt$import android.graphics.drawable.Drawable import android.os.Bundle import androidx.annotation.IdRes import androidx.appcompat.app.AppCompatActivity import androidx.core.net.toUri import androidx.lifecycle.Lifecycle import androidx.lifecycle.asFlow import androidx.navigation.NavBackStackEntry import androidx.navigation.NavController import androidx.navigation.NavDeepLinkRequest import androidx.navigation.NavOptions import it.airgap.beaconsdk.blockchain.substrate.data.SubstrateSignerPayload import jp.co.soramitsu.account.api.domain.model.ImportMode import jp.co.soramitsu.account.api.presentation.account.create.ChainAccountCreatePayload import jp.co.soramitsu.account.api.presentation.actions.AddAccountBottomSheet import jp.co.soramitsu.account.impl.domain.account.details.AccountInChain import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.account.impl.presentation.account.details.AccountDetailsFragment import jp.co.soramitsu.account.impl.presentation.account.export.WalletExportFragment import jp.co.soramitsu.account.impl.presentation.account.exportaccounts.AccountsForExportFragment import jp.co.soramitsu.account.impl.presentation.create_backup_password.CreateBackupPasswordDialog import jp.co.soramitsu.account.api.presentation.create_backup_password.CreateBackupPasswordPayload import jp.co.soramitsu.account.impl.presentation.account.create.CreateAccountDialog import jp.co.soramitsu.account.impl.presentation.backup_wallet.BackupWalletDialog import jp.co.soramitsu.account.impl.presentation.experimental.SuccessfulFragment import jp.co.soramitsu.account.impl.presentation.exporting.json.confirm.ExportJsonConfirmFragment import jp.co.soramitsu.account.impl.presentation.exporting.json.confirm.ExportJsonConfirmPayload import jp.co.soramitsu.account.impl.presentation.exporting.json.password.ExportJsonPasswordFragment import jp.co.soramitsu.account.impl.presentation.exporting.mnemonic.ExportMnemonicFragment import jp.co.soramitsu.account.impl.presentation.exporting.seed.ExportSeedFragment import jp.co.soramitsu.account.impl.presentation.importing.ImportAccountFragment import jp.co.soramitsu.account.impl.presentation.importing.remote_backup.ImportRemoteWalletDialog import jp.co.soramitsu.account.impl.presentation.mnemonic.backup.BackupMnemonicDialog import jp.co.soramitsu.account.impl.presentation.mnemonic.backup.BackupMnemonicFragment import jp.co.soramitsu.account.impl.presentation.mnemonic.confirm.ConfirmMnemonicFragment import jp.co.soramitsu.account.impl.presentation.mnemonic.confirm.ConfirmMnemonicPayload import jp.co.soramitsu.account.impl.presentation.mnemonic_agreements.MnemonicAgreementsDialog import jp.co.soramitsu.account.impl.presentation.node.add.AddNodeFragment import jp.co.soramitsu.account.impl.presentation.node.details.NodeDetailsFragment import jp.co.soramitsu.account.impl.presentation.node.details.NodeDetailsPayload import jp.co.soramitsu.account.impl.presentation.node.list.NodesFragment import jp.co.soramitsu.account.impl.presentation.optionsaddaccount.OptionsAddAccountFragment import jp.co.soramitsu.account.impl.presentation.pincode.PinCodeAction import jp.co.soramitsu.account.impl.presentation.pincode.PincodeFragment import jp.co.soramitsu.account.impl.presentation.pincode.ToolbarConfiguration import jp.co.soramitsu.app.R import jp.co.soramitsu.app.root.presentation.AlertFragment import jp.co.soramitsu.app.root.presentation.RootRouter import jp.co.soramitsu.app.root.presentation.WebViewerFragment import jp.co.soramitsu.app.root.presentation.emptyResultKey import jp.co.soramitsu.app.root.presentation.stories.StoryFragment import jp.co.soramitsu.common.AlertViewState import jp.co.soramitsu.common.navigation.DelayedNavigation import jp.co.soramitsu.common.navigation.payload.WalletSelectorPayload import jp.co.soramitsu.common.presentation.StoryGroupModel import jp.co.soramitsu.common.utils.postToUiThread import jp.co.soramitsu.common.view.onResumeObserver import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.crowdloan.impl.presentation.CrowdloanRouter import jp.co.soramitsu.crowdloan.impl.presentation.contribute.confirm.ConfirmContributeFragment import jp.co.soramitsu.crowdloan.impl.presentation.contribute.confirm.parcel.ConfirmContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.BonusPayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeFragment import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.model.CustomContributePayload import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.CrowdloanContributeFragment import jp.co.soramitsu.crowdloan.impl.presentation.contribute.select.parcel.ContributePayload import jp.co.soramitsu.onboarding.impl.OnboardingRouter import jp.co.soramitsu.onboarding.impl.welcome.WelcomeFragment import jp.co.soramitsu.onboarding.impl.welcome.select_import_mode.SelectImportModeDialog import jp.co.soramitsu.polkaswap.api.presentation.PolkaswapRouter import jp.co.soramitsu.polkaswap.api.presentation.models.SwapDetailsParcelModel import jp.co.soramitsu.polkaswap.api.presentation.models.SwapDetailsViewState import jp.co.soramitsu.polkaswap.api.presentation.models.TransactionSettingsModel import jp.co.soramitsu.polkaswap.impl.presentation.swap_preview.SwapPreviewFragment import jp.co.soramitsu.polkaswap.impl.presentation.swap_tokens.SwapTokensFragment import jp.co.soramitsu.polkaswap.impl.presentation.transaction_settings.TransactionSettingsFragment import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.soracard.api.presentation.SoraCardRouter import jp.co.soramitsu.splash.SplashRouter import jp.co.soramitsu.staking.api.domain.model.PoolInfo import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.payouts.confirm.ConfirmPayoutFragment import jp.co.soramitsu.staking.impl.presentation.payouts.confirm.model.ConfirmPayoutPayload import jp.co.soramitsu.staking.impl.presentation.payouts.detail.PayoutDetailsFragment import jp.co.soramitsu.staking.impl.presentation.payouts.model.PendingPayoutParcelable import jp.co.soramitsu.staking.impl.presentation.pools.PoolInfoFragment import jp.co.soramitsu.staking.impl.presentation.pools.PoolInfoOptionsFragment import jp.co.soramitsu.staking.impl.presentation.staking.balance.StakingBalanceFragment import jp.co.soramitsu.staking.impl.presentation.staking.bond.confirm.ConfirmBondMoreFragment import jp.co.soramitsu.staking.impl.presentation.staking.bond.confirm.ConfirmBondMorePayload import jp.co.soramitsu.staking.impl.presentation.staking.bond.select.SelectBondMoreFragment import jp.co.soramitsu.staking.impl.presentation.staking.bond.select.SelectBondMorePayload import jp.co.soramitsu.staking.impl.presentation.staking.controller.confirm.ConfirmSetControllerFragment import jp.co.soramitsu.staking.impl.presentation.staking.controller.confirm.ConfirmSetControllerPayload import jp.co.soramitsu.staking.impl.presentation.staking.rebond.confirm.ConfirmRebondFragment import jp.co.soramitsu.staking.impl.presentation.staking.rebond.confirm.ConfirmRebondPayload import jp.co.soramitsu.staking.impl.presentation.staking.redeem.RedeemFragment import jp.co.soramitsu.staking.impl.presentation.staking.redeem.RedeemPayload import jp.co.soramitsu.staking.impl.presentation.staking.rewardDestination.confirm.ConfirmRewardDestinationFragment import jp.co.soramitsu.staking.impl.presentation.staking.rewardDestination.confirm.parcel.ConfirmRewardDestinationPayload import jp.co.soramitsu.staking.impl.presentation.staking.unbond.PoolFullUnstakeDepositorAlertFragment import jp.co.soramitsu.staking.impl.presentation.staking.unbond.confirm.ConfirmUnbondFragment import jp.co.soramitsu.staking.impl.presentation.staking.unbond.confirm.ConfirmUnbondPayload import jp.co.soramitsu.staking.impl.presentation.staking.unbond.select.SelectUnbondFragment import jp.co.soramitsu.staking.impl.presentation.staking.unbond.select.SelectUnbondPayload import jp.co.soramitsu.staking.impl.presentation.validators.change.custom.settings.CustomValidatorsSettingsFragment import jp.co.soramitsu.staking.impl.presentation.validators.details.CollatorDetailsFragment import jp.co.soramitsu.staking.impl.presentation.validators.details.ValidatorDetailsFragment import jp.co.soramitsu.staking.impl.presentation.validators.parcel.CollatorDetailsParcelModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.ValidatorDetailsParcelModel import jp.co.soramitsu.success.presentation.SuccessFragment import jp.co.soramitsu.success.presentation.SuccessRouter import jp.co.soramitsu.wallet.api.domain.model.XcmChainType import jp.co.soramitsu.wallet.impl.domain.beacon.SignStatus import jp.co.soramitsu.wallet.impl.domain.model.PhishingType import jp.co.soramitsu.wallet.impl.presentation.AssetPayload import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.addressbook.CreateContactFragment import jp.co.soramitsu.wallet.impl.presentation.balance.assetselector.AssetSelectFragment import jp.co.soramitsu.wallet.impl.presentation.balance.chainselector.ChainSelectFragment import jp.co.soramitsu.wallet.impl.presentation.balance.detail.BalanceDetailFragment import jp.co.soramitsu.wallet.impl.presentation.balance.detail.frozen.FrozenAssetPayload import jp.co.soramitsu.wallet.impl.presentation.balance.detail.frozen.FrozenTokensFragment import jp.co.soramitsu.wallet.impl.presentation.balance.optionswallet.OptionsWalletFragment import jp.co.soramitsu.wallet.impl.presentation.balance.walletselector.light.WalletSelectionMode import jp.co.soramitsu.wallet.impl.presentation.balance.walletselector.light.WalletSelectorFragment import jp.co.soramitsu.wallet.impl.presentation.beacon.main.BeaconFragment import jp.co.soramitsu.wallet.impl.presentation.beacon.main.DAppMetadataModel import jp.co.soramitsu.wallet.impl.presentation.beacon.sign.SignBeaconTransactionFragment import jp.co.soramitsu.wallet.impl.presentation.beacon.sign.TransactionRawDataFragment import jp.co.soramitsu.wallet.impl.presentation.cross_chain.CrossChainTransferDraft import jp.co.soramitsu.wallet.impl.presentation.cross_chain.confirm.CrossChainConfirmFragment import jp.co.soramitsu.wallet.impl.presentation.cross_chain.setup.CrossChainSetupFragment import jp.co.soramitsu.wallet.impl.presentation.history.AddressHistoryFragment import jp.co.soramitsu.wallet.impl.presentation.model.OperationParcelizeModel import jp.co.soramitsu.wallet.impl.presentation.receive.ReceiveFragment import jp.co.soramitsu.wallet.impl.presentation.send.TransferDraft import jp.co.soramitsu.wallet.impl.presentation.send.confirm.ConfirmSendFragment import jp.co.soramitsu.wallet.impl.presentation.send.setup.SendSetupFragment import jp.co.soramitsu.wallet.impl.presentation.transaction.detail.extrinsic.ExtrinsicDetailFragment import jp.co.soramitsu.wallet.impl.presentation.transaction.detail.extrinsic.ExtrinsicDetailsPayload import jp.co.soramitsu.wallet.impl.presentation.transaction.detail.reward.RewardDetailFragment import jp.co.soramitsu.wallet.impl.presentation.transaction.detail.reward.RewardDetailsPayload import jp.co.soramitsu.wallet.impl.presentation.transaction.detail.swap.SwapDetailFragment import jp.co.soramitsu.wallet.impl.presentation.transaction.detail.transfer.TransferDetailFragment import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.emptyFlow import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.filterNotNull import kotlinx.coroutines.flow.flowOf import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.flow.onCompletion import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.flow.onStart import kotlinx.coroutines.job import kotlinx.parcelize.Parcelize import kotlin.coroutines.coroutineContext import jp.co.soramitsu.common.utils.combine as combineLiveData</ID>
    <ID>ImportOrdering:NetworkIssuesViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.AccountInteractor import jp.co.soramitsu.account.api.presentation.actions.AddAccountBottomSheet import jp.co.soramitsu.common.AlertViewState import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.NetworkIssueItemState import jp.co.soramitsu.common.compose.component.NetworkIssueType import jp.co.soramitsu.common.mixin.api.NetworkStateMixin import jp.co.soramitsu.common.mixin.api.NetworkStateUi import jp.co.soramitsu.common.mixin.api.UpdatesMixin import jp.co.soramitsu.common.mixin.api.UpdatesProviderUi import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:NodeDetailsRootViewModel.kt$import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.base.errors.FearlessException import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.account.impl.domain.errors.NodeAlreadyExistsException import jp.co.soramitsu.account.impl.domain.errors.UnsupportedNetworkException</ID>
    <ID>ImportOrdering:NodesAdapter.kt$import android.annotation.SuppressLint import android.view.View import android.view.ViewGroup import android.widget.ImageView import android.widget.TextView import jp.co.soramitsu.common.list.BaseGroupedDiffCallback import jp.co.soramitsu.common.list.GroupedListAdapter import jp.co.soramitsu.common.list.GroupedListHolder import jp.co.soramitsu.common.utils.inflateChild import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.account.impl.presentation.node.model.NodeHeaderModel import jp.co.soramitsu.account.impl.presentation.node.model.NodeModel</ID>
    <ID>ImportOrdering:NodesFragment.kt$import android.os.Bundle import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import androidx.core.os.bundleOf import androidx.fragment.app.viewModels import androidx.lifecycle.lifecycleScope import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import javax.inject.Inject import jp.co.soramitsu.account.impl.presentation.node.model.NodeModel import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.presentation.ErrorDialog import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.feature_account_impl.databinding.FragmentNodesBinding</ID>
    <ID>ImportOrdering:NodesModule.kt$import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.account.api.domain.interfaces.NodesSettingsScenario import jp.co.soramitsu.account.impl.domain.NodesSettingsScenarioImpl import jp.co.soramitsu.account.impl.presentation.node.mixin.api.NodeListingMixin import jp.co.soramitsu.account.impl.presentation.node.mixin.impl.NodeListingProvider import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry</ID>
    <ID>ImportOrdering:NodesViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.liveData import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.NodesSettingsScenario import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.account.impl.presentation.node.details.NodeDetailsPayload import jp.co.soramitsu.account.impl.presentation.node.list.NodesFragment.Companion.CHAIN_ID_KEY import jp.co.soramitsu.account.impl.presentation.node.mixin.api.NodeListingMixin import jp.co.soramitsu.account.impl.presentation.node.model.NodeModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.map import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.NodeId import jp.co.soramitsu.runtime.storage.NodesSettingsStorage import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.drop import kotlinx.coroutines.flow.map import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:NotZeroAmountValidation.kt$import java.math.BigDecimal import jp.co.soramitsu.common.validation.DefaultFailureLevel import jp.co.soramitsu.common.validation.Validation import jp.co.soramitsu.common.validation.ValidationStatus</ID>
    <ID>ImportOrdering:NotZeroBalanceValidation.kt$import java.math.BigDecimal import jp.co.soramitsu.common.validation.DefaultFailureLevel import jp.co.soramitsu.common.validation.Validation import jp.co.soramitsu.common.validation.ValidationStatus import jp.co.soramitsu.runtime.ext.accountIdOf import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.impl.domain.validations.controller.SetControllerValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.controller.SetControllerValidationPayload import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletRepository import kotlinx.coroutines.flow.first</ID>
    <ID>ImportOrdering:ObserveBrowserEvents.kt$import jp.co.soramitsu.common.base.BaseComposeBottomSheetDialogFragment import jp.co.soramitsu.common.base.BaseBottomSheetDialogFragment import jp.co.soramitsu.common.base.BaseComposeFragment import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.mixin.api.Browserable import jp.co.soramitsu.common.utils.showBrowser</ID>
    <ID>ImportOrdering:OnboardingStoriesDataSource.kt$import jp.co.soramitsu.common.domain.model.StoryGroup import jp.co.soramitsu.common.R</ID>
    <ID>ImportOrdering:OptionsAddAccountViewModel.kt$import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.AccountInteractor import jp.co.soramitsu.account.api.domain.interfaces.AssetNotNeedAccountUseCase import jp.co.soramitsu.account.api.presentation.actions.AddAccountBottomSheet import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.account.impl.presentation.optionsaddaccount.OptionsAddAccountFragment.Companion.KEY_PAYLOAD import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:ParachainMetadataParcelModel.kt$import android.os.Parcelable import jp.co.soramitsu.crowdloan.api.data.repository.ParachainMetadata import jp.co.soramitsu.crowdloan.api.data.repository.ParachainMetadataFlow import kotlinx.parcelize.Parcelize import kotlinx.android.parcel.RawValue import java.math.BigDecimal import java.util.Locale</ID>
    <ID>ImportOrdering:PayoutDetailsFragment.kt$import android.os.Bundle import androidx.fragment.app.viewModels import dagger.hilt.android.AndroidEntryPoint import dev.chrisbanes.insetter.applyInsetter import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.utils.formatDateFromMillis import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.account.api.presentation.actions.setupExternalActions import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.feature_staking_impl.databinding.FragmentPayoutDetailsBinding import jp.co.soramitsu.staking.impl.presentation.payouts.model.PendingPayoutParcelable</ID>
    <ID>ImportOrdering:PayoutDetailsViewModel.kt$import androidx.lifecycle.SavedStateHandle import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.payouts.confirm.model.ConfirmPayoutPayload import jp.co.soramitsu.staking.impl.presentation.payouts.model.PendingPayoutParcelable import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:PayoutsListViewModel.kt$import androidx.lifecycle.MutableLiveData import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.base.errors.TitledException import jp.co.soramitsu.common.mixin.api.Retriable import jp.co.soramitsu.common.mixin.api.RetryPayload import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.requireException import jp.co.soramitsu.common.utils.requireValue import jp.co.soramitsu.common.utils.singleReplaySharedFlow import jp.co.soramitsu.common.utils.withLoading import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.model.PendingPayout import jp.co.soramitsu.staking.impl.domain.model.PendingPayoutsStatistics import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.payouts.confirm.model.ConfirmPayoutPayload import jp.co.soramitsu.staking.impl.presentation.payouts.list.model.PendingPayoutModel import jp.co.soramitsu.staking.impl.presentation.payouts.list.model.PendingPayoutsStatisticsModel import jp.co.soramitsu.staking.impl.presentation.payouts.model.PendingPayoutParcelable import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioInteractor import jp.co.soramitsu.wallet.api.presentation.formatters.formatSigned import jp.co.soramitsu.wallet.impl.domain.model.Token import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:PendingPayoutParcelable.kt$import android.os.Parcelable import java.math.BigInteger import kotlinx.parcelize.Parcelize</ID>
    <ID>ImportOrdering:PermissionException.kt$import jp.co.soramitsu.android_foundation.core.RuntimePermission import jp.co.soramitsu.android_foundation.core.PermissionResult import java.lang.Exception</ID>
    <ID>ImportOrdering:PinCodeViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.vibration.DeviceVibrator import jp.co.soramitsu.account.api.domain.interfaces.AccountInteractor import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.account.impl.presentation.AccountRouter import kotlinx.coroutines.launch import javax.inject.Inject</ID>
    <ID>ImportOrdering:PincodeFragment.kt$import android.os.Bundle import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import android.widget.Toast import androidx.activity.OnBackPressedCallback import androidx.biometric.BiometricManager import androidx.biometric.BiometricPrompt import androidx.core.os.bundleOf import androidx.fragment.app.viewModels import dagger.hilt.android.AndroidEntryPoint import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.io.MainThreadExecutor import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.feature_account_impl.databinding.FragmentPincodeBinding import jp.co.soramitsu.account.impl.presentation.pincode.fingerprint.FingerprintCallback import jp.co.soramitsu.account.impl.presentation.pincode.fingerprint.FingerprintWrapper import jp.co.soramitsu.common.presentation.ErrorDialog</ID>
    <ID>ImportOrdering:PolkaswapDisclaimerViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.theme.colorAccent import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.feature_polkaswap_impl.R import jp.co.soramitsu.polkaswap.api.domain.PolkaswapInteractor import jp.co.soramitsu.polkaswap.api.presentation.PolkaswapRouter import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn</ID>
    <ID>ImportOrdering:PolkaswapFeatureBindModule.kt$import dagger.Binds import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import javax.inject.Named import javax.inject.Singleton import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.common.data.network.config.RemoteConfigFetcher import jp.co.soramitsu.core.extrinsic.ExtrinsicService import jp.co.soramitsu.polkaswap.api.data.PolkaswapRepository import jp.co.soramitsu.polkaswap.api.domain.PolkaswapInteractor import jp.co.soramitsu.polkaswap.impl.data.PolkaswapRepositoryImpl import jp.co.soramitsu.polkaswap.impl.domain.PolkaswapInteractorImpl import jp.co.soramitsu.runtime.di.REMOTE_STORAGE_SOURCE import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.core.rpc.RpcCalls import jp.co.soramitsu.runtime.storage.source.StorageDataSource</ID>
    <ID>ImportOrdering:PolkaswapInteractor.kt$import java.math.BigDecimal import java.math.BigInteger import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.polkaswap.api.domain.models.SwapDetails import jp.co.soramitsu.polkaswap.api.models.Market import jp.co.soramitsu.polkaswap.api.models.WithDesired import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.wallet.impl.domain.model.Asset import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.StateFlow</ID>
    <ID>ImportOrdering:PolkaswapInteractorImpl.kt$import java.math.BigDecimal import java.math.BigInteger import java.math.RoundingMode import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.domain.model.accountId import jp.co.soramitsu.common.data.storage.Preferences import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.utils.isZero import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.core.runtime.models.responses.QuoteResponse import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.polkaswap.api.data.PolkaswapRepository import jp.co.soramitsu.polkaswap.api.domain.InsufficientLiquidityException import jp.co.soramitsu.polkaswap.api.domain.PolkaswapInteractor import jp.co.soramitsu.polkaswap.api.domain.models.SwapDetails import jp.co.soramitsu.polkaswap.api.models.Market import jp.co.soramitsu.polkaswap.api.models.WithDesired import jp.co.soramitsu.polkaswap.api.models.backStrings import jp.co.soramitsu.polkaswap.api.models.toFilters import jp.co.soramitsu.polkaswap.api.presentation.models.toModel import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.soraMainChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.soraTestChainId import jp.co.soramitsu.runtime.multiNetwork.chainWithAsset import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletRepository import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import kotlin.math.max import kotlinx.coroutines.FlowPreview import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.debounce import kotlinx.coroutines.flow.merge</ID>
    <ID>ImportOrdering:PoolBondMoreViewModel.kt$import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.validation.StakeInsufficientBalanceException import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.wallet.api.presentation.BaseEnterAmountViewModel import jp.co.soramitsu.wallet.api.presentation.Validation import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount</ID>
    <ID>ImportOrdering:PoolInfoOptionsViewModel.kt$import androidx.lifecycle.SavedStateHandle import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.staking.api.domain.model.PoolInfo import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.EditPoolFlowState import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.presentation.pools.compose.PoolInfoOptionsViewState</ID>
    <ID>ImportOrdering:PoolInfoViewModel.kt$import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.DropDownViewState import jp.co.soramitsu.common.compose.component.TitleValueViewState import jp.co.soramitsu.common.resources.ClipboardManager import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.applyFiatRate import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.ext.accountFromMapKey import jp.co.soramitsu.runtime.ext.accountIdOf import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.shared_utils.extensions.toHexString import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.shared_utils.ss58.SS58Encoder.toAddress import jp.co.soramitsu.staking.api.domain.model.NominationPoolState import jp.co.soramitsu.staking.api.domain.model.PoolInfo import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SelectedValidatorsFlowState import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.presentation.pools.compose.PoolInfoScreenInterface import jp.co.soramitsu.staking.impl.presentation.pools.compose.PoolInfoScreenViewState import jp.co.soramitsu.staking.impl.presentation.pools.compose.PoolStatusViewState import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.stateIn</ID>
    <ID>ImportOrdering:ProfileActionsSheet.kt$import android.content.Context import android.os.Bundle import jp.co.soramitsu.common.view.bottomSheet.list.fixed.item import jp.co.soramitsu.account.api.presentation.actions.CopyCallback import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.account.api.presentation.actions.ExternalActionsSheet import jp.co.soramitsu.account.api.presentation.actions.ExternalViewCallback import jp.co.soramitsu.feature_account_impl.R</ID>
    <ID>ImportOrdering:ProfileFragment.kt$import android.os.Bundle import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import androidx.core.view.isVisible import androidx.fragment.app.viewModels import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import javax.inject.Inject import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.account.api.presentation.actions.copyAddressClicked import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.data.network.coingecko.FiatCurrency import jp.co.soramitsu.common.mixin.impl.observeBrowserEvents import jp.co.soramitsu.common.presentation.FiatCurrenciesChooserBottomSheetDialog import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListBottomSheet import jp.co.soramitsu.feature_account_impl.databinding.FragmentProfileBinding import jp.co.soramitsu.oauth.base.sdk.contract.SoraCardResult import jp.co.soramitsu.oauth.base.sdk.signin.SoraCardSignInContract</ID>
    <ID>ImportOrdering:ProfileModule.kt$import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import jp.co.soramitsu.common.di.viewmodel.ViewModelModule import jp.co.soramitsu.coredb.dao.AssetDao import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.domain.interfaces.TotalBalanceUseCase import jp.co.soramitsu.account.impl.domain.TotalBalanceUseCaseImpl import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry</ID>
    <ID>ImportOrdering:ProfileViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.liveData import androidx.lifecycle.map import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.util.Locale import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.AccountInteractor import jp.co.soramitsu.account.api.domain.interfaces.TotalBalanceUseCase import jp.co.soramitsu.account.api.domain.model.MetaAccount import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.account.impl.presentation.language.mapper.mapLanguageToLanguageModel import jp.co.soramitsu.common.BuildConfig import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.OptionsProvider import jp.co.soramitsu.common.data.network.coingecko.FiatChooserEvent import jp.co.soramitsu.common.data.network.coingecko.FiatCurrency import jp.co.soramitsu.common.domain.GetAvailableFiatCurrencies import jp.co.soramitsu.common.domain.SelectedFiat import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListBottomSheet import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.oauth.base.sdk.SoraCardEnvironmentType import jp.co.soramitsu.oauth.base.sdk.SoraCardInfo import jp.co.soramitsu.oauth.base.sdk.SoraCardKycCredentials import jp.co.soramitsu.oauth.base.sdk.contract.SoraCardCommonVerification import jp.co.soramitsu.oauth.base.sdk.contract.SoraCardContractData import jp.co.soramitsu.soracard.api.domain.SoraCardInteractor import jp.co.soramitsu.soracard.impl.presentation.SoraCardItemViewState import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.firstOrNull import kotlinx.coroutines.flow.flowOf import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch import jp.co.soramitsu.oauth.R as SoraCardR</ID>
    <ID>ImportOrdering:ReceiveViewModel.kt$import android.graphics.Bitmap import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.resources.ClipboardManager import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.QrCodeGenerator import jp.co.soramitsu.common.utils.requireException import jp.co.soramitsu.common.utils.requireValue import jp.co.soramitsu.common.utils.write import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.soraKusamaChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.soraTestChainId import jp.co.soramitsu.wallet.impl.domain.CurrentAccountAddressUseCase import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.domain.model.WalletAccount import jp.co.soramitsu.wallet.impl.presentation.AssetPayload import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.receive.model.QrSharingPayload import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.firstOrNull import kotlinx.coroutines.flow.flow import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:RecommendationSettingsProvider.kt$import java.math.BigInteger import jp.co.soramitsu.staking.api.domain.model.Collator import jp.co.soramitsu.staking.api.domain.model.Validator import jp.co.soramitsu.staking.impl.domain.recommendations.settings.filters.BlockProducerFilters import jp.co.soramitsu.staking.impl.domain.recommendations.settings.filters.Filters import jp.co.soramitsu.staking.impl.domain.recommendations.settings.filters.RecommendationPostProcessor import jp.co.soramitsu.staking.impl.domain.recommendations.settings.filters.Sorting import jp.co.soramitsu.staking.impl.domain.recommendations.settings.postprocessors.RemoveClusteringPostprocessor import jp.co.soramitsu.staking.impl.domain.recommendations.settings.sortings.BlockProducersSorting import jp.co.soramitsu.staking.impl.presentation.validators.change.custom.settings.SettingsSchema import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow</ID>
    <ID>ImportOrdering:RecommendedCollatorsViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import javax.inject.Inject import javax.inject.Named import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.castOrNull import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.lazyAsync import jp.co.soramitsu.common.utils.withLoading import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.api.domain.model.Collator import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.recommendations.CollatorRecommendatorFactory import jp.co.soramitsu.staking.impl.domain.recommendations.settings.RecommendationSettingsProviderFactory import jp.co.soramitsu.staking.impl.domain.recommendations.settings.sortings.BlockProducersSorting import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess.ReadyToSubmit import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess.ReadyToSubmit.SelectionMethod import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingSharedState import jp.co.soramitsu.staking.impl.presentation.mappers.mapCollatorToCollatorModel import jp.co.soramitsu.staking.impl.presentation.validators.change.CollatorModel import jp.co.soramitsu.staking.impl.presentation.validators.change.setRecommendedCollators import jp.co.soramitsu.staking.impl.presentation.validators.parcel.CollatorDetailsParcelModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.CollatorStakeParcelModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.IdentityParcelModel import jp.co.soramitsu.staking.impl.scenarios.parachain.StakingParachainScenarioInteractor import jp.co.soramitsu.wallet.impl.domain.TokenUseCase import jp.co.soramitsu.wallet.impl.domain.model.Token import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:RecommendedValidatorsViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.invoke import jp.co.soramitsu.common.utils.lazyAsync import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.api.domain.model.Validator import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.getSelectedChain import jp.co.soramitsu.staking.impl.domain.recommendations.ValidatorRecommendatorFactory import jp.co.soramitsu.staking.impl.domain.recommendations.settings.RecommendationSettingsProviderFactory import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess.ReadyToSubmit import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess.ReadyToSubmit.SelectionMethod import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingSharedState import jp.co.soramitsu.staking.impl.presentation.mappers.mapValidatorToValidatorDetailsParcelModel import jp.co.soramitsu.staking.impl.presentation.mappers.mapValidatorToValidatorModel import jp.co.soramitsu.staking.impl.presentation.validators.change.ValidatorModel import jp.co.soramitsu.staking.impl.presentation.validators.change.setRecommendedValidators import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioInteractor import jp.co.soramitsu.wallet.impl.domain.TokenUseCase import jp.co.soramitsu.wallet.impl.domain.model.Token import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.flow import kotlinx.coroutines.flow.map import kotlinx.coroutines.launch import javax.inject.Named</ID>
    <ID>ImportOrdering:RedeemFragment.kt$import android.os.Bundle import androidx.core.view.isVisible import androidx.fragment.app.viewModels import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import dev.chrisbanes.insetter.applyInsetter import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.mixin.impl.observeRetries import jp.co.soramitsu.common.mixin.impl.observeValidations import jp.co.soramitsu.common.view.setProgress import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.account.api.presentation.actions.setupExternalActions import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.feature_staking_impl.databinding.FragmentRedeemBinding import javax.inject.Inject</ID>
    <ID>ImportOrdering:RedeemViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import javax.inject.Inject import javax.inject.Named import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.common.R import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.mixin.api.Validatable import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.formatCryptoFull import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.requireException import jp.co.soramitsu.common.utils.requireValue import jp.co.soramitsu.common.validation.ValidationExecutor import jp.co.soramitsu.common.validation.progressConsumer import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import jp.co.soramitsu.shared_utils.extensions.fromHex import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.staking.redeem.RedeemInteractor import jp.co.soramitsu.staking.impl.domain.validations.reedeem.RedeemValidationPayload import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.scenarios.StakingScenarioInteractor import jp.co.soramitsu.wallet.api.data.mappers.mapAssetToAssetModel import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeLoaderMixin import kotlinx.coroutines.flow.MutableSharedFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.filterIsInstance import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:ReferralContributeView.kt$import android.content.Context import android.text.method.LinkMovementMethod import android.util.AttributeSet import android.view.View import android.widget.TextView import androidx.annotation.LayoutRes import androidx.lifecycle.LifecycleCoroutineScope import com.google.android.material.switchmaterial.SwitchMaterial import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.common.utils.createSpannable import jp.co.soramitsu.common.utils.observe import jp.co.soramitsu.common.utils.setVisible import jp.co.soramitsu.common.utils.showBrowser import jp.co.soramitsu.common.view.InputField import jp.co.soramitsu.common.view.TableCellView import jp.co.soramitsu.feature_crowdloan_impl.R import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeView import jp.co.soramitsu.crowdloan.impl.presentation.contribute.custom.CustomContributeViewState import java.math.BigDecimal</ID>
    <ID>ImportOrdering:ReviewCustomValidatorsViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import javax.inject.Named import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.view.ButtonState import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.api.domain.model.Validator import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.getSelectedChain import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingSharedState import jp.co.soramitsu.staking.impl.presentation.mappers.mapValidatorToValidatorDetailsParcelModel import jp.co.soramitsu.staking.impl.presentation.mappers.mapValidatorToValidatorModel import jp.co.soramitsu.staking.impl.presentation.validators.change.ValidatorModel import jp.co.soramitsu.staking.impl.presentation.validators.change.custom.review.model.ValidatorsSelectionState import jp.co.soramitsu.staking.impl.presentation.validators.change.setCustomValidators import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioInteractor import jp.co.soramitsu.wallet.impl.domain.TokenUseCase import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.filterIsInstance import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:RewardCalculator.kt$import java.math.BigDecimal import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId</ID>
    <ID>ImportOrdering:RewardDestinationMixin.kt$import androidx.lifecycle.LiveData import java.math.BigDecimal import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.mixin.api.Browserable import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListBottomSheet import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.domain.rewards.RewardCalculator import jp.co.soramitsu.wallet.impl.domain.model.Asset import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.flow.Flow</ID>
    <ID>ImportOrdering:RewardDestinationProvider.kt$import androidx.lifecycle.MutableLiveData import java.math.BigDecimal import jp.co.soramitsu.account.api.presentation.account.AddressDisplayUseCase import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.data.network.AppLinksProvider import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListBottomSheet import jp.co.soramitsu.runtime.ext.addressOf import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.api.data.SyntheticStakingType import jp.co.soramitsu.staking.api.data.syntheticStakingType import jp.co.soramitsu.staking.api.domain.model.RewardDestination import jp.co.soramitsu.staking.api.domain.model.StakingAccount import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.rewards.DAYS_IN_YEAR import jp.co.soramitsu.staking.impl.domain.rewards.RewardCalculator import jp.co.soramitsu.staking.impl.domain.rewards.SoraRewardCalculator import jp.co.soramitsu.staking.impl.domain.rewards.SoraStakingRewardsScenario import jp.co.soramitsu.staking.impl.presentation.mappers.RewardSuffix import jp.co.soramitsu.staking.impl.presentation.mappers.mapPeriodReturnsToRewardEstimation import jp.co.soramitsu.staking.impl.scenarios.StakingScenarioInteractor import jp.co.soramitsu.wallet.impl.domain.model.Asset import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.channels.BufferOverflow import kotlinx.coroutines.flow.MutableSharedFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.flow.onStart import kotlinx.coroutines.launch import jp.co.soramitsu.core.models.Asset as CoreAsset</ID>
    <ID>ImportOrdering:RewardDetailFragment.kt$import androidx.annotation.StringRes import androidx.core.os.bundleOf import androidx.fragment.app.viewModels import dagger.hilt.android.AndroidEntryPoint import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.utils.formatDateTime import jp.co.soramitsu.common.utils.makeGone import jp.co.soramitsu.common.utils.setTextColorRes import jp.co.soramitsu.common.utils.showBrowser import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.account.api.presentation.actions.ExternalActionsSheet import jp.co.soramitsu.account.api.presentation.actions.ExternalViewCallback import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.feature_wallet_impl.databinding.FragmentRewardSlashDetailsBinding import jp.co.soramitsu.wallet.impl.presentation.model.OperationParcelizeModel import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain</ID>
    <ID>ImportOrdering:RewardDetailViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.liveData import dagger.hilt.android.lifecycle.HiltViewModel import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.mixin.api.Browserable import jp.co.soramitsu.common.resources.ClipboardManager import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.account.api.presentation.account.AddressDisplayUseCase import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.transaction.detail.reward.RewardDetailFragment.Companion.KEY_PAYLOAD import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import kotlinx.coroutines.flow.flow import javax.inject.Inject</ID>
    <ID>ImportOrdering:RootActivity.kt$import android.annotation.SuppressLint import android.content.ActivityNotFoundException import android.content.Intent import android.net.Uri import android.os.Bundle import android.view.View import android.view.animation.Animation import android.view.animation.TranslateAnimation import android.widget.TextView import androidx.activity.viewModels import androidx.core.view.WindowInsetsCompat import androidx.core.view.isVisible import androidx.lifecycle.Lifecycle import androidx.lifecycle.LifecycleObserver import androidx.lifecycle.OnLifecycleEvent import androidx.lifecycle.ProcessLifecycleOwner import androidx.lifecycle.lifecycleScope import androidx.navigation.NavController import androidx.navigation.fragment.NavHostFragment import dagger.hilt.android.AndroidEntryPoint import javax.inject.Inject import jp.co.soramitsu.app.R import jp.co.soramitsu.app.root.navigation.Navigator import jp.co.soramitsu.common.PLAY_MARKET_APP_URI import jp.co.soramitsu.common.PLAY_MARKET_BROWSER_URI import jp.co.soramitsu.common.base.BaseActivity import jp.co.soramitsu.common.utils.EventObserver import jp.co.soramitsu.common.utils.observe import jp.co.soramitsu.common.utils.showToast import jp.co.soramitsu.common.utils.updatePadding import jp.co.soramitsu.common.view.bottomSheet.AlertBottomSheet</ID>
    <ID>ImportOrdering:RootViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.util.Date import java.util.Timer import java.util.TimerTask import javax.inject.Inject import jp.co.soramitsu.app.R import jp.co.soramitsu.app.root.domain.RootInteractor import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.mixin.api.NetworkStateMixin import jp.co.soramitsu.common.mixin.api.NetworkStateUi import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.core.runtime.ChainConnection import jp.co.soramitsu.core.updater.Updater import kotlin.concurrent.timerTask import kotlin.time.DurationUnit import kotlin.time.toDuration import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:RuntimeSyncService.kt$import android.util.Log import io.ktor.util.collections.ConcurrentSet import java.util.concurrent.ConcurrentHashMap import jp.co.soramitsu.common.mixin.api.UpdatesMixin import jp.co.soramitsu.common.mixin.api.UpdatesProviderUi import jp.co.soramitsu.common.utils.md5 import jp.co.soramitsu.common.utils.newLimitedThreadPoolExecutor import jp.co.soramitsu.coredb.dao.ChainDao import jp.co.soramitsu.coredb.model.chain.ChainRuntimeInfoLocal import jp.co.soramitsu.coredb.model.chain.ChainTypesLocal import jp.co.soramitsu.runtime.BuildConfig import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.connection.ConnectionPool import jp.co.soramitsu.runtime.multiNetwork.runtime.types.TypesFetcher import jp.co.soramitsu.shared_utils.runtime.metadata.GetMetadataRequest import jp.co.soramitsu.shared_utils.wsrpc.executeAsync import jp.co.soramitsu.shared_utils.wsrpc.mappers.nonNull import jp.co.soramitsu.shared_utils.wsrpc.mappers.pojo import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.Job import kotlinx.coroutines.asCoroutineDispatcher import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableSharedFlow import kotlinx.coroutines.flow.filter import kotlinx.coroutines.launch import kotlinx.serialization.decodeFromString import kotlinx.serialization.json.Json import kotlinx.serialization.json.JsonArray import kotlinx.serialization.json.jsonObject import kotlinx.serialization.json.jsonPrimitive</ID>
    <ID>ImportOrdering:ScannerActivity.kt$import android.app.Activity import android.content.Intent import android.graphics.Color import android.os.Bundle import android.view.KeyEvent import androidx.activity.result.ActivityResult import androidx.activity.result.ActivityResultLauncher import androidx.activity.result.contract.ActivityResultContracts import androidx.appcompat.app.AppCompatActivity import androidx.lifecycle.LiveData import androidx.lifecycle.ProcessLifecycleOwner import com.google.zxing.client.android.Intents import com.journeyapps.barcodescanner.CaptureManager import dagger.hilt.android.AndroidEntryPoint import jp.co.soramitsu.common.R import jp.co.soramitsu.common.compose.component.emptyClick import javax.inject.Inject import jp.co.soramitsu.common.databinding.ActivityScannerBinding import jp.co.soramitsu.common.presentation.ErrorDialog import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.EventObserver</ID>
    <ID>ImportOrdering:ScannerViewModel.kt$import android.net.Uri import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.R import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.QrBitmapDecoder import jp.co.soramitsu.common.utils.requireValue import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:SearchAssetsViewModel.kt$import androidx.compose.material.ExperimentalMaterialApi import androidx.compose.material.SwipeableState import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.presentation.actions.AddAccountBottomSheet import jp.co.soramitsu.common.AlertViewState import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.ActionItemType import jp.co.soramitsu.common.compose.component.SwipeState import jp.co.soramitsu.common.compose.viewstate.AssetListItemViewState import jp.co.soramitsu.common.mixin.api.NetworkStateMixin import jp.co.soramitsu.common.mixin.api.NetworkStateUi import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.isZero import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.utils.sumByBigDecimal import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.runtime.ext.ecosystem import jp.co.soramitsu.runtime.multiNetwork.chain.ChainEcosystem import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.defaultChainSort import jp.co.soramitsu.runtime.multiNetwork.chain.model.getWithToken import jp.co.soramitsu.wallet.impl.domain.ChainInteractor import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.domain.model.AssetWithStatus import jp.co.soramitsu.wallet.impl.presentation.AssetPayload import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.balance.list.model.BalanceListItemModel import jp.co.soramitsu.wallet.impl.presentation.balance.list.model.toAssetState import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:SearchCustomBlockProducerInteractor.kt$import android.graphics.drawable.PictureDrawable import androidx.lifecycle.Lifecycle import java.math.BigDecimal import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createAddressIcon import jp.co.soramitsu.common.address.createEthereumAddressIcon import jp.co.soramitsu.common.data.memory.ComputationalCache import jp.co.soramitsu.common.utils.formatAsPercentage import jp.co.soramitsu.common.utils.fractionToPercentage import jp.co.soramitsu.common.utils.toggle import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.core.utils.isValidAddress import jp.co.soramitsu.shared_utils.extensions.requireHexPrefix import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.api.domain.model.Collator import jp.co.soramitsu.staking.api.domain.model.Validator import jp.co.soramitsu.staking.impl.domain.validators.CollatorProvider import jp.co.soramitsu.staking.impl.domain.validators.ValidatorProvider import jp.co.soramitsu.staking.impl.domain.validators.ValidatorSource import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingSharedState import jp.co.soramitsu.staking.impl.presentation.validators.change.setCustomCollators import jp.co.soramitsu.staking.impl.presentation.validators.change.setCustomValidators import kotlinx.coroutines.flow.first</ID>
    <ID>ImportOrdering:SearchCustomValidatorsViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.util.Locale import javax.inject.Inject import javax.inject.Named import jp.co.soramitsu.common.address.AddressIconGenerator.Companion.SIZE_MEDIUM import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.presentation.map import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.shared_utils.extensions.fromHex import jp.co.soramitsu.shared_utils.extensions.requireHexPrefix import jp.co.soramitsu.shared_utils.extensions.toHexString import jp.co.soramitsu.staking.impl.domain.validators.current.search.BlockedValidatorException import jp.co.soramitsu.staking.impl.domain.validators.current.search.SearchCustomBlockProducerInteractor import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingSharedState import jp.co.soramitsu.staking.impl.presentation.mappers.mapValidatorToValidatorDetailsParcelModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.CollatorDetailsParcelModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.CollatorStakeParcelModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.IdentityParcelModel import jp.co.soramitsu.wallet.impl.domain.TokenUseCase import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.filterIsInstance import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:SeedImportView.kt$import android.content.Context import android.util.AttributeSet import androidx.core.view.isVisible import androidx.lifecycle.LifecycleOwner import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.common.utils.nameInputFilters import jp.co.soramitsu.common.view.InputField import jp.co.soramitsu.common.view.shape.getIdleDrawable import jp.co.soramitsu.account.api.presentation.importing.ImportAccountType import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.feature_account_impl.databinding.ImportSourceSeedBinding import jp.co.soramitsu.account.impl.presentation.importing.source.model.ImportSource import jp.co.soramitsu.account.impl.presentation.importing.source.model.RawSeedImportSource</ID>
    <ID>ImportOrdering:SelectBondMoreFragment.kt$import android.os.Bundle import androidx.compose.foundation.layout.WindowInsets import androidx.compose.foundation.layout.ime import androidx.compose.foundation.layout.imePadding import androidx.compose.runtime.collectAsState import androidx.compose.runtime.getValue import androidx.compose.ui.Modifier import androidx.compose.ui.platform.LocalDensity import androidx.compose.ui.platform.ViewCompositionStrategy import androidx.core.view.isGone import androidx.core.view.isVisible import androidx.fragment.app.viewModels import androidx.lifecycle.lifecycleScope import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import dev.chrisbanes.insetter.applyInsetter import javax.inject.Inject import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.compose.component.QuickAmountInput import jp.co.soramitsu.common.compose.component.QuickInput import jp.co.soramitsu.common.compose.theme.FearlessAppTheme import jp.co.soramitsu.common.mixin.impl.observeRetries import jp.co.soramitsu.common.mixin.impl.observeValidations import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.common.utils.hideSoftKeyboard import jp.co.soramitsu.common.view.setProgress import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.feature_staking_impl.databinding.FragmentBondMoreBinding</ID>
    <ID>ImportOrdering:SelectBondMoreViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import javax.inject.Inject import javax.inject.Named import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.mixin.api.Validatable import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.requireException import jp.co.soramitsu.common.validation.ValidationExecutor import jp.co.soramitsu.common.validation.progressConsumer import jp.co.soramitsu.core.utils.amountFromPlanks import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.staking.bond.BondMoreInteractor import jp.co.soramitsu.staking.impl.domain.validations.bond.BondMoreValidationPayload import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.staking.bond.bondMoreValidationFailure import jp.co.soramitsu.staking.impl.presentation.staking.bond.confirm.ConfirmBondMorePayload import jp.co.soramitsu.staking.impl.scenarios.StakingScenarioInteractor import jp.co.soramitsu.wallet.api.data.mappers.mapAssetToAssetModel import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeLoaderMixin import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import kotlin.time.DurationUnit import kotlin.time.toDuration import kotlinx.coroutines.FlowPreview import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.debounce import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.firstOrNull import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:SelectCustomCollatorsViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.invoke import jp.co.soramitsu.common.utils.lazyAsync import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.api.domain.model.Collator import jp.co.soramitsu.staking.impl.domain.recommendations.CollatorRecommendatorFactory import jp.co.soramitsu.staking.impl.domain.recommendations.settings.RecommendationSettings import jp.co.soramitsu.staking.impl.domain.recommendations.settings.RecommendationSettingsProvider import jp.co.soramitsu.staking.impl.domain.recommendations.settings.RecommendationSettingsProviderFactory import jp.co.soramitsu.staking.impl.domain.recommendations.settings.SettingsStorage import jp.co.soramitsu.staking.impl.domain.recommendations.settings.filters.Filters import jp.co.soramitsu.staking.impl.domain.recommendations.settings.sortings.BlockProducersSorting import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingSharedState import jp.co.soramitsu.staking.impl.presentation.mappers.mapCollatorToCollatorModel import jp.co.soramitsu.staking.impl.presentation.validators.change.CollatorModel import jp.co.soramitsu.staking.impl.presentation.validators.change.custom.select.model.ContinueButtonState import jp.co.soramitsu.staking.impl.presentation.validators.change.setCustomCollators import jp.co.soramitsu.staking.impl.presentation.validators.parcel.CollatorDetailsParcelModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.CollatorStakeParcelModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.IdentityParcelModel import jp.co.soramitsu.wallet.impl.domain.TokenUseCase import jp.co.soramitsu.wallet.impl.domain.model.Token import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import kotlinx.coroutines.Deferred import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.emitAll import kotlinx.coroutines.flow.filterIsInstance import kotlinx.coroutines.flow.flow import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.launch import javax.inject.Named import jp.co.soramitsu.common.utils.withLoading</ID>
    <ID>ImportOrdering:SelectCustomValidatorsViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigInteger import javax.inject.Inject import javax.inject.Named import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.invoke import jp.co.soramitsu.common.utils.lazyAsync import jp.co.soramitsu.common.utils.toggle import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.staking.api.domain.model.Validator import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.getSelectedChain import jp.co.soramitsu.staking.impl.domain.recommendations.ValidatorRecommendatorFactory import jp.co.soramitsu.staking.impl.domain.recommendations.settings.RecommendationSettingsProviderFactory import jp.co.soramitsu.staking.impl.domain.recommendations.settings.SettingsStorage import jp.co.soramitsu.staking.impl.domain.recommendations.settings.sortings.BlockProducersSorting import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingSharedState import jp.co.soramitsu.staking.impl.presentation.mappers.mapValidatorToValidatorDetailsParcelModel import jp.co.soramitsu.staking.impl.presentation.mappers.mapValidatorToValidatorModel import jp.co.soramitsu.staking.impl.presentation.validators.change.ValidatorModel import jp.co.soramitsu.staking.impl.presentation.validators.change.custom.select.model.ContinueButtonState import jp.co.soramitsu.staking.impl.presentation.validators.change.setCustomValidators import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioInteractor import jp.co.soramitsu.wallet.impl.domain.TokenUseCase import jp.co.soramitsu.wallet.impl.domain.model.Token import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.emitAll import kotlinx.coroutines.flow.filterIsInstance import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.flow import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:SelectMarketViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.presentation.map import jp.co.soramitsu.polkaswap.api.domain.PolkaswapInteractor import jp.co.soramitsu.polkaswap.api.models.Market import jp.co.soramitsu.polkaswap.api.presentation.PolkaswapRouter import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn</ID>
    <ID>ImportOrdering:SelectPoolViewModel.kt$import androidx.compose.ui.text.SpanStyle import androidx.compose.ui.text.buildAnnotatedString import androidx.compose.ui.text.withStyle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.theme.black1 import jp.co.soramitsu.common.compose.theme.greenText import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.presentation.map import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.staking.api.domain.model.NominationPoolState import jp.co.soramitsu.staking.api.domain.model.PoolInfo import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.presentation.pools.compose.PoolSorting import jp.co.soramitsu.staking.impl.presentation.pools.compose.SelectableListItemState import jp.co.soramitsu.staking.impl.presentation.pools.compose.SingleSelectListItemViewState import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.distinctUntilChanged import kotlinx.coroutines.flow.stateIn</ID>
    <ID>ImportOrdering:SelectUnbondFragment.kt$import androidx.compose.foundation.layout.WindowInsets import androidx.compose.foundation.layout.ime import androidx.compose.foundation.layout.imePadding import androidx.compose.runtime.collectAsState import androidx.compose.runtime.getValue import androidx.compose.ui.Modifier import androidx.compose.ui.platform.LocalDensity import androidx.compose.ui.platform.ViewCompositionStrategy import androidx.core.os.bundleOf import androidx.core.view.isGone import androidx.core.view.isVisible import androidx.fragment.app.viewModels import androidx.lifecycle.lifecycleScope import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import dev.chrisbanes.insetter.applyInsetter import javax.inject.Inject import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.compose.component.QuickAmountInput import jp.co.soramitsu.common.compose.component.QuickInput import jp.co.soramitsu.common.compose.theme.FearlessAppTheme import jp.co.soramitsu.common.mixin.impl.observeRetries import jp.co.soramitsu.common.mixin.impl.observeValidations import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.common.utils.hideSoftKeyboard import jp.co.soramitsu.common.view.setProgress import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.feature_staking_impl.databinding.FragmentSelectUnbondBinding</ID>
    <ID>ImportOrdering:SelectWalletViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.AccountInteractor import jp.co.soramitsu.account.api.domain.interfaces.TotalBalanceUseCase import jp.co.soramitsu.account.impl.presentation.account.mixin.api.AccountListingMixin import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.ChangeBalanceViewState import jp.co.soramitsu.common.compose.component.WalletItemViewState import jp.co.soramitsu.common.compose.component.WalletSelectorViewState import jp.co.soramitsu.common.mixin.api.UpdatesMixin import jp.co.soramitsu.common.mixin.api.UpdatesProviderUi import jp.co.soramitsu.common.utils.formatAsChange import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.mapList import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:SendSetupContent.kt$import androidx.annotation.DrawableRes import androidx.annotation.StringRes import androidx.compose.foundation.BorderStroke import androidx.compose.foundation.background import androidx.compose.foundation.layout.Arrangement import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.Column import androidx.compose.foundation.layout.PaddingValues import androidx.compose.foundation.layout.Spacer import androidx.compose.foundation.layout.defaultMinSize import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.foundation.layout.fillMaxWidth import androidx.compose.foundation.layout.height import androidx.compose.foundation.layout.imePadding import androidx.compose.foundation.layout.padding import androidx.compose.foundation.layout.size import androidx.compose.foundation.lazy.LazyRow import androidx.compose.material.Icon import androidx.compose.runtime.Composable import androidx.compose.ui.Alignment import androidx.compose.ui.ExperimentalComposeUiApi import androidx.compose.ui.Modifier import androidx.compose.ui.graphics.Color import androidx.compose.ui.platform.LocalSoftwareKeyboardController import androidx.compose.ui.res.painterResource import androidx.compose.ui.res.stringResource import androidx.compose.ui.tooling.preview.Preview import androidx.compose.ui.unit.Dp import androidx.compose.ui.unit.dp import java.math.BigDecimal import jp.co.soramitsu.common.compose.component.AccentDarkDisabledButton import jp.co.soramitsu.common.compose.component.AddressInput import jp.co.soramitsu.common.compose.component.AddressInputState import jp.co.soramitsu.common.compose.component.AmountInput import jp.co.soramitsu.common.compose.component.AmountInputViewState import jp.co.soramitsu.common.compose.component.BottomSheetScreen import jp.co.soramitsu.common.compose.component.ButtonViewState import jp.co.soramitsu.common.compose.component.CapsTitle import jp.co.soramitsu.common.compose.component.ColoredButton import jp.co.soramitsu.common.compose.component.FeeInfo import jp.co.soramitsu.common.compose.component.FeeInfoViewState import jp.co.soramitsu.common.compose.component.MarginHorizontal import jp.co.soramitsu.common.compose.component.MarginVertical import jp.co.soramitsu.common.compose.component.QuickAmountInput import jp.co.soramitsu.common.compose.component.QuickInput import jp.co.soramitsu.common.compose.component.SelectorState import jp.co.soramitsu.common.compose.component.SelectorWithBorder import jp.co.soramitsu.common.compose.component.ToolbarBottomSheet import jp.co.soramitsu.common.compose.component.ToolbarViewState import jp.co.soramitsu.common.compose.component.WarningInfo import jp.co.soramitsu.common.compose.component.WarningInfoState import jp.co.soramitsu.common.compose.theme.FearlessTheme import jp.co.soramitsu.common.compose.theme.backgroundBlack import jp.co.soramitsu.common.compose.theme.black05 import jp.co.soramitsu.common.compose.theme.colorAccentDark import jp.co.soramitsu.common.compose.theme.white24 import jp.co.soramitsu.feature_wallet_impl.R</ID>
    <ID>ImportOrdering:SendSetupFragment.kt$import android.Manifest import android.graphics.Rect import android.os.Bundle import android.view.View import android.widget.FrameLayout import androidx.activity.result.ActivityResultLauncher import androidx.compose.foundation.layout.PaddingValues import androidx.compose.runtime.Composable import androidx.compose.runtime.collectAsState import androidx.compose.runtime.getValue import androidx.compose.ui.unit.Density import androidx.compose.ui.unit.dp import androidx.core.os.bundleOf import androidx.fragment.app.viewModels import androidx.lifecycle.lifecycleScope import com.google.android.material.bottomsheet.BottomSheetBehavior import com.journeyapps.barcodescanner.ScanOptions import dagger.hilt.android.AndroidEntryPoint import java.lang.Integer.max import jp.co.soramitsu.common.base.BaseComposeBottomSheetDialogFragment import jp.co.soramitsu.common.presentation.ErrorDialog import jp.co.soramitsu.common.scan.ScanTextContract import jp.co.soramitsu.common.scan.ScannerActivity import jp.co.soramitsu.wallet.impl.presentation.AssetPayload import jp.co.soramitsu.wallet.impl.presentation.common.askPermissionsSafely import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:SendSetupViewModel.kt$import androidx.compose.ui.unit.Dp import androidx.compose.ui.unit.dp import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import java.math.BigInteger import java.math.RoundingMode import javax.inject.Inject import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createAddressIcon import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.base.errors.ValidationException import jp.co.soramitsu.common.base.errors.ValidationWarning import jp.co.soramitsu.common.compose.component.AddressInputState import jp.co.soramitsu.common.compose.component.AmountInputViewState import jp.co.soramitsu.common.compose.component.ButtonViewState import jp.co.soramitsu.common.compose.component.FeeInfoViewState import jp.co.soramitsu.common.compose.component.SelectorState import jp.co.soramitsu.common.compose.component.ToolbarViewState import jp.co.soramitsu.common.compose.component.WarningInfoState import jp.co.soramitsu.common.resources.ClipboardManager import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.applyFiatRate import jp.co.soramitsu.common.utils.combine import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.isNotZero import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.utils.requireValue import jp.co.soramitsu.core.utils.isValidAddress import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.wallet.api.domain.TransferValidationResult import jp.co.soramitsu.wallet.api.domain.ValidateTransferUseCase import jp.co.soramitsu.wallet.api.domain.fromValidationResult import jp.co.soramitsu.wallet.impl.domain.CurrentAccountAddressUseCase import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletConstants import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.PhishingType import jp.co.soramitsu.wallet.impl.domain.model.Transfer import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import jp.co.soramitsu.wallet.impl.presentation.AssetPayload import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.balance.chainselector.ChainItemState import jp.co.soramitsu.wallet.impl.presentation.send.SendSharedState import jp.co.soramitsu.wallet.impl.presentation.send.TransferDraft import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.StateFlow import kotlinx.coroutines.flow.catch import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.firstOrNull import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.flow.retry import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:SetControllerFragment.kt$import androidx.fragment.app.viewModels import dagger.hilt.android.AndroidEntryPoint import jp.co.soramitsu.common.address.AddressChooserBottomSheetDialog import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.mixin.impl.observeValidations import jp.co.soramitsu.common.utils.setVisible import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListBottomSheet import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.account.api.presentation.actions.setupExternalActions import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.feature_staking_impl.databinding.FragmentSetControllerAccountBinding</ID>
    <ID>ImportOrdering:SetControllerViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.presentation.account.AddressDisplayUseCase import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.AppLinksProvider import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.mixin.api.RetryPayload import jp.co.soramitsu.common.mixin.api.Validatable import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.combine import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.mediatorLiveData import jp.co.soramitsu.common.utils.updateFrom import jp.co.soramitsu.common.validation.ValidationExecutor import jp.co.soramitsu.common.view.bottomSheet.list.dynamic.DynamicListBottomSheet.Payload import jp.co.soramitsu.feature_wallet_api.R import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import jp.co.soramitsu.staking.api.domain.model.StakingAccount import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.getSelectedChain import jp.co.soramitsu.staking.impl.domain.staking.controller.ControllerInteractor import jp.co.soramitsu.staking.impl.domain.validations.controller.SetControllerValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.controller.SetControllerValidationSystem import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.staking.controller.confirm.ConfirmSetControllerPayload import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioInteractor import jp.co.soramitsu.wallet.api.data.mappers.mapFeeToFeeModel import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeLoaderMixin import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeStatus import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.CancellationException import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.flow.filterIsInstance import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:SetupStakingFragment.kt$import androidx.compose.foundation.layout.WindowInsets import androidx.compose.foundation.layout.ime import androidx.compose.foundation.layout.imePadding import androidx.compose.runtime.collectAsState import androidx.compose.runtime.getValue import androidx.compose.ui.Modifier import androidx.compose.ui.platform.LocalDensity import androidx.compose.ui.platform.ViewCompositionStrategy import androidx.core.view.isVisible import androidx.fragment.app.viewModels import androidx.lifecycle.lifecycleScope import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import dev.chrisbanes.insetter.applyInsetter import javax.inject.Inject import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.compose.component.QuickAmountInput import jp.co.soramitsu.common.compose.component.QuickInput import jp.co.soramitsu.common.compose.theme.FearlessAppTheme import jp.co.soramitsu.common.mixin.impl.observeBrowserEvents import jp.co.soramitsu.common.mixin.impl.observeRetries import jp.co.soramitsu.common.mixin.impl.observeValidations import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.common.utils.hideSoftKeyboard import jp.co.soramitsu.common.view.bottomSheet.AlertBottomSheet import jp.co.soramitsu.common.view.setProgress import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.feature_staking_impl.databinding.FragmentSetupStakingBinding import jp.co.soramitsu.staking.impl.presentation.common.rewardDestination.observeRewardDestinationChooser import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeViews import jp.co.soramitsu.wallet.api.presentation.mixin.fee.displayFeeStatus</ID>
    <ID>ImportOrdering:SetupStakingPoolViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import java.math.BigInteger import javax.inject.Inject import jp.co.soramitsu.account.api.domain.model.address import jp.co.soramitsu.common.AlertViewState import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createAddressIcon import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.base.errors.ValidationException import jp.co.soramitsu.common.compose.component.AccountInfoViewState import jp.co.soramitsu.common.compose.component.AmountInputViewState import jp.co.soramitsu.common.compose.component.ButtonViewState import jp.co.soramitsu.common.compose.component.FeeInfoViewState import jp.co.soramitsu.common.compose.component.ToolbarViewState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.applyFiatRate import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.isNotZero import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.validation.AmountTooLowToStakeException import jp.co.soramitsu.common.validation.ExistentialDepositCrossedException import jp.co.soramitsu.common.validation.StakeInsufficientBalanceException import jp.co.soramitsu.common.validation.WaitForFeeCalculationException import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.wallet.api.domain.ExistentialDepositUseCase import jp.co.soramitsu.wallet.api.presentation.formatters.formatCryptoDetailFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.filterNotNull import kotlinx.coroutines.flow.flow import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:SetupStakingSharedState.kt$import android.util.Log import java.math.BigDecimal import jp.co.soramitsu.staking.api.data.StakingType import jp.co.soramitsu.staking.api.domain.model.Collator import jp.co.soramitsu.staking.api.domain.model.RewardDestination import jp.co.soramitsu.staking.api.domain.model.Validator import jp.co.soramitsu.staking.api.domain.model.WithAddress import jp.co.soramitsu.staking.impl.domain.recommendations.settings.filters.Filters import jp.co.soramitsu.staking.impl.domain.recommendations.settings.filters.Sorting import kotlinx.coroutines.flow.MutableStateFlow</ID>
    <ID>ImportOrdering:SetupStakingViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.liveData import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import java.math.BigInteger import javax.inject.Inject import javax.inject.Named import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createEthereumAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.mixin.api.Retriable import jp.co.soramitsu.common.mixin.api.Validatable import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.validation.ValidationExecutor import jp.co.soramitsu.common.validation.progressConsumer import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.core.utils.amountFromPlanks import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.api.domain.model.RewardDestination import jp.co.soramitsu.staking.impl.data.mappers.mapRewardDestinationModelToRewardDestination import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.rewards.RewardCalculatorFactory import jp.co.soramitsu.staking.impl.domain.setup.SetupStakingInteractor import jp.co.soramitsu.staking.impl.domain.validations.setup.SetupStakingPayload import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingSharedState import jp.co.soramitsu.staking.impl.presentation.common.rewardDestination.RewardDestinationMixin import jp.co.soramitsu.staking.impl.presentation.common.validation.stakingValidationFailure import jp.co.soramitsu.staking.impl.scenarios.StakingScenarioInteractor import jp.co.soramitsu.wallet.api.data.mappers.mapAssetToAssetModel import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeLoaderMixin import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeStatus import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.async import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.filterIsInstance import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.firstOrNull import kotlinx.coroutines.flow.flowOn import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:SoraRewardCalculator.kt$import java.math.BigDecimal import jp.co.soramitsu.common.utils.fractionToPercentage import jp.co.soramitsu.common.utils.median import jp.co.soramitsu.common.utils.sumByBigInteger import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.shared_utils.extensions.toHexString import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:SoraStakingRewardsScenario.kt$import java.math.BigInteger import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.core.rpc.RpcCalls import jp.co.soramitsu.core.rpc.calls.liquidityProxyQuote import jp.co.soramitsu.coredb.dao.TokenPriceDao import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.wallet.impl.domain.model.Token</ID>
    <ID>ImportOrdering:SplashViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.domain.GetEducationalStoriesUseCase import jp.co.soramitsu.common.domain.ShouldShowEducationalStoriesUseCase import jp.co.soramitsu.common.domain.model.StoryGroup import jp.co.soramitsu.common.presentation.StoryElement import jp.co.soramitsu.common.presentation.StoryGroupModel import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.splash.SplashRouter import kotlinx.coroutines.launch import javax.inject.Inject</ID>
    <ID>ImportOrdering:StakingConfirmViewModel.kt$import androidx.annotation.DrawableRes import androidx.annotation.StringRes import java.math.BigInteger import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.wallet.api.domain.ExistentialDepositUseCase import jp.co.soramitsu.wallet.api.presentation.BaseConfirmViewModel import jp.co.soramitsu.wallet.impl.domain.model.Asset</ID>
    <ID>ImportOrdering:StakingConstantsRepository.kt$import java.math.BigInteger import jp.co.soramitsu.common.utils.numberConstant import jp.co.soramitsu.common.utils.parachainStaking import jp.co.soramitsu.common.utils.staking import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.kusamaChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.polkadotChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.westendChainId import jp.co.soramitsu.runtime.multiNetwork.getRuntime</ID>
    <ID>ImportOrdering:StakingFeatureModule.kt$import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import javax.inject.Named import javax.inject.Singleton import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.presentation.account.AddressDisplayUseCase import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.data.memory.ComputationalCache import jp.co.soramitsu.common.data.network.AppLinksProvider import jp.co.soramitsu.common.data.network.NetworkApiCreator import jp.co.soramitsu.common.data.network.rpc.BulkRetriever import jp.co.soramitsu.common.data.storage.Preferences import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.core.extrinsic.ExtrinsicService import jp.co.soramitsu.core.extrinsic.mortality.IChainStateRepository import jp.co.soramitsu.core.rpc.RpcCalls import jp.co.soramitsu.core.storage.StorageCache import jp.co.soramitsu.coredb.dao.AccountStakingDao import jp.co.soramitsu.coredb.dao.StakingTotalRewardDao import jp.co.soramitsu.coredb.dao.TokenPriceDao import jp.co.soramitsu.runtime.di.LOCAL_STORAGE_SOURCE import jp.co.soramitsu.runtime.di.REMOTE_STORAGE_SOURCE import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.storage.source.StorageDataSource import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.api.domain.api.IdentityRepository import jp.co.soramitsu.staking.api.domain.api.StakingRepository import jp.co.soramitsu.staking.impl.data.network.subquery.StakingApi import jp.co.soramitsu.staking.impl.data.network.subquery.SubQueryDelegationHistoryFetcher import jp.co.soramitsu.staking.impl.data.network.subquery.SubQueryValidatorSetFetcher import jp.co.soramitsu.staking.impl.data.repository.IdentityRepositoryImpl import jp.co.soramitsu.staking.impl.data.repository.PayoutRepository import jp.co.soramitsu.staking.impl.data.repository.StakingConstantsRepository import jp.co.soramitsu.staking.impl.data.repository.StakingPoolApi import jp.co.soramitsu.staking.impl.data.repository.StakingPoolDataSource import jp.co.soramitsu.staking.impl.data.repository.StakingRepositoryImpl import jp.co.soramitsu.staking.impl.data.repository.StakingRewardsRepository import jp.co.soramitsu.staking.impl.data.repository.datasource.ParachainStakingStoriesDataSourceImpl import jp.co.soramitsu.staking.impl.data.repository.datasource.StakingRewardsDataSource import jp.co.soramitsu.staking.impl.data.repository.datasource.StakingStoriesDataSourceImpl import jp.co.soramitsu.staking.impl.data.repository.datasource.SubqueryStakingRewardsDataSource import jp.co.soramitsu.staking.impl.domain.EraTimeCalculatorFactory import jp.co.soramitsu.staking.impl.domain.GetIdentitiesUseCase import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.alerts.AlertsInteractor import jp.co.soramitsu.staking.impl.domain.payout.PayoutInteractor import jp.co.soramitsu.staking.impl.domain.recommendations.CollatorRecommendatorFactory import jp.co.soramitsu.staking.impl.domain.recommendations.ValidatorRecommendatorFactory import jp.co.soramitsu.staking.impl.domain.recommendations.settings.RecommendationSettingsProviderFactory import jp.co.soramitsu.staking.impl.domain.recommendations.settings.SettingsStorage import jp.co.soramitsu.staking.impl.domain.rewards.RewardCalculatorFactory import jp.co.soramitsu.staking.impl.domain.rewards.SoraStakingRewardsScenario import jp.co.soramitsu.staking.impl.domain.setup.SetupStakingInteractor import jp.co.soramitsu.staking.impl.domain.staking.bond.BondMoreInteractor import jp.co.soramitsu.staking.impl.domain.staking.controller.ControllerInteractor import jp.co.soramitsu.staking.impl.domain.staking.rebond.RebondInteractor import jp.co.soramitsu.staking.impl.domain.staking.redeem.RedeemInteractor import jp.co.soramitsu.staking.impl.domain.staking.rewardDestination.ChangeRewardDestinationInteractor import jp.co.soramitsu.staking.impl.domain.staking.unbond.UnbondInteractor import jp.co.soramitsu.staking.impl.domain.validators.CollatorProvider import jp.co.soramitsu.staking.impl.domain.validators.ValidatorProvider import jp.co.soramitsu.staking.impl.domain.validators.current.CurrentValidatorsInteractor import jp.co.soramitsu.staking.impl.domain.validators.current.search.SearchCustomBlockProducerInteractor import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingSharedState import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.presentation.common.rewardDestination.RewardDestinationMixin import jp.co.soramitsu.staking.impl.presentation.common.rewardDestination.RewardDestinationProvider import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.staking.impl.scenarios.parachain.StakingParachainScenarioInteractor import jp.co.soramitsu.staking.impl.scenarios.parachain.StakingParachainScenarioRepository import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioInteractor import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioRepository import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeLoaderMixin import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeLoaderProvider import jp.co.soramitsu.wallet.impl.domain.TokenUseCase import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletConstants import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletRepository import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.SupervisorJob</ID>
    <ID>ImportOrdering:StakingFragment.kt$import androidx.compose.foundation.layout.Column import androidx.compose.foundation.layout.Spacer import androidx.compose.foundation.layout.WindowInsets import androidx.compose.foundation.layout.fillMaxWidth import androidx.compose.foundation.layout.height import androidx.compose.foundation.layout.ime import androidx.compose.foundation.layout.padding import androidx.compose.runtime.collectAsState import androidx.compose.runtime.getValue import androidx.compose.ui.Modifier import androidx.compose.ui.platform.LocalDensity import androidx.compose.ui.platform.ViewCompositionStrategy import androidx.compose.ui.res.stringResource import androidx.compose.ui.unit.Dp import androidx.core.view.isVisible import androidx.fragment.app.viewModels import androidx.lifecycle.lifecycleScope import androidx.recyclerview.widget.LinearLayoutManager import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import dev.chrisbanes.insetter.applyInsetter import javax.inject.Inject import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.compose.component.AccentButton import jp.co.soramitsu.common.compose.component.AssetSelector import jp.co.soramitsu.common.compose.component.MarginVertical import jp.co.soramitsu.common.compose.component.QuickAmountInput import jp.co.soramitsu.common.compose.component.QuickInput import jp.co.soramitsu.common.compose.theme.FearlessAppTheme import jp.co.soramitsu.common.mixin.impl.observeValidations import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.presentation.StoryGroupModel import jp.co.soramitsu.common.utils.bindTo import jp.co.soramitsu.common.utils.hideSoftKeyboard import jp.co.soramitsu.common.utils.makeGone import jp.co.soramitsu.common.utils.makeVisible import jp.co.soramitsu.common.utils.setVisible import jp.co.soramitsu.common.view.dialog.infoDialog import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.feature_staking_impl.databinding.FragmentStakingBinding import jp.co.soramitsu.staking.api.data.StakingType import jp.co.soramitsu.staking.impl.domain.model.NominatorStatus import jp.co.soramitsu.staking.impl.domain.model.StashNoneStatus import jp.co.soramitsu.staking.impl.domain.model.ValidatorStatus import jp.co.soramitsu.staking.impl.presentation.staking.main.compose.EstimatedEarnings import jp.co.soramitsu.staking.impl.presentation.staking.main.compose.StakingAssetInfo import jp.co.soramitsu.staking.impl.presentation.staking.main.compose.StakingPoolInfo import jp.co.soramitsu.staking.impl.presentation.staking.main.model.StakingNetworkInfoModel import jp.co.soramitsu.staking.impl.presentation.view.DelegationOptionsBottomSheet import jp.co.soramitsu.staking.impl.presentation.view.DelegationRecyclerViewAdapter import jp.co.soramitsu.staking.impl.presentation.view.StakeSummaryView import kotlinx.coroutines.Job import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.distinctUntilChanged import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:StakingInteractor.kt$import java.math.BigDecimal import java.math.BigInteger import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.domain.model.MetaAccount import jp.co.soramitsu.account.api.domain.model.accountId import jp.co.soramitsu.account.api.domain.model.address import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.address.createEthereumAddressModel import jp.co.soramitsu.common.data.network.runtime.binding.AccountInfo import jp.co.soramitsu.common.data.network.runtime.binding.BlockNumber import jp.co.soramitsu.common.utils.Modules import jp.co.soramitsu.common.utils.balances import jp.co.soramitsu.common.utils.combineToPair import jp.co.soramitsu.common.utils.numberConstant import jp.co.soramitsu.core.extrinsic.mortality.IChainStateRepository import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.runtime.ext.accountIdOf import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.polkadotChainId import jp.co.soramitsu.shared_utils.extensions.toHexString import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.shared_utils.runtime.metadata.RuntimeMetadata import jp.co.soramitsu.shared_utils.runtime.metadata.module import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.api.domain.api.StakingRepository import jp.co.soramitsu.staking.api.domain.model.StakingAccount import jp.co.soramitsu.staking.impl.data.mappers.mapAccountToStakingAccount import jp.co.soramitsu.staking.impl.data.repository.StakingRewardsRepository import jp.co.soramitsu.staking.impl.domain.validations.setup.SetupStakingFeeValidation import jp.co.soramitsu.staking.impl.domain.validations.setup.SetupStakingValidationFailure import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletRepository import jp.co.soramitsu.wallet.impl.domain.model.ControllerDeprecationWarning import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import jp.co.soramitsu.wallet.impl.domain.validation.EnoughToPayFeesValidation import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.debounce import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:StakingParachainScenarioInteractor.kt$import java.math.BigDecimal import java.math.BigInteger import java.util.Optional import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.domain.model.MetaAccount import jp.co.soramitsu.account.api.domain.model.accountId import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.address.createEthereumAddressModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.utils.sumByBigInteger import jp.co.soramitsu.common.validation.CompositeValidation import jp.co.soramitsu.common.validation.ValidationSystem import jp.co.soramitsu.core.models.Asset.StakingType import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.ext.accountIdOf import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.polkadotChainId import jp.co.soramitsu.runtime.state.SingleAssetSharedState import jp.co.soramitsu.shared_utils.extensions.fromHex import jp.co.soramitsu.shared_utils.extensions.requireHexPrefix import jp.co.soramitsu.shared_utils.extensions.toHexString import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.shared_utils.runtime.extrinsic.ExtrinsicBuilder import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.api.domain.api.AccountIdMap import jp.co.soramitsu.staking.api.domain.api.IdentityRepository import jp.co.soramitsu.staking.api.domain.model.AtStake import jp.co.soramitsu.staking.api.domain.model.BlockNumber import jp.co.soramitsu.staking.api.domain.model.CandidateInfo import jp.co.soramitsu.staking.api.domain.model.Delegation import jp.co.soramitsu.staking.api.domain.model.DelegationScheduledRequest import jp.co.soramitsu.staking.api.domain.model.Identity import jp.co.soramitsu.staking.api.domain.model.RewardDestination import jp.co.soramitsu.staking.api.domain.model.Round import jp.co.soramitsu.staking.api.domain.model.StakingLedger import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.data.network.blockhain.calls.parachainCancelDelegationRequest import jp.co.soramitsu.staking.impl.data.network.blockhain.calls.parachainCandidateBondMore import jp.co.soramitsu.staking.impl.data.network.blockhain.calls.parachainDelegatorBondMore import jp.co.soramitsu.staking.impl.data.network.blockhain.calls.parachainExecuteDelegationRequest import jp.co.soramitsu.staking.impl.data.network.blockhain.calls.parachainScheduleCandidateBondLess import jp.co.soramitsu.staking.impl.data.network.blockhain.calls.parachainScheduleDelegatorBondLess import jp.co.soramitsu.staking.impl.data.network.blockhain.calls.parachainScheduleRevokeDelegation import jp.co.soramitsu.staking.impl.data.network.subquery.SubQueryDelegationHistoryFetcher import jp.co.soramitsu.staking.impl.data.repository.StakingConstantsRepository import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.getSelectedChain import jp.co.soramitsu.staking.impl.domain.model.NetworkInfo import jp.co.soramitsu.staking.impl.domain.model.Unbonding import jp.co.soramitsu.staking.impl.domain.model.toUnbonding import jp.co.soramitsu.staking.impl.domain.validations.balance.BalanceUnlockingLimitValidation import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.bond.BondMoreValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.bond.BondMoreValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.bond.BondMoreValidationSystem import jp.co.soramitsu.staking.impl.domain.validations.bond.NotZeroBondValidation import jp.co.soramitsu.staking.impl.domain.validations.rebond.NotZeroRebondValidation import jp.co.soramitsu.staking.impl.domain.validations.rebond.RebondFeeValidation import jp.co.soramitsu.staking.impl.domain.validations.rebond.RebondValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.rebond.RebondValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.rebond.RebondValidationSystem import jp.co.soramitsu.staking.impl.domain.validations.reedeem.RedeemFeeValidation import jp.co.soramitsu.staking.impl.domain.validations.reedeem.RedeemValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.reedeem.RedeemValidationSystem import jp.co.soramitsu.staking.impl.domain.validations.setup.MinimumAmountValidation import jp.co.soramitsu.staking.impl.domain.validations.setup.SetupStakingFeeValidation import jp.co.soramitsu.staking.impl.domain.validations.setup.SetupStakingMaximumNominatorsValidation import jp.co.soramitsu.staking.impl.domain.validations.setup.SetupStakingPayload import jp.co.soramitsu.staking.impl.domain.validations.setup.SetupStakingValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.unbond.CrossExistentialValidation import jp.co.soramitsu.staking.impl.domain.validations.unbond.EnoughToUnbondValidation import jp.co.soramitsu.staking.impl.domain.validations.unbond.NotZeroUnbondValidation import jp.co.soramitsu.staking.impl.domain.validations.unbond.UnbondFeeValidation import jp.co.soramitsu.staking.impl.domain.validations.unbond.UnbondLimitValidation import jp.co.soramitsu.staking.impl.domain.validations.unbond.UnbondValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.unbond.UnbondValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.unbond.UnbondValidationSystem import jp.co.soramitsu.staking.impl.presentation.staking.balance.model.StakingBalanceModel import jp.co.soramitsu.staking.impl.presentation.staking.balance.rebond.RebondKind import jp.co.soramitsu.staking.impl.scenarios.StakingScenarioInteractor import jp.co.soramitsu.wallet.api.presentation.model.mapAmountToAmountModel import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletRepository import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import jp.co.soramitsu.wallet.impl.domain.validation.EnoughToPayFeesValidation import jp.co.soramitsu.wallet.impl.domain.validation.assetBalanceProducer import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.channelFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.emitAll import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.filterIsInstance import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.flow import kotlinx.coroutines.flow.flowOf import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.onStart import jp.co.soramitsu.core.models.Asset as CoreAsset</ID>
    <ID>ImportOrdering:StakingParachainScenarioViewModel.kt$import java.math.BigDecimal import jp.co.soramitsu.common.domain.model.StoryGroup import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.withLoading import jp.co.soramitsu.common.validation.CompositeValidation import jp.co.soramitsu.common.validation.ValidationSystem import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.shared_utils.extensions.fromHex import jp.co.soramitsu.shared_utils.extensions.requireHexPrefix import jp.co.soramitsu.shared_utils.extensions.toHexString import jp.co.soramitsu.staking.api.domain.model.DelegatorStateStatus import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.data.repository.datasource.ParachainStakingStoriesDataSourceImpl import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.alerts.Alert import jp.co.soramitsu.staking.impl.domain.model.NetworkInfo import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationPayload import jp.co.soramitsu.staking.impl.presentation.staking.alerts.model.AlertModel import jp.co.soramitsu.staking.impl.presentation.staking.main.StakingViewState import jp.co.soramitsu.staking.impl.presentation.staking.main.StakingViewStateOld import jp.co.soramitsu.staking.impl.presentation.staking.main.di.StakingViewStateFactory import jp.co.soramitsu.staking.impl.presentation.staking.main.model.StakingNetworkInfoModel import jp.co.soramitsu.staking.impl.scenarios.parachain.StakingParachainScenarioInteractor import jp.co.soramitsu.staking.impl.scenarios.relaychain.HOURS_IN_DAY import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.emptyFlow import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.shareIn</ID>
    <ID>ImportOrdering:StakingPoolInteractor.kt$import java.math.BigInteger import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.domain.model.accountId import jp.co.soramitsu.common.list.GroupedList import jp.co.soramitsu.common.list.emptyGroupedList import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.runtime.ext.accountFromMapKey import jp.co.soramitsu.runtime.ext.accountIdOf import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.shared_utils.extensions.toHexString import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.shared_utils.ss58.SS58Encoder import jp.co.soramitsu.shared_utils.ss58.SS58Encoder.toAccountId import jp.co.soramitsu.staking.api.domain.api.IdentityRepository import jp.co.soramitsu.staking.api.domain.model.Identity import jp.co.soramitsu.staking.api.domain.model.NominatedValidator import jp.co.soramitsu.staking.api.domain.model.NominationPoolState import jp.co.soramitsu.staking.api.domain.model.Nominations import jp.co.soramitsu.staking.api.domain.model.OwnPool import jp.co.soramitsu.staking.api.domain.model.PoolInfo import jp.co.soramitsu.staking.api.domain.model.PoolUnbonding import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.data.model.BondedPool import jp.co.soramitsu.staking.impl.data.model.PoolMember import jp.co.soramitsu.staking.impl.data.model.PoolRewards import jp.co.soramitsu.staking.impl.data.repository.StakingPoolApi import jp.co.soramitsu.staking.impl.data.repository.StakingPoolDataSource import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.getSelectedChain import jp.co.soramitsu.staking.impl.domain.validators.current.CurrentValidatorsInteractor import jp.co.soramitsu.staking.impl.presentation.common.EditPoolFlowState import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioRepository import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletConstants import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.ExperimentalCoroutinesApi import kotlinx.coroutines.FlowPreview import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.distinctUntilChanged import kotlinx.coroutines.flow.emptyFlow import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.filterNotNull import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.flattenMerge import kotlinx.coroutines.flow.flowOf import kotlinx.coroutines.flow.map import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:StakingPoolViewModel.kt$import java.math.BigDecimal import jp.co.soramitsu.common.compose.component.AmountInputViewState import jp.co.soramitsu.common.compose.component.TitleValueViewState import jp.co.soramitsu.common.domain.model.StoryGroup import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.applyFiatRate import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.nullIfEmpty import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.utils.withLoading import jp.co.soramitsu.common.validation.CompositeValidation import jp.co.soramitsu.common.validation.ValidationSystem import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.multiNetwork.chain.model.polkadotChainId import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.rewards.RewardCalculatorFactory import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationPayload import jp.co.soramitsu.staking.impl.presentation.mappers.mapPeriodReturnsToRewardEstimation import jp.co.soramitsu.staking.impl.presentation.staking.alerts.model.AlertModel import jp.co.soramitsu.staking.impl.presentation.staking.main.Pool import jp.co.soramitsu.staking.impl.presentation.staking.main.ReturnsModel import jp.co.soramitsu.staking.impl.presentation.staking.main.StakingViewState import jp.co.soramitsu.staking.impl.presentation.staking.main.StakingViewStateOld import jp.co.soramitsu.staking.impl.presentation.staking.main.compose.EstimatedEarningsViewState import jp.co.soramitsu.staking.impl.presentation.staking.main.compose.toViewState import jp.co.soramitsu.staking.impl.presentation.staking.main.default import jp.co.soramitsu.staking.impl.presentation.staking.main.model.StakingNetworkInfoModel import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.emptyFlow import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn</ID>
    <ID>ImportOrdering:StakingRelayChainScenarioInteractor.kt$import java.math.BigDecimal import java.math.BigInteger import java.util.Optional import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.domain.model.MetaAccount import jp.co.soramitsu.account.api.domain.model.accountId import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.utils.sumByBigInteger import jp.co.soramitsu.common.validation.CompositeValidation import jp.co.soramitsu.common.validation.ValidationSystem import jp.co.soramitsu.core.models.Asset.StakingType import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.ext.accountIdOf import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.state.SingleAssetSharedState import jp.co.soramitsu.shared_utils.extensions.toHexString import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.shared_utils.runtime.extrinsic.ExtrinsicBuilder import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.api.domain.api.AccountIdMap import jp.co.soramitsu.staking.api.domain.api.IdentityRepository import jp.co.soramitsu.staking.api.domain.model.DelegationAction import jp.co.soramitsu.staking.api.domain.model.Exposure import jp.co.soramitsu.staking.api.domain.model.IndividualExposure import jp.co.soramitsu.staking.api.domain.model.RewardDestination import jp.co.soramitsu.staking.api.domain.model.StakingLedger import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.api.domain.model.isUnbondingIn import jp.co.soramitsu.staking.impl.data.model.Payout import jp.co.soramitsu.staking.impl.data.network.blockhain.calls.bondMore import jp.co.soramitsu.staking.impl.data.network.blockhain.calls.chill import jp.co.soramitsu.staking.impl.data.network.blockhain.calls.rebond import jp.co.soramitsu.staking.impl.data.network.blockhain.calls.unbond import jp.co.soramitsu.staking.impl.data.network.blockhain.calls.withdrawUnbonded import jp.co.soramitsu.staking.impl.data.repository.PayoutRepository import jp.co.soramitsu.staking.impl.data.repository.StakingConstantsRepository import jp.co.soramitsu.staking.impl.data.repository.StakingRewardsRepository import jp.co.soramitsu.staking.impl.domain.EraTimeCalculator import jp.co.soramitsu.staking.impl.domain.EraTimeCalculatorFactory import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.common.isWaiting import jp.co.soramitsu.staking.impl.domain.isNominationActive import jp.co.soramitsu.staking.impl.domain.minimumStake import jp.co.soramitsu.staking.impl.domain.model.NetworkInfo import jp.co.soramitsu.staking.impl.domain.model.NominatorStatus import jp.co.soramitsu.staking.impl.domain.model.PendingPayout import jp.co.soramitsu.staking.impl.domain.model.PendingPayoutsStatistics import jp.co.soramitsu.staking.impl.domain.model.StakeSummary import jp.co.soramitsu.staking.impl.domain.model.StashNoneStatus import jp.co.soramitsu.staking.impl.domain.model.Unbonding import jp.co.soramitsu.staking.impl.domain.model.ValidatorStatus import jp.co.soramitsu.staking.impl.domain.validations.balance.BalanceAccountRequiredValidation import jp.co.soramitsu.staking.impl.domain.validations.balance.BalanceUnlockingLimitValidation import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.bond.BondMoreValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.bond.BondMoreValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.bond.BondMoreValidationSystem import jp.co.soramitsu.staking.impl.domain.validations.bond.NotZeroBondValidation import jp.co.soramitsu.staking.impl.domain.validations.rebond.EnoughToRebondValidation import jp.co.soramitsu.staking.impl.domain.validations.rebond.NotZeroRebondValidation import jp.co.soramitsu.staking.impl.domain.validations.rebond.RebondFeeValidation import jp.co.soramitsu.staking.impl.domain.validations.rebond.RebondValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.rebond.RebondValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.rebond.RebondValidationSystem import jp.co.soramitsu.staking.impl.domain.validations.reedeem.RedeemFeeValidation import jp.co.soramitsu.staking.impl.domain.validations.reedeem.RedeemValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.reedeem.RedeemValidationSystem import jp.co.soramitsu.staking.impl.domain.validations.setup.MinimumAmountValidation import jp.co.soramitsu.staking.impl.domain.validations.setup.SetupStakingMaximumNominatorsValidation import jp.co.soramitsu.staking.impl.domain.validations.setup.SetupStakingPayload import jp.co.soramitsu.staking.impl.domain.validations.setup.SetupStakingValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.unbond.ControllerCanPayFeeValidation import jp.co.soramitsu.staking.impl.domain.validations.unbond.CrossExistentialValidation import jp.co.soramitsu.staking.impl.domain.validations.unbond.EnoughToUnbondValidation import jp.co.soramitsu.staking.impl.domain.validations.unbond.NotZeroUnbondValidation import jp.co.soramitsu.staking.impl.domain.validations.unbond.UnbondFeeValidation import jp.co.soramitsu.staking.impl.domain.validations.unbond.UnbondLimitValidation import jp.co.soramitsu.staking.impl.domain.validations.unbond.UnbondValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.unbond.UnbondValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.unbond.UnbondValidationSystem import jp.co.soramitsu.staking.impl.presentation.staking.balance.model.StakingBalanceModel import jp.co.soramitsu.staking.impl.presentation.staking.balance.rebond.RebondKind import jp.co.soramitsu.staking.impl.scenarios.StakingScenarioInteractor import jp.co.soramitsu.wallet.api.presentation.model.mapAmountToAmountModel import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletConstants import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletRepository import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import jp.co.soramitsu.wallet.impl.domain.validation.EnoughToPayFeesValidation import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.distinctUntilChanged import kotlinx.coroutines.flow.emitAll import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.filterIsInstance import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.firstOrNull import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.flow import kotlinx.coroutines.flow.flowOf import kotlinx.coroutines.flow.flowOn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.flow.onStart import kotlinx.coroutines.withContext import jp.co.soramitsu.core.models.Asset as CoreAsset</ID>
    <ID>ImportOrdering:StakingRelayChainScenarioRepository.kt$import java.math.BigInteger import jp.co.soramitsu.common.data.network.runtime.binding.NonNullBinderWithType import jp.co.soramitsu.common.data.network.runtime.binding.incompatible import jp.co.soramitsu.common.utils.Modules import jp.co.soramitsu.common.utils.accountIdFromMapKey import jp.co.soramitsu.common.utils.babe import jp.co.soramitsu.common.utils.constant import jp.co.soramitsu.common.utils.mapValuesNotNull import jp.co.soramitsu.common.utils.nominationPools import jp.co.soramitsu.common.utils.numberConstant import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.utils.session import jp.co.soramitsu.common.utils.staking import jp.co.soramitsu.common.utils.stakingOrNull import jp.co.soramitsu.common.utils.storageKeys import jp.co.soramitsu.common.utils.u32ArgumentFromStorageKey import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.core.runtime.storage.returnType import jp.co.soramitsu.coredb.dao.AccountStakingDao import jp.co.soramitsu.coredb.model.AccountStakingLocal import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.storage.source.StorageDataSource import jp.co.soramitsu.runtime.storage.source.observeNonNull import jp.co.soramitsu.runtime.storage.source.queryNonNull import jp.co.soramitsu.shared_utils.extensions.fromHex import jp.co.soramitsu.shared_utils.extensions.toHexString import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.shared_utils.runtime.definitions.types.fromByteArrayOrNull import jp.co.soramitsu.shared_utils.runtime.definitions.types.fromHex import jp.co.soramitsu.shared_utils.runtime.metadata.moduleOrNull import jp.co.soramitsu.shared_utils.runtime.metadata.storage import jp.co.soramitsu.shared_utils.runtime.metadata.storageKey import jp.co.soramitsu.shared_utils.runtime.metadata.storageOrNull import jp.co.soramitsu.shared_utils.ss58.SS58Encoder.toAccountId import jp.co.soramitsu.staking.api.domain.api.AccountIdMap import jp.co.soramitsu.staking.api.domain.model.EraIndex import jp.co.soramitsu.staking.api.domain.model.Exposure import jp.co.soramitsu.staking.api.domain.model.Nominations import jp.co.soramitsu.staking.api.domain.model.SlashingSpans import jp.co.soramitsu.staking.api.domain.model.StakingLedger import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.api.domain.model.ValidatorPrefs import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindActiveEra import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindCurrentEra import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindCurrentIndex import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindCurrentSlot import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindErasStartSessionIndex import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindExposure import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindHistoryDepth import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindMaxNominators import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindMinBond import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindNominations import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindNominatorsCount import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindRewardDestination import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindSlashDeferDuration import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindSlashingSpans import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindStakingLedger import jp.co.soramitsu.staking.impl.data.network.blockhain.bindings.bindValidatorPrefs import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.activeEraStorageKeyOrNull import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletConstants import kotlin.math.floor import kotlin.math.max import kotlin.time.DurationUnit import kotlin.time.toDuration import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.emptyFlow import kotlinx.coroutines.flow.filterNotNull import kotlinx.coroutines.flow.firstOrNull import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.flowOf import kotlinx.coroutines.flow.mapLatest import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:StakingRelaychainScenarioViewModel.kt$import java.math.BigDecimal import jp.co.soramitsu.common.domain.model.StoryGroup import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.mapList import jp.co.soramitsu.common.utils.withLoading import jp.co.soramitsu.common.validation.CompositeValidation import jp.co.soramitsu.common.validation.ValidationSystem import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.shared_utils.extensions.toHexString import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.data.repository.datasource.StakingStoriesDataSource import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.alerts.Alert import jp.co.soramitsu.staking.impl.domain.alerts.AlertsInteractor import jp.co.soramitsu.staking.impl.domain.model.NetworkInfo import jp.co.soramitsu.staking.impl.domain.validations.balance.BalanceAccountRequiredValidation import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.welcome.WelcomeStakingMaxNominatorsValidation import jp.co.soramitsu.staking.impl.domain.validations.welcome.WelcomeStakingValidationFailure import jp.co.soramitsu.staking.impl.presentation.staking.alerts.model.AlertModel import jp.co.soramitsu.staking.impl.presentation.staking.main.StakingViewState import jp.co.soramitsu.staking.impl.presentation.staking.main.StakingViewStateOld import jp.co.soramitsu.staking.impl.presentation.staking.main.di.StakingViewStateFactory import jp.co.soramitsu.staking.impl.presentation.staking.main.model.StakingNetworkInfoModel import jp.co.soramitsu.staking.impl.presentation.staking.main.scenarios.StakingScenarioViewModel.Companion.WAITING_ICON import jp.co.soramitsu.staking.impl.presentation.staking.main.scenarios.StakingScenarioViewModel.Companion.WARNING_ICON import jp.co.soramitsu.staking.impl.scenarios.relaychain.HOURS_IN_DAY import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioInteractor import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.distinctUntilChanged import kotlinx.coroutines.flow.emptyFlow import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.shareIn</ID>
    <ID>ImportOrdering:StakingRewardsDataSource.kt$import jp.co.soramitsu.staking.impl.domain.model.TotalReward import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import kotlinx.coroutines.flow.Flow</ID>
    <ID>ImportOrdering:StakingRewardsRepository.kt$import jp.co.soramitsu.staking.impl.data.repository.datasource.StakingRewardsDataSource import jp.co.soramitsu.staking.impl.domain.model.TotalReward import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import kotlinx.coroutines.flow.Flow</ID>
    <ID>ImportOrdering:StakingScenarioInteractor.kt$import java.math.BigDecimal import java.math.BigInteger import java.util.Optional import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.validation.ValidationSystem import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.shared_utils.runtime.extrinsic.ExtrinsicBuilder import jp.co.soramitsu.staking.api.domain.model.RewardDestination import jp.co.soramitsu.staking.api.domain.model.StakingLedger import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.domain.model.NetworkInfo import jp.co.soramitsu.staking.impl.domain.model.Unbonding import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.bond.BondMoreValidationSystem import jp.co.soramitsu.staking.impl.domain.validations.rebond.RebondValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.rebond.RebondValidationSystem import jp.co.soramitsu.staking.impl.domain.validations.reedeem.RedeemValidationSystem import jp.co.soramitsu.staking.impl.domain.validations.setup.SetupStakingPayload import jp.co.soramitsu.staking.impl.domain.validations.setup.SetupStakingValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.unbond.UnbondValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.unbond.UnbondValidationSystem import jp.co.soramitsu.staking.impl.presentation.staking.balance.model.StakingBalanceModel import jp.co.soramitsu.staking.impl.presentation.staking.balance.rebond.RebondKind import jp.co.soramitsu.wallet.impl.domain.model.Asset import kotlinx.coroutines.flow.Flow import jp.co.soramitsu.core.models.Asset as CoreAsset</ID>
    <ID>ImportOrdering:StakingScenarioViewModel.kt$import java.math.BigDecimal import jp.co.soramitsu.common.domain.model.StoryGroup import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.validation.ValidationSystem import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationFailure import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationPayload import jp.co.soramitsu.staking.impl.presentation.staking.alerts.model.AlertModel import jp.co.soramitsu.staking.impl.presentation.staking.main.StakingViewState import jp.co.soramitsu.staking.impl.presentation.staking.main.StakingViewStateOld import jp.co.soramitsu.staking.impl.presentation.staking.main.model.StakingNetworkInfoModel import jp.co.soramitsu.wallet.impl.domain.model.Token import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow</ID>
    <ID>ImportOrdering:StakingUpdatersModule.kt$import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.components.SingletonComponent import javax.inject.Named import javax.inject.Singleton import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.domain.updaters.AccountUpdateScope import jp.co.soramitsu.common.data.network.rpc.BulkRetriever import jp.co.soramitsu.common.mixin.api.UpdatesMixin import jp.co.soramitsu.core.storage.StorageCache import jp.co.soramitsu.core.updater.UpdateSystem import jp.co.soramitsu.coredb.dao.AccountStakingDao import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.network.updaters.BlockNumberUpdater import jp.co.soramitsu.runtime.network.updaters.SingleChainUpdateSystem import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.AccountNominationsUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.AccountRewardDestinationUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.AccountValidatorPrefsUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.ActiveEraUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.CounterForNominatorsUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.CurrentEraUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.DelegatorStateUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.HistoryDepthUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.MaxNominatorsUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.MinBondUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.StakingLedgerUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.TotalIssuanceUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.ValidatorExposureUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.controller.AccountControllerBalanceUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.historical.HistoricalTotalValidatorRewardUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.historical.HistoricalUpdateMediator import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.historical.HistoricalValidatorRewardPointsUpdater import jp.co.soramitsu.staking.impl.data.network.blockhain.updaters.scope.AccountStakingScope import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioRepository import jp.co.soramitsu.wallet.api.data.cache.AssetCache import kotlinx.coroutines.flow.map</ID>
    <ID>ImportOrdering:StakingViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import javax.inject.Inject import javax.inject.Named import jp.co.soramitsu.account.api.domain.model.address import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.AssetSelectorState import jp.co.soramitsu.common.domain.model.StoryGroup import jp.co.soramitsu.common.mixin.api.Validatable import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.presentation.StakingStoryModel import jp.co.soramitsu.common.presentation.StoryElement import jp.co.soramitsu.common.presentation.StoryGroupModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.childScope import jp.co.soramitsu.common.utils.formatAsPercentage import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.utils.withLoading import jp.co.soramitsu.common.validation.ValidationExecutor import jp.co.soramitsu.core.updater.UpdateSystem import jp.co.soramitsu.core.utils.amountFromPlanks import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.api.data.StakingAssetSelection import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.api.data.StakingType import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.data.repository.datasource.ParachainStakingStoriesDataSourceImpl import jp.co.soramitsu.staking.impl.data.repository.datasource.StakingStoriesDataSourceImpl import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.alerts.AlertsInteractor import jp.co.soramitsu.staking.impl.domain.getSelectedChain import jp.co.soramitsu.staking.impl.domain.rewards.RewardCalculatorFactory import jp.co.soramitsu.staking.impl.domain.setup.SetupStakingInteractor import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.balance.ManageStakingValidationSystem import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingSharedState import jp.co.soramitsu.staking.impl.presentation.common.StakingAssetSelector import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolState import jp.co.soramitsu.staking.impl.presentation.staking.balance.manageStakingActionValidationFailure import jp.co.soramitsu.staking.impl.presentation.staking.bond.select.SelectBondMorePayload import jp.co.soramitsu.staking.impl.presentation.staking.main.compose.EstimatedEarningsViewState import jp.co.soramitsu.staking.impl.presentation.staking.main.compose.StakeInfoViewState import jp.co.soramitsu.staking.impl.presentation.staking.main.compose.StakingAssetInfoViewState import jp.co.soramitsu.staking.impl.presentation.staking.main.compose.default import jp.co.soramitsu.staking.impl.presentation.staking.main.compose.update import jp.co.soramitsu.staking.impl.presentation.staking.main.di.StakingViewStateFactory import jp.co.soramitsu.staking.impl.presentation.staking.main.model.StakingNetworkInfoModel import jp.co.soramitsu.staking.impl.presentation.staking.main.scenarios.BaseStakingViewModel import jp.co.soramitsu.staking.impl.presentation.staking.main.scenarios.StakingScenario import jp.co.soramitsu.staking.impl.presentation.staking.redeem.RedeemPayload import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.staking.impl.scenarios.parachain.StakingParachainScenarioInteractor import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioInteractor import jp.co.soramitsu.wallet.impl.presentation.model.ControllerDeprecationWarningModel import jp.co.soramitsu.wallet.impl.presentation.model.toModel import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.cancelChildren import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharedFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.debounce import kotlinx.coroutines.flow.distinctUntilChanged import kotlinx.coroutines.flow.filterIsInstance import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.flatMapConcat import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.flow.shareIn import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:StakingViewStateOld.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import java.math.BigDecimal import java.math.BigInteger import jp.co.soramitsu.common.base.TitleAndMessage import jp.co.soramitsu.common.mixin.api.Validatable import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.applyFiatRate import jp.co.soramitsu.common.utils.asLiveData import jp.co.soramitsu.common.utils.formatAsPercentage import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.utils.withLoading import jp.co.soramitsu.common.validation.ValidationExecutor import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.ext.accountFromMapKey import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.shared_utils.extensions.toHexString import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.staking.api.domain.model.CandidateInfo import jp.co.soramitsu.staking.api.domain.model.CandidateInfoStatus import jp.co.soramitsu.staking.api.domain.model.Round import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.getSelectedChain import jp.co.soramitsu.staking.impl.domain.model.DelegatorStatus import jp.co.soramitsu.staking.impl.domain.model.NominatorStatus import jp.co.soramitsu.staking.impl.domain.model.NominatorStatus.Inactive.Reason import jp.co.soramitsu.staking.impl.domain.model.StakeSummary import jp.co.soramitsu.staking.impl.domain.model.StashNoneStatus import jp.co.soramitsu.staking.impl.domain.model.ValidatorStatus import jp.co.soramitsu.staking.impl.domain.rewards.RewardCalculator import jp.co.soramitsu.staking.impl.domain.rewards.RewardCalculatorFactory import jp.co.soramitsu.staking.impl.domain.rewards.SoraStakingRewardsScenario import jp.co.soramitsu.staking.impl.domain.validations.welcome.WelcomeStakingValidationPayload import jp.co.soramitsu.staking.impl.domain.validations.welcome.WelcomeStakingValidationSystem import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingSharedState import jp.co.soramitsu.staking.impl.presentation.mappers.mapPeriodReturnsToRewardEstimation import jp.co.soramitsu.staking.impl.presentation.staking.main.model.RewardEstimation import jp.co.soramitsu.staking.impl.presentation.staking.main.scenarios.PERIOD_MONTH import jp.co.soramitsu.staking.impl.presentation.staking.main.scenarios.PERIOD_YEAR import jp.co.soramitsu.staking.impl.presentation.validators.parcel.CollatorDetailsParcelModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.CollatorStakeParcelModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.IdentityParcelModel import jp.co.soramitsu.staking.impl.scenarios.parachain.StakingParachainScenarioInteractor import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioInteractor import jp.co.soramitsu.wallet.api.data.mappers.mapAssetToAssetModel import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Deferred import kotlinx.coroutines.async import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.cancellable import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.distinctUntilChanged import kotlinx.coroutines.flow.emptyFlow import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.filterIsInstance import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.flow.shareIn import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch import jp.co.soramitsu.core.models.Asset as CoreAsset</ID>
    <ID>ImportOrdering:StartChangeCollatorsViewModel.kt$import androidx.lifecycle.MutableLiveData import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.mixin.api.Browserable import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.invoke import jp.co.soramitsu.common.utils.lazyAsync import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.api.domain.model.Collator import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.recommendations.CollatorRecommendatorFactory import jp.co.soramitsu.staking.impl.domain.recommendations.settings.RecommendationSettings import jp.co.soramitsu.staking.impl.domain.recommendations.settings.RecommendationSettingsProvider import jp.co.soramitsu.staking.impl.domain.recommendations.settings.RecommendationSettingsProviderFactory import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingSharedState import jp.co.soramitsu.staking.impl.scenarios.parachain.StakingParachainScenarioInteractor import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import kotlinx.coroutines.Deferred import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.emitAll import kotlinx.coroutines.flow.filterNotNull import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.flow import kotlinx.coroutines.flow.map import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:StartChangeValidatorsViewModel.kt$import androidx.lifecycle.MutableLiveData import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.mixin.api.Browserable import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.impl.domain.recommendations.ValidatorRecommendatorFactory import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingProcess import jp.co.soramitsu.staking.impl.presentation.common.SetupStakingSharedState import jp.co.soramitsu.staking.impl.presentation.validators.change.retractValidators import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioInteractor import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.transform import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:StartSelectValidatorsViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.common.AlertViewState import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.SelectValidatorsVariantPanelViewState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.staking.impl.domain.recommendations.ValidatorRecommendatorFactory import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.SelectValidatorFlowState import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:StartStakingPoolViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import javax.inject.Inject import jp.co.soramitsu.common.AlertViewState import jp.co.soramitsu.common.BuildConfig import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.ToolbarViewState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.chain.model.polkadotChainId import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.impl.domain.rewards.RewardCalculatorFactory import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolCreateFlowState import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolJoinFlowState import jp.co.soramitsu.staking.impl.presentation.common.StakingPoolSharedStateProvider import jp.co.soramitsu.staking.impl.presentation.mappers.mapPeriodReturnsToRewardEstimation import jp.co.soramitsu.staking.impl.presentation.staking.main.scenarios.PERIOD_YEAR import jp.co.soramitsu.staking.impl.scenarios.StakingPoolInteractor import jp.co.soramitsu.staking.impl.scenarios.relaychain.HOURS_IN_DAY import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioInteractor import jp.co.soramitsu.wallet.impl.domain.model.Asset import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.stateIn</ID>
    <ID>ImportOrdering:SubstrateRemoteSource.kt$import java.math.BigInteger import jp.co.soramitsu.common.data.network.runtime.binding.AssetsAccountInfo import jp.co.soramitsu.common.data.network.runtime.binding.EqAccountInfo import jp.co.soramitsu.common.data.network.runtime.binding.EqOraclePricePoint import jp.co.soramitsu.common.data.network.runtime.binding.ExtrinsicStatusEvent import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.shared_utils.runtime.extrinsic.ExtrinsicBuilder import jp.co.soramitsu.wallet.impl.data.network.blockchain.bindings.TransferExtrinsic import jp.co.soramitsu.wallet.impl.domain.model.Transfer</ID>
    <ID>ImportOrdering:SwapDetailViewModel.kt$import androidx.annotation.StringRes import androidx.compose.ui.graphics.Color import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.GradientIconState import jp.co.soramitsu.common.compose.theme.greenText import jp.co.soramitsu.common.compose.theme.white import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.mixin.api.Browserable import jp.co.soramitsu.common.resources.ClipboardManager import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.polkaswap.api.models.Market import jp.co.soramitsu.polkaswap.api.models.toMarkets import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.wallet.api.presentation.formatters.formatCryptoDetailFromPlanks import jp.co.soramitsu.wallet.api.presentation.formatters.formatCryptoFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.Operation import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.model.OperationParcelizeModel import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.flow import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:SwapDetails.kt$import java.math.BigDecimal import jp.co.soramitsu.wallet.impl.domain.model.Asset</ID>
    <ID>ImportOrdering:SwapDetailsParcelModel.kt$import android.os.Parcelable import java.math.BigInteger import jp.co.soramitsu.polkaswap.api.models.Market import jp.co.soramitsu.polkaswap.api.models.WithDesired import kotlinx.parcelize.Parcelize</ID>
    <ID>ImportOrdering:SwapDetailsViewState.kt$import android.os.Parcelable import java.math.BigDecimal import jp.co.soramitsu.common.compose.component.GradientIconState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.core.runtime.models.responses.QuoteResponse import jp.co.soramitsu.feature_polkaswap_api.R import jp.co.soramitsu.polkaswap.api.domain.models.SwapDetails import jp.co.soramitsu.polkaswap.api.models.WithDesired import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.parcelize.Parcelize import jp.co.soramitsu.core.models.Asset as CoreAsset</ID>
    <ID>ImportOrdering:SwapTokensViewModel.kt$import androidx.annotation.StringRes import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigDecimal import java.math.BigInteger import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.base.errors.ValidationException import jp.co.soramitsu.common.compose.component.AmountInputViewState import jp.co.soramitsu.common.presentation.LoadingState import jp.co.soramitsu.common.presentation.dataOrNull import jp.co.soramitsu.common.presentation.map import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.applyFiatRate import jp.co.soramitsu.common.utils.combine import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.formatCrypto import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.isZero import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.validation.NotEnoughResultedAmountToPayFeeException import jp.co.soramitsu.common.validation.SpendInsufficientBalanceException import jp.co.soramitsu.common.validation.UnableToPayFeeException import jp.co.soramitsu.common.validation.WaitForFeeCalculationException import jp.co.soramitsu.feature_polkaswap_impl.R import jp.co.soramitsu.polkaswap.api.domain.InsufficientLiquidityException import jp.co.soramitsu.polkaswap.api.domain.PathUnavailableException import jp.co.soramitsu.polkaswap.api.domain.PolkaswapInteractor import jp.co.soramitsu.polkaswap.api.domain.models.SwapDetails import jp.co.soramitsu.polkaswap.api.models.Market import jp.co.soramitsu.polkaswap.api.models.WithDesired import jp.co.soramitsu.polkaswap.api.presentation.PolkaswapRouter import jp.co.soramitsu.polkaswap.api.presentation.models.SwapDetailsParcelModel import jp.co.soramitsu.polkaswap.api.presentation.models.SwapDetailsViewState import jp.co.soramitsu.polkaswap.api.presentation.models.TransactionSettingsModel import jp.co.soramitsu.polkaswap.api.presentation.models.detailsToViewState import jp.co.soramitsu.polkaswap.impl.presentation.transaction_settings.TransactionSettingsFragment import jp.co.soramitsu.wallet.api.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import kotlinx.coroutines.FlowPreview import kotlinx.coroutines.Job import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.catch import kotlinx.coroutines.flow.collectLatest import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.filterNotNull import kotlinx.coroutines.flow.flatMapConcat import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.flow.transform import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:TernoaRewardCalculator.kt$import java.math.BigDecimal import jp.co.soramitsu.common.utils.fractionToPercentage import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.shared_utils.extensions.toHexString import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:TokenUseCaseImpl.kt$import jp.co.soramitsu.wallet.impl.domain.TokenUseCase import jp.co.soramitsu.wallet.impl.domain.interfaces.TokenRepository import jp.co.soramitsu.wallet.impl.domain.model.Token import jp.co.soramitsu.runtime.state.SingleAssetSharedState import jp.co.soramitsu.runtime.state.chainAsset import jp.co.soramitsu.runtime.state.selectedAssetFlow import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flatMapLatest</ID>
    <ID>ImportOrdering:TotalBalanceUseCaseImpl.kt$import java.math.BigDecimal import java.math.RoundingMode import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.domain.interfaces.TotalBalanceUseCase import jp.co.soramitsu.account.api.domain.model.TotalBalance import jp.co.soramitsu.common.utils.DOLLAR_SIGN import jp.co.soramitsu.common.utils.applyFiatRate import jp.co.soramitsu.common.utils.fractionToPercentage import jp.co.soramitsu.common.utils.isZero import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.utils.percentageToFraction import jp.co.soramitsu.coredb.dao.AssetDao import jp.co.soramitsu.coredb.model.AssetWithToken import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.polkadotChainId import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.flow import kotlinx.coroutines.flow.map</ID>
    <ID>ImportOrdering:TransactionDetailViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.liveData import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.presentation.account.AddressDisplayUseCase import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.mixin.api.Browserable import jp.co.soramitsu.common.resources.ClipboardManager import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.presentation.AssetPayload import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import jp.co.soramitsu.wallet.impl.presentation.model.OperationParcelizeModel import kotlinx.coroutines.flow.flow</ID>
    <ID>ImportOrdering:TransactionHistoryFilterFragment.kt$import android.widget.CompoundButton import androidx.fragment.app.viewModels import androidx.lifecycle.lifecycleScope import dagger.hilt.android.AndroidEntryPoint import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.common.view.ButtonState import jp.co.soramitsu.common.view.bindFromMap import jp.co.soramitsu.common.view.viewBinding import jp.co.soramitsu.wallet.impl.domain.interfaces.TransactionFilter import jp.co.soramitsu.feature_wallet_impl.R import jp.co.soramitsu.feature_wallet_impl.databinding.FragmentTransactionsFilterBinding</ID>
    <ID>ImportOrdering:TransactionSettingsViewModel.kt$import androidx.compose.ui.focus.FocusState import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.text.NumberFormat import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.NumberInputState import jp.co.soramitsu.common.compose.component.SelectorState import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.feature_polkaswap_impl.R import jp.co.soramitsu.polkaswap.api.models.Market import jp.co.soramitsu.polkaswap.api.presentation.PolkaswapRouter import jp.co.soramitsu.polkaswap.api.presentation.models.TransactionSettingsModel import jp.co.soramitsu.polkaswap.impl.presentation.select_market.SelectMarketFragment import kotlinx.coroutines.Job import kotlinx.coroutines.flow.MutableStateFlow import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.flow.stateIn</ID>
    <ID>ImportOrdering:TransferDraft.kt$import android.os.Parcelable import java.math.BigDecimal import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.wallet.impl.presentation.AssetPayload import kotlinx.android.parcel.IgnoredOnParcel import kotlinx.parcelize.Parcelize</ID>
    <ID>ImportOrdering:UnbondValidationPayload.kt$import java.math.BigDecimal import jp.co.soramitsu.staking.api.domain.model.StakingState import jp.co.soramitsu.wallet.impl.domain.model.Asset</ID>
    <ID>ImportOrdering:Unbonding.kt$import android.os.Build import java.math.BigInteger import java.util.Calendar import java.util.TimeZone import jp.co.soramitsu.common.data.network.subquery.StakingHistoryRemote import jp.co.soramitsu.common.data.network.subquery.SubsquidRewardResponse import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.staking.api.domain.model.DelegationAction import jp.co.soramitsu.staking.api.domain.model.DelegationScheduledRequest import java.text.SimpleDateFormat import java.time.Instant import java.util.Locale</ID>
    <ID>ImportOrdering:ValidateTransferUseCase.kt$import java.math.BigInteger import jp.co.soramitsu.common.base.errors.ValidationException import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.validation.DeadRecipientException import jp.co.soramitsu.common.validation.ExistentialDepositCrossedException import jp.co.soramitsu.common.validation.SpendInsufficientBalanceException import jp.co.soramitsu.common.validation.TransferAddressNotValidException import jp.co.soramitsu.common.validation.TransferToTheSameAddressException import jp.co.soramitsu.common.validation.WaitForFeeCalculationException import jp.co.soramitsu.core.models.ChainId import jp.co.soramitsu.wallet.impl.domain.model.Asset</ID>
    <ID>ImportOrdering:ValidateTransferUseCaseImpl.kt$import java.math.BigInteger import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.utils.sumByBigDecimal import jp.co.soramitsu.core.models.ChainAssetType import jp.co.soramitsu.core.models.ChainId import jp.co.soramitsu.core.utils.isValidAddress import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.runtime.ext.accountIdOf import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.wallet.api.domain.ExistentialDepositUseCase import jp.co.soramitsu.wallet.api.domain.TransferValidationResult import jp.co.soramitsu.wallet.api.domain.ValidateTransferUseCase import jp.co.soramitsu.wallet.impl.data.network.blockchain.SubstrateRemoteSource import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletConstants import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount</ID>
    <ID>ImportOrdering:Validator.kt$import java.math.BigDecimal import java.math.BigInteger import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.address.AddressModel import jp.co.soramitsu.common.address.createAddressModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.formatAsPercentage import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.fractionToPercentage import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.ext.addressOf import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.shared_utils.extensions.fromHex import jp.co.soramitsu.staking.api.domain.model.NominatedValidator import jp.co.soramitsu.staking.api.domain.model.Validator import jp.co.soramitsu.staking.impl.domain.recommendations.settings.sortings.BlockProducersSorting import jp.co.soramitsu.staking.impl.presentation.validators.change.ValidatorModel import jp.co.soramitsu.staking.impl.presentation.validators.details.model.ValidatorDetailsModel import jp.co.soramitsu.staking.impl.presentation.validators.details.model.ValidatorStakeModel import jp.co.soramitsu.staking.impl.presentation.validators.details.model.ValidatorStakeModel.ActiveStakeModel import jp.co.soramitsu.staking.impl.presentation.validators.details.view.Error import jp.co.soramitsu.staking.impl.presentation.validators.parcel.ValidatorDetailsParcelModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.ValidatorStakeParcelModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.ValidatorStakeParcelModel.Active.NominatorInfo import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.Token import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks</ID>
    <ID>ImportOrdering:ValidatorDetailsViewModel.kt$import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.AppLinksProvider import jp.co.soramitsu.common.data.network.BlockExplorerUrlBuilder import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.common.utils.flowOf import jp.co.soramitsu.common.utils.formatCryptoDetail import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.sumByBigInteger import jp.co.soramitsu.feature_staking_impl.R import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.getSupportedExplorers import jp.co.soramitsu.staking.impl.domain.StakingInteractor import jp.co.soramitsu.staking.impl.domain.getSelectedChain import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.mappers.mapValidatorDetailsParcelToValidatorDetailsModel import jp.co.soramitsu.staking.impl.presentation.mappers.mapValidatorDetailsToErrors import jp.co.soramitsu.staking.impl.presentation.validators.details.ValidatorDetailsFragment.Companion.KEY_VALIDATOR import jp.co.soramitsu.staking.impl.presentation.validators.parcel.NominatorParcelModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.ValidatorDetailsParcelModel import jp.co.soramitsu.staking.impl.presentation.validators.parcel.ValidatorStakeParcelModel import jp.co.soramitsu.staking.impl.scenarios.relaychain.StakingRelayChainScenarioInteractor import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.first import kotlinx.coroutines.launch import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:ValidatorRecommendatorFactory.kt$import androidx.lifecycle.Lifecycle import jp.co.soramitsu.common.data.memory.ComputationalCache import jp.co.soramitsu.staking.api.domain.model.Validator import jp.co.soramitsu.staking.api.data.StakingSharedState import jp.co.soramitsu.staking.impl.domain.validators.ValidatorProvider import jp.co.soramitsu.staking.impl.domain.validators.ValidatorSource import jp.co.soramitsu.runtime.state.chain import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:ValidatorStakeParcelModel.kt$import android.os.Parcelable import java.math.BigDecimal import java.math.BigInteger import jp.co.soramitsu.staking.api.domain.model.CandidateInfoStatus import kotlinx.parcelize.Parcelize import kotlinx.parcelize.RawValue</ID>
    <ID>ImportOrdering:ValidatorsSettingsViewModel.kt$import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import java.math.BigInteger import javax.inject.Inject import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.invoke import jp.co.soramitsu.common.utils.lazyAsync import jp.co.soramitsu.staking.api.domain.model.Validator import jp.co.soramitsu.staking.impl.domain.recommendations.settings.RecommendationSettingsProvider import jp.co.soramitsu.staking.impl.domain.recommendations.settings.RecommendationSettingsProviderFactory import jp.co.soramitsu.staking.impl.domain.recommendations.settings.SettingsStorage import jp.co.soramitsu.staking.impl.presentation.StakingRouter import jp.co.soramitsu.staking.impl.presentation.validators.change.custom.settings.SettingsSchema import kotlinx.coroutines.Deferred import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:WalletAccountActionsSheet.kt$import android.content.Context import android.os.Bundle import jp.co.soramitsu.common.view.bottomSheet.list.fixed.item import jp.co.soramitsu.account.api.presentation.actions.CopyCallback import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.account.api.presentation.actions.ExternalActionsSheet import jp.co.soramitsu.account.api.presentation.actions.ExternalViewCallback import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId</ID>
    <ID>ImportOrdering:WalletExportFragment.kt$import android.os.Bundle import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import androidx.core.os.bundleOf import androidx.fragment.app.viewModels import coil.ImageLoader import dagger.hilt.android.AndroidEntryPoint import jp.co.soramitsu.common.base.BaseFragment import jp.co.soramitsu.feature_account_impl.databinding.FragmentWalletExportBinding import jp.co.soramitsu.account.impl.domain.account.details.AccountInChain import javax.inject.Inject</ID>
    <ID>ImportOrdering:WalletExportViewModel.kt$import android.graphics.drawable.Drawable import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import dagger.hilt.android.lifecycle.HiltViewModel import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.invoke import jp.co.soramitsu.account.api.domain.model.TotalBalance import jp.co.soramitsu.account.api.presentation.actions.ExternalAccountActions import jp.co.soramitsu.feature_account_impl.R import jp.co.soramitsu.account.impl.domain.account.details.AccountDetailsInteractor import jp.co.soramitsu.account.impl.domain.account.details.AccountInChain import jp.co.soramitsu.account.impl.presentation.AccountRouter import jp.co.soramitsu.account.impl.presentation.account.model.format import jp.co.soramitsu.runtime.multiNetwork.chain.model.polkadotChainId import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.async import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.launch import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.TotalBalanceUseCase</ID>
    <ID>ImportOrdering:WalletFeatureModule.kt$import android.content.ContentResolver import android.content.Context import com.google.gson.Gson import dagger.Module import dagger.Provides import dagger.hilt.InstallIn import dagger.hilt.android.qualifiers.ApplicationContext import dagger.hilt.components.SingletonComponent import javax.inject.Named import javax.inject.Singleton import jp.co.soramitsu.account.api.domain.interfaces.AccountInteractor import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.domain.updaters.AccountUpdateScope import jp.co.soramitsu.account.impl.presentation.account.mixin.api.AccountListingMixin import jp.co.soramitsu.account.impl.presentation.account.mixin.impl.AccountListingProvider import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.data.network.HttpExceptionHandler import jp.co.soramitsu.common.data.network.NetworkApiCreator import jp.co.soramitsu.common.data.network.coingecko.CoingeckoApi import jp.co.soramitsu.common.data.network.config.RemoteConfigFetcher import jp.co.soramitsu.common.data.network.rpc.BulkRetriever import jp.co.soramitsu.common.data.storage.Preferences import jp.co.soramitsu.common.domain.GetAvailableFiatCurrencies import jp.co.soramitsu.common.domain.SelectedFiat import jp.co.soramitsu.common.interfaces.FileProvider import jp.co.soramitsu.common.mixin.api.UpdatesMixin import jp.co.soramitsu.common.resources.ResourceManager import jp.co.soramitsu.common.utils.QrBitmapDecoder import jp.co.soramitsu.core.extrinsic.ExtrinsicService import jp.co.soramitsu.core.rpc.RpcCalls import jp.co.soramitsu.core.updater.UpdateSystem import jp.co.soramitsu.coredb.dao.AddressBookDao import jp.co.soramitsu.coredb.dao.AssetDao import jp.co.soramitsu.coredb.dao.ChainDao import jp.co.soramitsu.coredb.dao.OperationDao import jp.co.soramitsu.coredb.dao.PhishingDao import jp.co.soramitsu.coredb.dao.TokenPriceDao import jp.co.soramitsu.feature_wallet_impl.BuildConfig import jp.co.soramitsu.runtime.di.REMOTE_STORAGE_SOURCE import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.runtime.RuntimeFilesCache import jp.co.soramitsu.runtime.storage.source.StorageDataSource import jp.co.soramitsu.wallet.api.data.cache.AssetCache import jp.co.soramitsu.wallet.api.domain.ExistentialDepositUseCase import jp.co.soramitsu.wallet.api.domain.ValidateTransferUseCase import jp.co.soramitsu.wallet.api.presentation.mixin.TransferValidityChecks import jp.co.soramitsu.wallet.api.presentation.mixin.TransferValidityChecksProvider import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeLoaderMixin import jp.co.soramitsu.wallet.api.presentation.mixin.fee.FeeLoaderProvider import jp.co.soramitsu.wallet.impl.data.buyToken.MoonPayProvider import jp.co.soramitsu.wallet.impl.data.buyToken.RampProvider import jp.co.soramitsu.wallet.impl.data.historySource.HistorySourceProvider import jp.co.soramitsu.wallet.impl.data.network.blockchain.SubstrateRemoteSource import jp.co.soramitsu.wallet.impl.data.network.blockchain.WssSubstrateSource import jp.co.soramitsu.wallet.impl.data.network.blockchain.updaters.BalancesUpdateSystem import jp.co.soramitsu.wallet.impl.data.network.blockchain.updaters.PaymentUpdaterFactory import jp.co.soramitsu.wallet.impl.data.network.phishing.PhishingApi import jp.co.soramitsu.wallet.impl.data.network.subquery.OperationsHistoryApi import jp.co.soramitsu.wallet.impl.data.repository.AddressBookRepositoryImpl import jp.co.soramitsu.wallet.impl.data.repository.HistoryRepository import jp.co.soramitsu.wallet.impl.data.repository.RuntimeWalletConstants import jp.co.soramitsu.wallet.impl.data.repository.TokenRepositoryImpl import jp.co.soramitsu.wallet.impl.data.repository.WalletRepositoryImpl import jp.co.soramitsu.wallet.impl.data.storage.TransferCursorStorage import jp.co.soramitsu.wallet.impl.domain.ChainInteractor import jp.co.soramitsu.wallet.impl.domain.CurrentAccountAddressUseCase import jp.co.soramitsu.wallet.impl.domain.TokenUseCase import jp.co.soramitsu.wallet.impl.domain.ValidateTransferUseCaseImpl import jp.co.soramitsu.wallet.impl.domain.WalletInteractorImpl import jp.co.soramitsu.wallet.impl.domain.XcmInteractor import jp.co.soramitsu.wallet.impl.domain.beacon.BeaconInteractor import jp.co.soramitsu.wallet.impl.domain.beacon.BeaconSharedState import jp.co.soramitsu.wallet.impl.domain.implementations.ExistentialDepositUseCaseImpl import jp.co.soramitsu.wallet.impl.domain.implementations.TokenUseCaseImpl import jp.co.soramitsu.wallet.impl.domain.interfaces.AddressBookRepository import jp.co.soramitsu.wallet.impl.domain.interfaces.TokenRepository import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletConstants import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletRepository import jp.co.soramitsu.wallet.impl.domain.model.BuyTokenRegistry import jp.co.soramitsu.wallet.impl.presentation.balance.assetActions.buy.BuyMixin import jp.co.soramitsu.wallet.impl.presentation.balance.assetActions.buy.BuyMixinProvider import jp.co.soramitsu.wallet.impl.presentation.send.SendSharedState import jp.co.soramitsu.wallet.impl.presentation.transaction.filter.HistoryFiltersProvider import jp.co.soramitsu.xcm.XcmService import jp.co.soramitsu.xcm.domain.XcmEntitiesFetcher import jp.co.soramitsu.xnetworking.networkclient.SoramitsuNetworkClient import jp.co.soramitsu.xnetworking.sorawallet.mainconfig.SoraRemoteConfigBuilder import jp.co.soramitsu.xnetworking.sorawallet.mainconfig.SoraRemoteConfigProvider import jp.co.soramitsu.xnetworking.txhistory.client.sorawallet.SubQueryClientForSoraWalletFactory</ID>
    <ID>ImportOrdering:WalletInteractor.kt$import java.io.File import java.math.BigDecimal import java.math.BigInteger import jp.co.soramitsu.account.api.domain.model.MetaAccount import jp.co.soramitsu.common.data.model.CursorPage import jp.co.soramitsu.common.data.network.runtime.binding.EqAccountInfo import jp.co.soramitsu.common.data.network.runtime.binding.EqOraclePricePoint import jp.co.soramitsu.common.data.secrets.v2.MetaAccountSecrets import jp.co.soramitsu.core.models.ChainId import jp.co.soramitsu.coredb.model.AddressBookContact import jp.co.soramitsu.coredb.model.AssetUpdateItem import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.shared_utils.scale.EncodableStruct import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.AssetWithStatus import jp.co.soramitsu.wallet.impl.domain.model.ControllerDeprecationWarning import jp.co.soramitsu.wallet.impl.domain.model.Fee import jp.co.soramitsu.wallet.impl.domain.model.Operation import jp.co.soramitsu.wallet.impl.domain.model.OperationsPageChange import jp.co.soramitsu.wallet.impl.domain.model.PhishingModel import jp.co.soramitsu.wallet.impl.domain.model.Transfer import jp.co.soramitsu.wallet.impl.domain.model.TransferValidityStatus import jp.co.soramitsu.wallet.impl.domain.model.WalletAccount import kotlinx.coroutines.flow.Flow import jp.co.soramitsu.core.models.Asset as CoreAsset</ID>
    <ID>ImportOrdering:WalletInteractorImpl.kt$import java.math.BigDecimal import java.math.BigInteger import jp.co.soramitsu.account.api.domain.interfaces.AccountRepository import jp.co.soramitsu.account.api.domain.model.MetaAccount import jp.co.soramitsu.account.api.domain.model.accountId import jp.co.soramitsu.account.api.domain.model.address import jp.co.soramitsu.common.data.model.CursorPage import jp.co.soramitsu.common.data.network.runtime.binding.EqAccountInfo import jp.co.soramitsu.common.data.network.runtime.binding.EqOraclePricePoint import jp.co.soramitsu.common.data.storage.Preferences import jp.co.soramitsu.common.domain.SelectedFiat import jp.co.soramitsu.common.interfaces.FileProvider import jp.co.soramitsu.common.mixin.api.UpdatesMixin import jp.co.soramitsu.common.mixin.api.UpdatesProviderUi import jp.co.soramitsu.common.utils.Modules import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.core.models.Asset.StakingType import jp.co.soramitsu.core.models.ChainId import jp.co.soramitsu.core.utils.isValidAddress import jp.co.soramitsu.coredb.model.AssetUpdateItem import jp.co.soramitsu.runtime.ext.ecosystem import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.ChainEcosystem import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.chain.model.isPolkadotOrKusama import jp.co.soramitsu.runtime.multiNetwork.chain.model.polkadotChainId import jp.co.soramitsu.runtime.multiNetwork.chainWithAsset import jp.co.soramitsu.shared_utils.extensions.toHexString import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.shared_utils.runtime.metadata.module import jp.co.soramitsu.wallet.impl.data.repository.HistoryRepository import jp.co.soramitsu.wallet.impl.domain.interfaces.AddressBookRepository import jp.co.soramitsu.wallet.impl.domain.interfaces.TransactionFilter import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletInteractor import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletRepository import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.AssetWithStatus import jp.co.soramitsu.wallet.impl.domain.model.ControllerDeprecationWarning import jp.co.soramitsu.wallet.impl.domain.model.Fee import jp.co.soramitsu.wallet.impl.domain.model.Operation import jp.co.soramitsu.wallet.impl.domain.model.OperationsPageChange import jp.co.soramitsu.wallet.impl.domain.model.PhishingModel import jp.co.soramitsu.wallet.impl.domain.model.Transfer import jp.co.soramitsu.wallet.impl.domain.model.WalletAccount import jp.co.soramitsu.wallet.impl.domain.model.toPhishingModel import jp.co.soramitsu.xcm.domain.XcmEntitiesFetcher import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.ExperimentalCoroutinesApi import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.distinctUntilChanged import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.flatMapLatest import kotlinx.coroutines.flow.flatMapMerge import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.withIndex import kotlinx.coroutines.withContext import jp.co.soramitsu.core.models.Asset as CoreAsset</ID>
    <ID>ImportOrdering:WalletRepository.kt$import jp.co.soramitsu.account.api.domain.model.MetaAccount import jp.co.soramitsu.common.data.network.config.AppConfigRemote import jp.co.soramitsu.common.data.network.runtime.binding.EqAccountInfo import jp.co.soramitsu.common.data.network.runtime.binding.EqOraclePricePoint import jp.co.soramitsu.coredb.model.AssetUpdateItem import jp.co.soramitsu.coredb.model.PhishingLocal import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.shared_utils.runtime.extrinsic.ExtrinsicBuilder import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.AssetWithStatus import jp.co.soramitsu.wallet.impl.domain.model.Fee import jp.co.soramitsu.wallet.impl.domain.model.Transfer import jp.co.soramitsu.wallet.impl.domain.model.TransferValidityStatus import kotlinx.coroutines.flow.Flow import java.math.BigDecimal import java.math.BigInteger import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.core.models.Asset as CoreAsset</ID>
    <ID>ImportOrdering:WalletRepositoryImpl.kt$import com.opencsv.CSVReaderHeaderAware import java.math.BigDecimal import java.math.BigInteger import jp.co.soramitsu.account.api.domain.model.MetaAccount import jp.co.soramitsu.account.api.domain.model.accountId import jp.co.soramitsu.common.compose.component.NetworkIssueItemState import jp.co.soramitsu.common.compose.component.NetworkIssueType import jp.co.soramitsu.common.data.network.HttpExceptionHandler import jp.co.soramitsu.common.data.network.coingecko.CoingeckoApi import jp.co.soramitsu.common.data.network.config.AppConfigRemote import jp.co.soramitsu.common.data.network.config.RemoteConfigFetcher import jp.co.soramitsu.common.domain.GetAvailableFiatCurrencies import jp.co.soramitsu.common.mixin.api.UpdatesMixin import jp.co.soramitsu.common.mixin.api.UpdatesProviderUi import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.core.utils.utilityAsset import jp.co.soramitsu.coredb.dao.OperationDao import jp.co.soramitsu.coredb.dao.PhishingDao import jp.co.soramitsu.coredb.dao.emptyAccountIdValue import jp.co.soramitsu.coredb.model.AssetUpdateItem import jp.co.soramitsu.coredb.model.AssetWithToken import jp.co.soramitsu.coredb.model.OperationLocal import jp.co.soramitsu.coredb.model.PhishingLocal import jp.co.soramitsu.runtime.ext.accountIdOf import jp.co.soramitsu.runtime.ext.addressOf import jp.co.soramitsu.runtime.multiNetwork.ChainRegistry import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.shared_utils.runtime.extrinsic.ExtrinsicBuilder import jp.co.soramitsu.wallet.api.data.cache.AssetCache import jp.co.soramitsu.wallet.impl.data.mappers.mapAssetLocalToAsset import jp.co.soramitsu.wallet.impl.data.network.blockchain.SubstrateRemoteSource import jp.co.soramitsu.wallet.impl.data.network.phishing.PhishingApi import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletConstants import jp.co.soramitsu.wallet.impl.domain.interfaces.WalletRepository import jp.co.soramitsu.wallet.impl.domain.model.Asset import jp.co.soramitsu.wallet.impl.domain.model.Asset.Companion.createEmpty import jp.co.soramitsu.wallet.impl.domain.model.AssetWithStatus import jp.co.soramitsu.wallet.impl.domain.model.Fee import jp.co.soramitsu.wallet.impl.domain.model.Transfer import jp.co.soramitsu.wallet.impl.domain.model.TransferValidityStatus import jp.co.soramitsu.wallet.impl.domain.model.amountFromPlanks import jp.co.soramitsu.wallet.impl.domain.model.planksFromAmount import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.distinctUntilChanged import kotlinx.coroutines.flow.first import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.withContext import jp.co.soramitsu.core.models.Asset as CoreAsset</ID>
    <ID>ImportOrdering:WalletSelectorViewModel.kt$import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.domain.interfaces.TotalBalanceUseCase import jp.co.soramitsu.account.impl.presentation.account.mixin.api.AccountListingMixin import jp.co.soramitsu.common.address.AddressIconGenerator import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.compose.component.ChangeBalanceViewState import jp.co.soramitsu.common.compose.component.WalletItemViewState import jp.co.soramitsu.common.compose.component.WalletSelectorViewState import jp.co.soramitsu.common.mixin.api.UpdatesMixin import jp.co.soramitsu.common.mixin.api.UpdatesProviderUi import jp.co.soramitsu.common.navigation.payload.WalletSelectorPayload import jp.co.soramitsu.common.utils.formatAsChange import jp.co.soramitsu.common.utils.formatFiat import jp.co.soramitsu.common.utils.inBackground import jp.co.soramitsu.common.utils.mapList import jp.co.soramitsu.wallet.impl.presentation.WalletRouter import kotlinx.coroutines.flow.SharingStarted import kotlinx.coroutines.flow.combine import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.stateIn import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:WelcomeViewModel.kt$import android.content.Intent import androidx.activity.result.ActivityResultLauncher import androidx.lifecycle.LiveData import androidx.lifecycle.MutableLiveData import androidx.lifecycle.SavedStateHandle import androidx.lifecycle.viewModelScope import dagger.hilt.android.lifecycle.HiltViewModel import javax.inject.Inject import jp.co.soramitsu.account.api.domain.model.ImportMode import jp.co.soramitsu.backup.BackupService import jp.co.soramitsu.common.base.BaseViewModel import jp.co.soramitsu.common.data.network.AppLinksProvider import jp.co.soramitsu.common.mixin.api.Browserable import jp.co.soramitsu.common.utils.Event import jp.co.soramitsu.feature_onboarding_impl.BuildConfig import jp.co.soramitsu.onboarding.impl.OnboardingRouter import jp.co.soramitsu.onboarding.impl.welcome.WelcomeFragment.Companion.KEY_PAYLOAD import kotlinx.coroutines.channels.BufferOverflow import kotlinx.coroutines.channels.Channel import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.onEach import kotlinx.coroutines.flow.receiveAsFlow import kotlinx.coroutines.launch</ID>
    <ID>ImportOrdering:Write.kt$import android.graphics.Bitmap import java.io.File import java.io.FileOutputStream import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext</ID>
    <ID>ImportOrdering:WssSubstrateSource.kt$import java.math.BigInteger import jp.co.soramitsu.common.data.network.runtime.binding.AccountInfo import jp.co.soramitsu.common.data.network.runtime.binding.AssetsAccountInfo import jp.co.soramitsu.common.data.network.runtime.binding.EqAccountInfo import jp.co.soramitsu.common.data.network.runtime.binding.EqOraclePricePoint import jp.co.soramitsu.common.data.network.runtime.binding.EventRecord import jp.co.soramitsu.common.data.network.runtime.binding.ExtrinsicStatusEvent import jp.co.soramitsu.common.data.network.runtime.binding.OrmlTokensAccountData import jp.co.soramitsu.common.data.network.runtime.binding.Phase import jp.co.soramitsu.common.data.network.runtime.binding.bindEquilibriumAssetRates import jp.co.soramitsu.common.data.network.runtime.binding.bindExtrinsicStatusEventRecords import jp.co.soramitsu.common.data.network.runtime.binding.bindOrNull import jp.co.soramitsu.common.utils.Calls import jp.co.soramitsu.common.data.network.runtime.binding.getTyped import jp.co.soramitsu.common.utils.Modules import jp.co.soramitsu.common.utils.orZero import jp.co.soramitsu.common.utils.staking import jp.co.soramitsu.common.utils.system import jp.co.soramitsu.common.utils.tokens import jp.co.soramitsu.common.utils.u64ArgumentFromStorageKey import jp.co.soramitsu.core.extrinsic.ExtrinsicService import jp.co.soramitsu.core.models.Asset import jp.co.soramitsu.core.models.ChainAssetType import jp.co.soramitsu.core.rpc.RpcCalls import jp.co.soramitsu.core.rpc.calls.getBlock import jp.co.soramitsu.core.runtime.storage.returnType import jp.co.soramitsu.runtime.ext.accountIdOf import jp.co.soramitsu.runtime.multiNetwork.chain.model.Chain import jp.co.soramitsu.runtime.multiNetwork.chain.model.ChainId import jp.co.soramitsu.runtime.storage.source.StorageDataSource import jp.co.soramitsu.runtime.storage.source.queryNonNull import jp.co.soramitsu.shared_utils.extensions.fromHex import jp.co.soramitsu.shared_utils.runtime.AccountId import jp.co.soramitsu.shared_utils.runtime.RuntimeSnapshot import jp.co.soramitsu.shared_utils.runtime.definitions.registry.TypeRegistry import jp.co.soramitsu.shared_utils.runtime.definitions.types.composite.DictEnum import jp.co.soramitsu.shared_utils.runtime.definitions.types.composite.Struct import jp.co.soramitsu.shared_utils.runtime.definitions.types.fromHexOrNull import jp.co.soramitsu.shared_utils.runtime.definitions.types.primitives.FixedByteArray import jp.co.soramitsu.shared_utils.runtime.extrinsic.ExtrinsicBuilder import jp.co.soramitsu.shared_utils.runtime.metadata.module import jp.co.soramitsu.shared_utils.runtime.metadata.storage import jp.co.soramitsu.shared_utils.runtime.metadata.storageKey import jp.co.soramitsu.wallet.api.data.cache.bindAccountInfoOrDefault import jp.co.soramitsu.wallet.api.data.cache.bindAssetsAccountData import jp.co.soramitsu.wallet.api.data.cache.bindEquilibriumAccountData import jp.co.soramitsu.wallet.api.data.cache.bindOrmlTokensAccountDataOrDefault import jp.co.soramitsu.wallet.impl.data.network.blockchain.bindings.bindTransferExtrinsic import jp.co.soramitsu.wallet.impl.data.repository.totalBalance import jp.co.soramitsu.wallet.impl.domain.model.Transfer</ID>
    <ID>ImportOrdering:kotlin-runtimepermissions-coroutines.kt$import androidx.fragment.app.Fragment import androidx.fragment.app.FragmentActivity import jp.co.soramitsu.android_foundation.kotlin.NoActivityException import jp.co.soramitsu.android_foundation.kotlin.PermissionException import jp.co.soramitsu.android_foundation.core.PermissionResult import kotlin.coroutines.resume import kotlin.coroutines.resumeWithException import kotlin.coroutines.suspendCoroutine import jp.co.soramitsu.android_foundation.core.RuntimePermission as RuntimePermission</ID>
    <ID>ImportOrdering:kotlin-runtimepermissions.kt$import androidx.fragment.app.Fragment import androidx.fragment.app.FragmentActivity import jp.co.soramitsu.android_foundation.core.RuntimePermission import jp.co.soramitsu.android_foundation.core.PermissionResult</ID>
    <ID>LambdaParameterNaming:CrossChainSetupViewModel.kt$CrossChainSetupViewModel$_asset</ID>
    <ID>LambdaParameterNaming:CrossChainSetupViewModel.kt$CrossChainSetupViewModel$_destinationChainId</ID>
    <ID>LargeClass:AccountRepositoryImpl.kt$AccountRepositoryImpl : AccountRepository</ID>
    <ID>LargeClass:BalanceListViewModel.kt$BalanceListViewModel : BaseViewModelUpdatesProviderUiNetworkStateUiWalletScreenInterface</ID>
    <ID>LargeClass:CrossChainSetupViewModel.kt$CrossChainSetupViewModel : BaseViewModelCrossChainSetupScreenInterface</ID>
    <ID>LargeClass:CustomContributeViewModel.kt$CustomContributeViewModel : BaseViewModelValidatableBrowserableFeeLoaderMixin</ID>
    <ID>LargeClass:Migrations.kt$&lt;no name provided&gt; : Migration</ID>
    <ID>LargeClass:Navigator.kt$Navigator : SplashRouterOnboardingRouterAccountRouterWalletRouterRootRouterStakingRouterCrowdloanRouterPolkaswapRouterSuccessRouterSoraCardRouter</ID>
    <ID>LargeClass:SendSetupViewModel.kt$SendSetupViewModel : BaseViewModelSendSetupScreenInterface</ID>
    <ID>LargeClass:StakingFeatureModule.kt$StakingFeatureModule</ID>
    <ID>LargeClass:StakingFragment.kt$StakingFragment : BaseFragmentDelegationHandler</ID>
    <ID>LargeClass:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor : StakingScenarioInteractor</ID>
    <ID>LargeClass:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor : StakingScenarioInteractor</ID>
    <ID>LargeClass:SwapTokensViewModel.kt$SwapTokensViewModel : BaseViewModelSwapTokensCallbacks</ID>
    <ID>LateinitUsage:AccountDetailsFragment.kt$AccountDetailsFragment$@Inject lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:AccountsForExportFragment.kt$AccountsForExportFragment$@Inject lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:AlertFragment.kt$AlertFragment$@Inject lateinit var navigator: Navigator</ID>
    <ID>LateinitUsage:BalanceListFragment.kt$BalanceListFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:ConfirmBondMoreFragment.kt$ConfirmBondMoreFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:ConfirmContributeFragment.kt$ConfirmContributeFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:ConfirmContributeFragment.kt$ConfirmContributeFragment$private lateinit var binding: FragmentContributeConfirmBinding</ID>
    <ID>LateinitUsage:ConfirmMnemonicFragment.kt$ConfirmMnemonicFragment$private lateinit var binding: FragmentConfirmMnemonicBinding</ID>
    <ID>LateinitUsage:ConfirmNominationsFragment.kt$ConfirmNominationsFragment$lateinit var adapter: ValidatorsAdapter</ID>
    <ID>LateinitUsage:ConfirmRebondFragment.kt$ConfirmRebondFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:ConfirmStakingFragment.kt$ConfirmStakingFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:ConfirmUnbondFragment.kt$ConfirmUnbondFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:CrowdloanContributeFragment.kt$CrowdloanContributeFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:CrowdloanFragment.kt$CrowdloanFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:CurrentValidatorsFragment.kt$CurrentValidatorsFragment$lateinit var adapter: CurrentValidatorsAdapter</ID>
    <ID>LateinitUsage:CustomContributeFragment.kt$CustomContributeFragment$@Inject protected lateinit var contributionManager: CustomContributeManager</ID>
    <ID>LateinitUsage:CustomContributeFragment.kt$CustomContributeFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:CustomContributeFragment.kt$CustomContributeFragment$private lateinit var binding: FragmentCustomContributeBinding</ID>
    <ID>LateinitUsage:CustomRebondFragment.kt$CustomRebondFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:ExportJsonConfirmFragment.kt$ExportJsonConfirmFragment$@Inject lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:ExportJsonConfirmFragment.kt$ExportJsonConfirmFragment$private lateinit var binding: FragmentExportJsonConfirmBinding</ID>
    <ID>LateinitUsage:ExportJsonPasswordFragment.kt$ExportJsonPasswordFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:ExportJsonPasswordFragment.kt$ExportJsonPasswordFragment$private lateinit var binding: FragmentExportJsonPasswordBinding</ID>
    <ID>LateinitUsage:ExportMnemonicFragment.kt$ExportMnemonicFragment$private lateinit var binding: FragmentExportMnemonicBinding</ID>
    <ID>LateinitUsage:ExportSeedFragment.kt$ExportSeedFragment$private lateinit var binding: FragmentExportSeedBinding</ID>
    <ID>LateinitUsage:ImportAccountFragment.kt$ImportAccountFragment$private lateinit var binding: FragmentImportAccountBinding</ID>
    <ID>LateinitUsage:LanguagesFragment.kt$LanguagesFragment$private lateinit var adapter: LanguagesAdapter</ID>
    <ID>LateinitUsage:LanguagesFragment.kt$LanguagesFragment$private lateinit var binding: FragmentLanguagesBinding</ID>
    <ID>LateinitUsage:NodeDetailsFragment.kt$NodeDetailsFragment$@Inject lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:NodeDetailsFragment.kt$NodeDetailsFragment$private lateinit var binding: FragmentNodeDetailsBinding</ID>
    <ID>LateinitUsage:NodesFragment.kt$NodesFragment$@Inject lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:NodesFragment.kt$NodesFragment$private lateinit var adapter: NodesAdapter</ID>
    <ID>LateinitUsage:NodesFragment.kt$NodesFragment$private lateinit var binding: FragmentNodesBinding</ID>
    <ID>LateinitUsage:PayoutsListFragment.kt$PayoutsListFragment$lateinit var adapter: PayoutAdapter</ID>
    <ID>LateinitUsage:PincodeFragment.kt$PincodeFragment$private lateinit var binding: FragmentPincodeBinding</ID>
    <ID>LateinitUsage:PoolFullUnstakeDepositorAlertFragment.kt$PoolFullUnstakeDepositorAlertFragment$@Inject lateinit var navigator: StakingRouter</ID>
    <ID>LateinitUsage:ProfileFragment.kt$ProfileFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:ProfileFragment.kt$ProfileFragment$private lateinit var binding: FragmentProfileBinding</ID>
    <ID>LateinitUsage:RecommendedCollatorsFragment.kt$RecommendedCollatorsFragment$lateinit var adapter: CollatorsAdapter</ID>
    <ID>LateinitUsage:RecommendedValidatorsFragment.kt$RecommendedValidatorsFragment$lateinit var adapter: ValidatorsAdapter</ID>
    <ID>LateinitUsage:RedeemFragment.kt$RedeemFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:RootActivity.kt$RootActivity$@Inject lateinit var navigator: Navigator</ID>
    <ID>LateinitUsage:ScannerActivity.kt$ScannerActivity$@Inject lateinit var viewModel: ScannerViewModel</ID>
    <ID>LateinitUsage:SelectBondMoreFragment.kt$SelectBondMoreFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:SelectCustomCollatorsFragment.kt$SelectCustomCollatorsFragment$lateinit var adapter: CollatorsAdapter</ID>
    <ID>LateinitUsage:SelectCustomValidatorsFragment.kt$SelectCustomValidatorsFragment$lateinit var adapter: ValidatorsAdapter</ID>
    <ID>LateinitUsage:SelectUnbondFragment.kt$SelectUnbondFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:SetupStakingFragment.kt$SetupStakingFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:StakingFragment.kt$StakingFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:ValidatorDetailsFragment.kt$ValidatorDetailsFragment$private lateinit var binding: FragmentValidatorDetailsBinding</ID>
    <ID>LateinitUsage:WalletExportFragment.kt$WalletExportFragment$@Inject lateinit var imageLoader: ImageLoader</ID>
    <ID>LateinitUsage:WalletExportFragment.kt$WalletExportFragment$private lateinit var binding: FragmentWalletExportBinding</ID>
    <ID>LongMethod:Migrations.kt$&lt;no name provided&gt;$override fun migrate(database: SupportSQLiteDatabase)</ID>
    <ID>LongParameterList:AccountFeatureModule.kt$AccountFeatureModule$( accountDataSource: AccountDataSource, accountDao: AccountDao, metaAccountDao: MetaAccountDao, storeV2: SecretStoreV2, jsonSeedDecoder: JsonSeedDecoder, jsonSeedEncoder: JsonSeedEncoder, languagesHolder: LanguagesHolder, chainRegistry: ChainRegistry )</ID>
    <ID>LongParameterList:AccountFeatureModule.kt$AccountFeatureModule$( preferences: Preferences, encryptedPreferences: EncryptedPreferences, jsonMapper: Gson, secretStoreV1: SecretStoreV1, accountDataMigration: AccountDataMigration, metaAccountDao: MetaAccountDao, chainRegistry: ChainRegistry, secretStoreV2: SecretStoreV2 )</ID>
    <ID>LongParameterList:BalanceDetailViewModel.kt$BalanceDetailViewModel$( private val interactor: WalletInteractor, private val router: WalletRouter, private val buyMixin: BuyMixin.Presentation, private val externalAccountActions: ExternalAccountActions.Presentation, addressIconGenerator: AddressIconGenerator, chainInteractor: ChainInteractor, historyFiltersProvider: HistoryFiltersProvider, savedStateHandle: SavedStateHandle, private val resourceManager: ResourceManager, private val clipboardManager: ClipboardManager, addressDisplayUseCase: AddressDisplayUseCase, private val currentAccountAddress: CurrentAccountAddressUseCase, private val xcmService: XcmService )</ID>
    <ID>LongParameterList:BalanceListViewModel.kt$BalanceListViewModel$( private val interactor: WalletInteractor, private val soraCardInteractor: SoraCardInteractor, private val chainInteractor: ChainInteractor, private val addressIconGenerator: AddressIconGenerator, private val router: WalletRouter, private val getAvailableFiatCurrencies: GetAvailableFiatCurrencies, private val selectedFiat: SelectedFiat, private val accountRepository: AccountRepository, private val updatesMixin: UpdatesMixin, private val networkStateMixin: NetworkStateMixin, private val resourceManager: ResourceManager, private val clipboardManager: ClipboardManager, private val currentAccountAddress: CurrentAccountAddressUseCase, private val kycRepository: KycRepository )</ID>
    <ID>LongParameterList:ChainAssetRemote.kt$ChainAssetRemote$( val id: String?, val name: String?, val symbol: String?, val precision: Int?, val icon: String?, val priceId: String?, val currencyId: String?, val existentialDeposit: String?, val color: String?, val isUtility: Boolean?, val isNative: Boolean?, val staking: String?, val purchaseProviders: List&lt;String&gt;?, val type: String? )</ID>
    <ID>LongParameterList:Collator.kt$Collator$( override val address: String, val bond: BigInteger, // collator's own stake in sorting val delegationCount: BigInteger, // delegations in sorting val totalCounted: BigInteger, // effective amount bonded in sorting val lowestTopDelegationAmount: BigInteger, // minimum bond in sorting val highestBottomDelegationAmount: BigInteger, val lowestBottomDelegationAmount: BigInteger, val topCapacity: CandidateCapacity, val bottomCapacity: CandidateCapacity, val request: String?, val status: CandidateInfoStatus, val identity: Identity?, val apy: BigDecimal? )</ID>
    <ID>LongParameterList:ConfirmContributeViewModel.kt$ConfirmContributeViewModel$( private val router: CrowdloanRouter, private val contributionInteractor: CrowdloanContributeInteractor, private val resourceManager: ResourceManager, private val chainRegistry: ChainRegistry, @Named("CrowdloanAssetUseCase") assetUseCase: AssetUseCase, accountUseCase: SelectedAccountUseCase, addressModelGenerator: AddressIconGenerator, private val validationExecutor: ValidationExecutor, private val validationSystem: ContributeValidationSystem, private val customContributeManager: CustomContributeManager, private val externalAccountActions: ExternalAccountActions.Presentation, private val transferValidityChecks: TransferValidityChecks.Presentation, private val savedStateHandle: SavedStateHandle )</ID>
    <ID>LongParameterList:ConfirmPayoutViewModel.kt$ConfirmPayoutViewModel$( private val interactor: StakingInteractor, private val relayChainInteractor: StakingRelayChainScenarioInteractor, private val payoutInteractor: PayoutInteractor, private val router: StakingRouter, private val addressModelGenerator: AddressIconGenerator, private val chainRegistry: ChainRegistry, private val externalAccountActions: ExternalAccountActions.Presentation, @Named("StakingFeeLoader") private val feeLoaderMixin: FeeLoaderMixin.Presentation, private val addressDisplayUseCase: AddressDisplayUseCase, private val validationSystem: ValidationSystem&lt;MakePayoutPayload, PayoutValidationFailure&gt;, private val validationExecutor: ValidationExecutor, private val resourceManager: ResourceManager, private val savedStateHandle: SavedStateHandle )</ID>
    <ID>LongParameterList:ConfirmRewardDestinationViewModel.kt$ConfirmRewardDestinationViewModel$( private val router: StakingRouter, private val interactor: StakingInteractor, stakingRelayChainScenarioInteractor: StakingRelayChainScenarioInteractor, private val addressIconGenerator: AddressIconGenerator, private val resourceManager: ResourceManager, private val validationSystem: RewardDestinationValidationSystem, private val rewardDestinationInteractor: ChangeRewardDestinationInteractor, private val chainRegistry: ChainRegistry, private val externalAccountActions: ExternalAccountActions.Presentation, private val addressDisplayUseCase: AddressDisplayUseCase, private val validationExecutor: ValidationExecutor, private val savedStateHandle: SavedStateHandle )</ID>
    <ID>LongParameterList:ConfirmStakingViewModel.kt$ConfirmStakingViewModel$( private val router: StakingRouter, private val interactor: StakingInteractor, private val scenarioInteractor: StakingScenarioInteractor, private val addressDisplayUseCase: AddressDisplayUseCase, private val resourceManager: ResourceManager, private val setupStakingSharedState: SetupStakingSharedState, private val setupStakingInteractor: SetupStakingInteractor, private val chainRegistry: ChainRegistry, @Named("StakingFeeLoader") private val feeLoaderMixin: FeeLoaderMixin.Presentation, private val externalAccountActions: ExternalAccountActions.Presentation, private val validationExecutor: ValidationExecutor, private val clipboardManager: ClipboardManager )</ID>
    <ID>LongParameterList:CrossChainSetupViewModel.kt$CrossChainSetupViewModel$( val savedStateHandle: SavedStateHandle, private val accountInteractor: AccountInteractor, private val resourceManager: ResourceManager, private val walletInteractor: WalletInteractor, private val walletConstants: WalletConstants, private val router: WalletRouter, private val clipboardManager: ClipboardManager, private val addressIconGenerator: AddressIconGenerator, private val currentAccountAddress: CurrentAccountAddressUseCase, private val validateTransferUseCase: ValidateTransferUseCase, private val chainAssetsManager: ChainAssetsManager, private val xcmInteractor: XcmInteractor )</ID>
    <ID>LongParameterList:CrossChainTransfer.kt$CrossChainTransfer$( senderTransferable: BigDecimal, senderTotal: BigDecimal, fee: BigDecimal, recipientBalance: BigDecimal, existentialDeposit: BigDecimal, isUtilityToken: Boolean, senderUtilityBalance: BigDecimal, utilityExistentialDeposit: BigDecimal, tip: BigDecimal? = null )</ID>
    <ID>LongParameterList:CrowdloanFeatureModule.kt$CrowdloanFeatureModule$( extrinsicService: ExtrinsicService, accountRepository: AccountRepository, chainRegistry: ChainRegistry, chainStateRepository: IChainStateRepository, sharedState: CrowdloanSharedState, crowdloanRepository: CrowdloanRepository, walletRepository: WalletRepository, moonbeamApi: MoonbeamApi, acalaApi: AcalaApi, resourceManager: ResourceManager )</ID>
    <ID>LongParameterList:Ext.kt$( flow: Flow&lt;T1&gt;, flow2: Flow&lt;T2&gt;, flow3: Flow&lt;T3&gt;, flow4: Flow&lt;T4&gt;, flow5: Flow&lt;T5&gt;, flow6: Flow&lt;T6&gt;, flow7: Flow&lt;T7&gt;, crossinline transform: suspend (T1, T2, T3, T4, T5, T6, T7) -&gt; R )</ID>
    <ID>LongParameterList:Ext.kt$( flow: Flow&lt;T1&gt;, flow2: Flow&lt;T2&gt;, flow3: Flow&lt;T3&gt;, flow4: Flow&lt;T4&gt;, flow5: Flow&lt;T5&gt;, flow6: Flow&lt;T6&gt;, flow7: Flow&lt;T7&gt;, flow8: Flow&lt;T8&gt;, crossinline transform: suspend (T1, T2, T3, T4, T5, T6, T7, T8) -&gt; R )</ID>
    <ID>LongParameterList:Ext.kt$( flow: Flow&lt;T1&gt;, flow2: Flow&lt;T2&gt;, flow3: Flow&lt;T3&gt;, flow4: Flow&lt;T4&gt;, flow5: Flow&lt;T5&gt;, flow6: Flow&lt;T6&gt;, flow7: Flow&lt;T7&gt;, flow8: Flow&lt;T8&gt;, flow9: Flow&lt;T9&gt;, crossinline transform: suspend (T1, T2, T3, T4, T5, T6, T7, T8, T9) -&gt; R )</ID>
    <ID>LongParameterList:Ext.kt$( flow: Flow&lt;T1&gt;, flow2: Flow&lt;T2&gt;, flow3: Flow&lt;T3&gt;, flow4: Flow&lt;T4&gt;, flow5: Flow&lt;T5&gt;, flow6: Flow&lt;T6&gt;, flow7: Flow&lt;T7&gt;, flow8: Flow&lt;T8&gt;, flow9: Flow&lt;T9&gt;, flow10: Flow&lt;T10&gt;, crossinline transform: suspend (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) -&gt; R )</ID>
    <ID>LongParameterList:Ext.kt$( flow: Flow&lt;T1&gt;, flow2: Flow&lt;T2&gt;, flow3: Flow&lt;T3&gt;, flow4: Flow&lt;T4&gt;, flow5: Flow&lt;T5&gt;, flow6: Flow&lt;T6&gt;, flow7: Flow&lt;T7&gt;, flow8: Flow&lt;T8&gt;, flow9: Flow&lt;T9&gt;, flow10: Flow&lt;T10&gt;, flow11: Flow&lt;T11&gt;, crossinline transform: suspend (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) -&gt; R )</ID>
    <ID>LongParameterList:Ext.kt$( flow: Flow&lt;T1&gt;, flow2: Flow&lt;T2&gt;, flow3: Flow&lt;T3&gt;, flow4: Flow&lt;T4&gt;, flow5: Flow&lt;T5&gt;, flow6: Flow&lt;T6&gt;, flow7: Flow&lt;T7&gt;, flow8: Flow&lt;T8&gt;, flow9: Flow&lt;T9&gt;, flow10: Flow&lt;T10&gt;, flow11: Flow&lt;T11&gt;, flow12: Flow&lt;T12&gt;, crossinline transform: suspend (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) -&gt; R )</ID>
    <ID>LongParameterList:Ext.kt$( flow: Flow&lt;T1&gt;, flow2: Flow&lt;T2&gt;, flow3: Flow&lt;T3&gt;, flow4: Flow&lt;T4&gt;, flow5: Flow&lt;T5&gt;, flow6: Flow&lt;T6&gt;, flow7: Flow&lt;T7&gt;, flow8: Flow&lt;T8&gt;, flow9: Flow&lt;T9&gt;, flow10: Flow&lt;T10&gt;, flow11: Flow&lt;T11&gt;, flow12: Flow&lt;T12&gt;, flow13: Flow&lt;T13&gt;, crossinline transform: suspend (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) -&gt; R )</ID>
    <ID>LongParameterList:Extrinsic.kt$( dexId: Int, inputAssetId: String, outputAssetId: String, amount: BigInteger, limit: BigInteger, filter: String, markets: List&lt;String&gt;, desired: WithDesired )</ID>
    <ID>LongParameterList:MapFundInfoToCrowdloan.kt$( fundInfo: FundInfo, parachainMetadata: ParachainMetadata?, parachainId: BigInteger, currentBlockNumber: BlockNumber, expectedBlockTimeInMillis: BigInteger, blocksPerLeasePeriod: BigInteger, leaseOffset: BigInteger, contribution: Contribution?, hasWonAuction: Boolean, minContribution: BigInteger = BigInteger.ZERO )</ID>
    <ID>LongParameterList:MetaAccount.kt$( id: Long, substratePublicKey: ByteArray, substrateCryptoType: CryptoType, substrateAccountId: ByteArray, ethereumAddress: ByteArray?, ethereumPublicKey: ByteArray?, isSelected: Boolean, name: String )</ID>
    <ID>LongParameterList:OperationLocal.kt$OperationLocal.Companion$( hash: String, address: String, chainId: String, chainAssetId: String, amount: BigInteger, senderAddress: String, receiverAddress: String, fee: BigInteger?, status: Status, source: Source )</ID>
    <ID>LongParameterList:OperationParcelizeModel.kt$OperationParcelizeModel.Swap$( val id: String, val address: String, val hash: String, val time: Long, val module: String, val chainAsset: Asset, val targetAsset: Asset?, val baseAssetAmount: BigInteger, val liquidityProviderFee: BigInteger, val selectedMarket: String?, val targetAssetAmount: BigInteger?, val networkFee: BigInteger, val status: Operation.Status )</ID>
    <ID>LongParameterList:PolkaswapInteractor.kt$PolkaswapInteractor$( dexId: Int, inputAssetId: String, outputAssetId: String, amount: BigInteger, limit: BigInteger, filter: String, markets: List&lt;String&gt;, desired: WithDesired )</ID>
    <ID>LongParameterList:PolkaswapRepository.kt$PolkaswapRepository$( chainId: ChainId, dexId: Int, inputAssetId: String, outputAssetId: String, amount: BigInteger, limit: BigInteger, filter: String, markets: List&lt;String&gt;, desired: WithDesired )</ID>
    <ID>LongParameterList:SetControllerViewModel.kt$SetControllerViewModel$( private val interactor: ControllerInteractor, private val stakingInteractor: StakingInteractor, relayChainInteractor: StakingRelayChainScenarioInteractor, private val addressIconGenerator: AddressIconGenerator, private val router: StakingRouter, private val externalActions: ExternalAccountActions.Presentation, private val appLinksProvider: AppLinksProvider, private val resourceManager: ResourceManager, private val addressDisplayUseCase: AddressDisplayUseCase, private val validationExecutor: ValidationExecutor, private val validationSystem: SetControllerValidationSystem, savedStateHandle: SavedStateHandle )</ID>
    <ID>LongParameterList:SetupStakingViewModel.kt$SetupStakingViewModel$( private val router: StakingRouter, private val interactor: StakingInteractor, private val stakingScenarioInteractor: StakingScenarioInteractor, private val rewardCalculatorFactory: RewardCalculatorFactory, private val resourceManager: ResourceManager, private val setupStakingInteractor: SetupStakingInteractor, private val setupStakingSharedState: SetupStakingSharedState, private val validationExecutor: ValidationExecutor, @Named("StakingFeeLoader") private val feeLoaderMixin: FeeLoaderMixin.Presentation, private val rewardDestinationMixin: RewardDestinationMixin.Presentation, private val addressIconGenerator: AddressIconGenerator, private val stakingSharedState: StakingSharedState )</ID>
    <ID>LongParameterList:StakingFeatureModule.kt$StakingFeatureModule$( accountRepository: AccountRepository, stakingRepository: StakingRepository, stakingRewardsRepository: StakingRewardsRepository, stakingSharedState: StakingSharedState, chainStateRepository: IChainStateRepository, chainRegistry: ChainRegistry, addressIconGenerator: AddressIconGenerator, walletRepository: WalletRepository )</ID>
    <ID>LongParameterList:StakingFeatureModule.kt$StakingFeatureModule$( api: StakingPoolApi, dataSource: StakingPoolDataSource, stakingInteractor: StakingInteractor, accountRepository: AccountRepository, relayChainScenarioRepository: StakingRelayChainScenarioRepository, identityRepository: IdentityRepository, walletConstants: WalletConstants, validatorProvider: ValidatorProvider, currentValidatorsInteractor: CurrentValidatorsInteractor )</ID>
    <ID>LongParameterList:StakingFeatureModule.kt$StakingFeatureModule$( interactor: StakingInteractor, accountRepository: AccountRepository, stakingConstantsRepository: StakingConstantsRepository, stakingParachainScenarioRepository: StakingParachainScenarioRepository, identityRepository: IdentityRepository, stakingSharedState: StakingSharedState, iconGenerator: AddressIconGenerator, resourceManager: ResourceManager, delegationHistoryFetcher: SubQueryDelegationHistoryFetcher, walletRepository: WalletRepository )</ID>
    <ID>LongParameterList:StakingFeatureModule.kt$StakingFeatureModule$( interactor: StakingInteractor, accountRepository: AccountRepository, stakingConstantsRepository: StakingConstantsRepository, walletRepository: WalletRepository, stakingRewardsRepository: StakingRewardsRepository, factory: EraTimeCalculatorFactory, stakingSharedState: StakingSharedState, stakingRelayChainScenarioRepository: StakingRelayChainScenarioRepository, identityRepository: IdentityRepository, payoutRepository: PayoutRepository, walletConstants: WalletConstants )</ID>
    <ID>LongParameterList:StakingFeatureModule.kt$StakingFeatureModule$( resourceManager: ResourceManager, appLinksProvider: AppLinksProvider, stakingInteractor: StakingInteractor, stakingRelayChainScenarioInteractor: StakingRelayChainScenarioInteractor, iconGenerator: AddressIconGenerator, accountDisplayUseCase: AddressDisplayUseCase, sharedState: StakingSharedState, soraStakingRewardsScenario: SoraStakingRewardsScenario )</ID>
    <ID>LongParameterList:StakingModule.kt$StakingModule$( interactor: StakingInteractor, setupStakingSharedState: SetupStakingSharedState, resourceManager: ResourceManager, rewardCalculatorFactory: RewardCalculatorFactory, router: StakingRouter, validationExecutor: ValidationExecutor, relayChainScenarioInteractor: StakingRelayChainScenarioInteractor, parachainScenarioInteractor: StakingParachainScenarioInteractor, stakingRewardsScenario: SoraStakingRewardsScenario )</ID>
    <ID>LongParameterList:StakingScenario.kt$StakingScenario$( private val state: StakingSharedState, private val baseViewModel: BaseStakingViewModel, private val stakingInteractor: StakingInteractor, private val parachainInteractor: StakingParachainScenarioInteractor, private val relaychainInteractor: StakingRelayChainScenarioInteractor, private val rewardCalculatorFactory: RewardCalculatorFactory, private val resourceManager: ResourceManager, private val alertsInteractor: AlertsInteractor, private val stakingViewStateFactory: StakingViewStateFactory, private val stakingPoolInteractor: StakingPoolInteractor, private val stakingParachainStoriesDataSourceImpl: ParachainStakingStoriesDataSourceImpl, private val stakingStoriesDataSourceImpl: StakingStoriesDataSourceImpl )</ID>
    <ID>LongParameterList:StakingUpdatersModule.kt$StakingUpdatersModule$( activeEraUpdater: ActiveEraUpdater, validatorExposureUpdater: ValidatorExposureUpdater, totalIssuanceUpdater: TotalIssuanceUpdater, currentEraUpdater: CurrentEraUpdater, stakingLedgerUpdater: StakingLedgerUpdater, accountValidatorPrefsUpdater: AccountValidatorPrefsUpdater, accountNominationsUpdater: AccountNominationsUpdater, rewardDestinationUpdater: AccountRewardDestinationUpdater, historyDepthUpdater: HistoryDepthUpdater, historicalUpdateMediator: HistoricalUpdateMediator, accountControllerBalanceUpdater: AccountControllerBalanceUpdater, minBondUpdater: MinBondUpdater, maxNominatorsUpdater: MaxNominatorsUpdater, counterForNominatorsUpdater: CounterForNominatorsUpdater, delegatorStateUpdater: DelegatorStateUpdater, @Named("StakingBlockNumberUpdater") blockNumberUpdater: BlockNumberUpdater, chainRegistry: ChainRegistry, stakingSharedState: StakingSharedState )</ID>
    <ID>LongParameterList:StakingUpdatersModule.kt$StakingUpdatersModule$( stakingRelayChainScenarioRepository: StakingRelayChainScenarioRepository, sharedState: StakingSharedState, chainRegistry: ChainRegistry, accountStakingDao: AccountStakingDao, assetCache: AssetCache, storageCache: StorageCache, updatesMixin: UpdatesMixin, accountUpdateScope: AccountUpdateScope )</ID>
    <ID>LongParameterList:StakingViewModel.kt$StakingViewModel$( private val interactor: StakingInteractor, alertsInteractor: AlertsInteractor, stakingViewStateFactory: StakingViewStateFactory, private val router: StakingRouter, private val resourceManager: ResourceManager, private val validationExecutor: ValidationExecutor, @Named("StakingChainUpdateSystem") stakingUpdateSystem: UpdateSystem, private val stakingSharedState: StakingSharedState, parachainScenarioInteractor: StakingParachainScenarioInteractor, relayChainScenarioInteractor: StakingRelayChainScenarioInteractor, private val rewardCalculatorFactory: RewardCalculatorFactory, private val setupStakingSharedState: SetupStakingSharedState, stakingPoolInteractor: StakingPoolInteractor, private val stakingPoolSharedStateProvider: StakingPoolSharedStateProvider, private val stakingParachainStoriesDataSourceImpl: ParachainStakingStoriesDataSourceImpl, private val stakingStoriesDataSourceImpl: StakingStoriesDataSourceImpl, private val setupStakingInteractor: SetupStakingInteractor )</ID>
    <ID>LongParameterList:Transfer.kt$Transfer$( senderTransferable: BigDecimal, senderTotal: BigDecimal, fee: BigDecimal, recipientBalance: BigDecimal, existentialDeposit: BigDecimal, isUtilityToken: Boolean, senderUtilityBalance: BigDecimal, utilityExistentialDeposit: BigDecimal, tip: BigDecimal? = null )</ID>
    <ID>LongParameterList:ValidatorDetailsModel.kt$CollatorDetailsModel$( val address: String, val addressImage: PictureDrawable, val identity: IdentityModel?, val statusText: String, val statusColor: Int, val delegations: String, val estimatedRewardsApr: String, val totalStake: String?, val totalStakeFiat: String?, val minBond: String, val selfBonded: String, val effectiveAmountBonded: String )</ID>
    <ID>LongParameterList:WalletFeatureModule.kt$WalletFeatureModule$( substrateSource: SubstrateRemoteSource, operationsDao: OperationDao, httpExceptionHandler: HttpExceptionHandler, phishingApi: PhishingApi, phishingDao: PhishingDao, walletConstants: WalletConstants, assetCache: AssetCache, coingeckoApi: CoingeckoApi, chainRegistry: ChainRegistry, availableFiatCurrencies: GetAvailableFiatCurrencies, updatesMixin: UpdatesMixin, remoteConfigFetcher: RemoteConfigFetcher )</ID>
    <ID>LongParameterList:WalletFeatureModule.kt$WalletFeatureModule$( walletRepository: WalletRepository, addressBookRepository: AddressBookRepository, accountRepository: AccountRepository, historyRepository: HistoryRepository, chainRegistry: ChainRegistry, fileProvider: FileProvider, preferences: Preferences, selectedFiat: SelectedFiat, updatesMixin: UpdatesMixin, xcmEntitiesFetcher: XcmEntitiesFetcher )</ID>
    <ID>LongParameterList:WalletRepositoryImpl.kt$WalletRepositoryImpl$( private val substrateSource: SubstrateRemoteSource, private val operationDao: OperationDao, private val httpExceptionHandler: HttpExceptionHandler, private val phishingApi: PhishingApi, private val assetCache: AssetCache, private val walletConstants: WalletConstants, private val phishingDao: PhishingDao, private val coingeckoApi: CoingeckoApi, private val chainRegistry: ChainRegistry, private val availableFiatCurrencies: GetAvailableFiatCurrencies, private val updatesMixin: UpdatesMixin, private val remoteConfigFetcher: RemoteConfigFetcher )</ID>
    <ID>MagicNumber:AccountStakingScope.kt$AccountStakingScope$500</ID>
    <ID>MagicNumber:ActionBar.kt$3</ID>
    <ID>MagicNumber:AddressIconGenerator.kt$32</ID>
    <ID>MagicNumber:AddressInput.kt$0.4f</ID>
    <ID>MagicNumber:AlertSheet.kt$16</ID>
    <ID>MagicNumber:AssetChainsBadge.kt$0.33f</ID>
    <ID>MagicNumber:AssetChainsBadge.kt$0.5f</ID>
    <ID>MagicNumber:AssetListItem.kt$0.64f</ID>
    <ID>MagicNumber:AssetSelector.kt$0.64f</ID>
    <ID>MagicNumber:AssetsOrderMigration.kt$AssetsOrderMigration$34</ID>
    <ID>MagicNumber:AssetsOrderMigration.kt$AssetsOrderMigration$35</ID>
    <ID>MagicNumber:BalanceDetailsScreen.kt$16</ID>
    <ID>MagicNumber:BalanceModel.kt$BalanceModel$0.8</ID>
    <ID>MagicNumber:BeaconInteractor.kt$BeaconInteractor$256</ID>
    <ID>MagicNumber:BottomNavigationBar.kt$0.08f</ID>
    <ID>MagicNumber:BottomNavigationBar.kt$0.5f</ID>
    <ID>MagicNumber:Chain.kt$3</ID>
    <ID>MagicNumber:ChainAccountsAdapter.kt$ChainAccountHolder$0.4f</ID>
    <ID>MagicNumber:ChainExt.kt$20</ID>
    <ID>MagicNumber:ChainExt.kt$32</ID>
    <ID>MagicNumber:ComponentHolder.kt$ComponentHolder$3</ID>
    <ID>MagicNumber:ComponentHolder.kt$ComponentHolder$4</ID>
    <ID>MagicNumber:ComposeExt.kt$MultipleEventsCutter$300L</ID>
    <ID>MagicNumber:ControllerDeprecationWarningModel.kt$8</ID>
    <ID>MagicNumber:CrossChainSetupFragment.kt$CrossChainSetupFragment$500</ID>
    <ID>MagicNumber:CrossChainSetupViewModel.kt$CrossChainSetupViewModel$5</ID>
    <ID>MagicNumber:CryptoUtils.kt$20</ID>
    <ID>MagicNumber:CryptoUtils.kt$32</ID>
    <ID>MagicNumber:CryptoUtils.kt$64</ID>
    <ID>MagicNumber:DelegationScheduledRequest.kt$DelegationAction.Companion$3</ID>
    <ID>MagicNumber:EncryptionUtil.kt$EncryptionUtil$25</ID>
    <ID>MagicNumber:EthereumDerivationPathMigration.kt$EthereumDerivationPathMigration$31</ID>
    <ID>MagicNumber:EthereumDerivationPathMigration.kt$EthereumDerivationPathMigration$32</ID>
    <ID>MagicNumber:EthereumDerivationPathTransformer.kt$EthereumDerivationPathTransformer$11</ID>
    <ID>MagicNumber:EthereumDerivationPathTransformer.kt$EthereumDerivationPathTransformer$13</ID>
    <ID>MagicNumber:EthereumDerivationPathTransformer.kt$EthereumDerivationPathTransformer$4</ID>
    <ID>MagicNumber:EthereumDerivationPathTransformer.kt$EthereumDerivationPathTransformer$8</ID>
    <ID>MagicNumber:ExapandableText.kt$180f</ID>
    <ID>MagicNumber:ExpandableLazyListNestedScrollConnection.kt$ExpandableLazyListNestedScrollConnection$0.5f</ID>
    <ID>MagicNumber:ExportJsonPasswordFragment.kt$ExportJsonPasswordFragment$24</ID>
    <ID>MagicNumber:Ext.kt$0xFFFFFF</ID>
    <ID>MagicNumber:Ext.kt$10</ID>
    <ID>MagicNumber:Ext.kt$11</ID>
    <ID>MagicNumber:Ext.kt$12</ID>
    <ID>MagicNumber:Ext.kt$3</ID>
    <ID>MagicNumber:Ext.kt$4</ID>
    <ID>MagicNumber:Ext.kt$5</ID>
    <ID>MagicNumber:Ext.kt$6</ID>
    <ID>MagicNumber:Ext.kt$7</ID>
    <ID>MagicNumber:Ext.kt$8</ID>
    <ID>MagicNumber:Ext.kt$9</ID>
    <ID>MagicNumber:Extensions.kt$1000</ID>
    <ID>MagicNumber:Extensions.kt$3600</ID>
    <ID>MagicNumber:Extensions.kt$60</ID>
    <ID>MagicNumber:Extensions.kt$&lt;no name provided&gt;$1000</ID>
    <ID>MagicNumber:FearlessLibExt.kt$20</ID>
    <ID>MagicNumber:FearlessLibExt.kt$32</ID>
    <ID>MagicNumber:FundInfo.kt$32</ID>
    <ID>MagicNumber:GetSoraCardScreen.kt$0xFF131313</ID>
    <ID>MagicNumber:GetSoraCardScreen.kt$0xFF1D1D1F</ID>
    <ID>MagicNumber:GetSoraCardScreen.kt$3</ID>
    <ID>MagicNumber:GetSoraCardScreen.kt$4</ID>
    <ID>MagicNumber:HashExt.kt$5</ID>
    <ID>MagicNumber:HiddenAssetsItem.kt$180f</ID>
    <ID>MagicNumber:InterlayContributeInteractor.kt$InterlayContributeInteractor$66</ID>
    <ID>MagicNumber:MoonbeamContributeInteractor.kt$MoonbeamContributeInteractor$10</ID>
    <ID>MagicNumber:MoonbeamContributeInteractor.kt$MoonbeamContributeInteractor$20</ID>
    <ID>MagicNumber:MoonbeamContributeViewState.kt$MoonbeamCrowdloanStep.CONTRIBUTE$3</ID>
    <ID>MagicNumber:MoonbeamContributeViewState.kt$MoonbeamCrowdloanStep.CONTRIBUTE_CONFIRM$4</ID>
    <ID>MagicNumber:MoonbeamStep4Contribute.kt$MoonbeamStep4Contribute$42</ID>
    <ID>MagicNumber:NftStub.kt$0.16f</ID>
    <ID>MagicNumber:NominatedValidator.kt$NominatedValidator.Status.Group.WaitingForNextEra$3</ID>
    <ID>MagicNumber:PaymentUpdater.kt$9420</ID>
    <ID>MagicNumber:PolkaswapDisclaimerScreen.kt$0.5f</ID>
    <ID>MagicNumber:PolkaswapInteractorImpl.kt$PolkaswapInteractorImpl$500</ID>
    <ID>MagicNumber:PullRefreshBox.kt$400</ID>
    <ID>MagicNumber:QrCodeGenerator.kt$QrCodeGenerator$0.5</ID>
    <ID>MagicNumber:QuickInput.kt$QuickAmountInput.P25$0.25</ID>
    <ID>MagicNumber:QuickInput.kt$QuickAmountInput.P50$0.5</ID>
    <ID>MagicNumber:QuickInput.kt$QuickAmountInput.P75$0.75</ID>
    <ID>MagicNumber:QuickInput.kt$TestQuickInput.P25$0.25</ID>
    <ID>MagicNumber:QuickInput.kt$TestQuickInput.P50$0.5</ID>
    <ID>MagicNumber:QuickInput.kt$TestQuickInput.P75$0.75</ID>
    <ID>MagicNumber:RootActivity.kt$RootActivity$500</ID>
    <ID>MagicNumber:SelectPoolScreen.kt$15</ID>
    <ID>MagicNumber:SelectValidatorsScreen.kt$0.3f</ID>
    <ID>MagicNumber:SelectValidatorsScreen.kt$15</ID>
    <ID>MagicNumber:SelectableListItem.kt$15</ID>
    <ID>MagicNumber:SelectedValidatorsScreen.kt$15</ID>
    <ID>MagicNumber:SendSetupFragment.kt$SendSetupFragment$500</ID>
    <ID>MagicNumber:SendSetupViewModel.kt$SendSetupViewModel$5</ID>
    <ID>MagicNumber:SetupStakingInteractor.kt$SetupStakingInteractor$16</ID>
    <ID>MagicNumber:SetupStakingInteractor.kt$SetupStakingInteractor$20</ID>
    <ID>MagicNumber:SetupStakingInteractor.kt$SetupStakingInteractor$32</ID>
    <ID>MagicNumber:StakeInfoViewState.kt$10000L</ID>
    <ID>MagicNumber:StakingConstantsRepository.kt$StakingConstantsRepository$16</ID>
    <ID>MagicNumber:StakingConstantsRepository.kt$StakingConstantsRepository$24</ID>
    <ID>MagicNumber:StakingFragment.kt$StakingFragment$16f</ID>
    <ID>MagicNumber:StakingFragment.kt$StakingFragment$52f</ID>
    <ID>MagicNumber:StakingInfoItem.kt$123123L</ID>
    <ID>MagicNumber:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$1000</ID>
    <ID>MagicNumber:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$24</ID>
    <ID>MagicNumber:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$60</ID>
    <ID>MagicNumber:StakingParachainScenarioViewModel.kt$StakingParachainScenarioViewModel$1.1</ID>
    <ID>MagicNumber:StakingPoolApi.kt$StakingPoolApi$9390</ID>
    <ID>MagicNumber:StakingPoolInteractor.kt$StakingPoolInteractor$10</ID>
    <ID>MagicNumber:StakingPoolInteractor.kt$StakingPoolInteractor$18</ID>
    <ID>MagicNumber:StakingPoolInteractor.kt$StakingPoolInteractor$32</ID>
    <ID>MagicNumber:StakingViewStateOld.kt$DelegatorViewState$1000</ID>
    <ID>MagicNumber:StakingViewStateOld.kt$DelegatorViewState$60</ID>
    <ID>MagicNumber:SubqueryRewardCalculator.kt$SubqueryRewardCalculator$0.025</ID>
    <ID>MagicNumber:SwapTokensViewModel.kt$SwapTokensViewModel$0.003</ID>
    <ID>MagicNumber:SwipeBox.kt$0.3f</ID>
    <ID>MagicNumber:Timer.kt$Timer$1000</ID>
    <ID>MagicNumber:Toolbar.kt$4f</ID>
    <ID>MagicNumber:Toolbar.kt$Toolbar$10</ID>
    <ID>MagicNumber:Toolbar.kt$Toolbar$16</ID>
    <ID>MagicNumber:TransactionSettingsContent.kt$0.5f</ID>
    <ID>MagicNumber:TransactionSettingsContent.kt$SlippageToleranceQuickInput.MEDIUM$0.5</ID>
    <ID>MagicNumber:TransactionSettingsContent.kt$SlippageToleranceQuickInput.SMALL$0.1</ID>
    <ID>MagicNumber:Unbonding.kt$1000</ID>
    <ID>MagicNumber:V2Migration.kt$V2Migration$28</ID>
    <ID>MagicNumber:V2Migration.kt$V2Migration$29</ID>
    <ID>MagicNumber:V2MigrationTest.kt$V2MigrationTest$26</ID>
    <ID>MagicNumber:V2MigrationTest.kt$V2MigrationTest$27</ID>
    <ID>MagicNumber:WalletInteractorImpl.kt$WalletInteractorImpl$4</ID>
    <ID>MagicNumber:WarningInfo.kt$180f</ID>
    <ID>MaxLineLength:AboutFragment.kt$AboutFragment$override</ID>
    <ID>MaxLineLength:AboutViewModel.kt$AboutViewModel$val uiState: StateFlow&lt;AboutState&gt; = flowOf(AboutState(list)).stateIn(viewModelScope, SharingStarted.Eagerly, AboutState(list))</ID>
    <ID>MaxLineLength:AcalaContributeFactory.kt$AcalaContributeFactory$override fun createView(context: Context, step: MoonbeamCrowdloanStep?): CustomContributeView</ID>
    <ID>MaxLineLength:AcalaContributeInteractor.kt$AcalaContributeInteractor$private suspend</ID>
    <ID>MaxLineLength:AcalaContributeInteractor.kt$AcalaContributeInteractor$suspend</ID>
    <ID>MaxLineLength:AcalaContributeSubmitter.kt$AcalaContributeSubmitter$override suspend</ID>
    <ID>MaxLineLength:AcalaContributeViewState.kt$AcalaContributeViewState$emailValid.not() -&gt; ApplyActionState.Unavailable(reason = resourceManager.getString(R.string.crowdloan_empty_email_title))</ID>
    <ID>MaxLineLength:AcalaContributeViewState.kt$AcalaContributeViewState$if (!isReferralValid) throw IllegalArgumentException(resourceManager.getString(R.string.crowdloan_acala_referral_code_invalid))</ID>
    <ID>MaxLineLength:AcalaContributeViewState.kt$AcalaContributeViewState$override</ID>
    <ID>MaxLineLength:AcalaContributeViewState.kt$AcalaContributeViewState$referral.isEmpty() -&gt; ApplyActionState.Unavailable(reason = resourceManager.getString(R.string.crowdloan_enter_referral))</ID>
    <ID>MaxLineLength:AccountDataSourceImpl.kt$AccountDataSourceImpl$override suspend</ID>
    <ID>MaxLineLength:AccountDataSourceImpl.kt$AccountDataSourceImpl$return</ID>
    <ID>MaxLineLength:AccountDetailsFragment.kt$AccountDetailsFragment$class</ID>
    <ID>MaxLineLength:AccountDetailsInteractor.kt$AccountDetailsInteractor$val hasAccount = !chain.isEthereumBased || metaAccount.ethereumPublicKey != null || metaAccount.hasChainAccount(chain.id)</ID>
    <ID>MaxLineLength:AccountDetailsViewModel.kt$AccountDetailsViewModel$externalAccountActions.showExternalActions(ExternalAccountActions.Payload(item.address, item.chainId, item.chainName, supportedExplorers))</ID>
    <ID>MaxLineLength:AccountDetailsViewModel.kt$AccountDetailsViewModel$hasChainAccount -&gt; interactor.getChainAccountSecret(metaId, chainId).buildExportSourceTypes(isEthereumBased)</ID>
    <ID>MaxLineLength:AccountDetailsViewModel.kt$AccountDetailsViewModel$val supportedExplorers = chainRegistry.getChain(item.chainId).explorers.getSupportedExplorers(BlockExplorerUrlBuilder.Type.ACCOUNT, item.address)</ID>
    <ID>MaxLineLength:AccountInteractorImpl.kt$AccountInteractorImpl$accountRepository.importChainFromSeed(metaId, chainId, accountName, seed, substrateDerivationPath, selectedEncryptionType)</ID>
    <ID>MaxLineLength:AccountInteractorImpl.kt$AccountInteractorImpl$override suspend fun getChainAccountSecrets(metaId: Long, chainId: ChainId)</ID>
    <ID>MaxLineLength:AccountNominationsUpdater.kt$AccountNominationsUpdater$)</ID>
    <ID>MaxLineLength:AccountRepositoryImpl.kt$AccountRepositoryImpl$override suspend</ID>
    <ID>MaxLineLength:AccountRepositoryImpl.kt$AccountRepositoryImpl$saveChainAccountFromMnemonic(metaId, chainId, accountName, mnemonicWords, cryptoType, substrateDerivationPath, ethereumDerivationPath)</ID>
    <ID>MaxLineLength:AccountRepositoryImpl.kt$AccountRepositoryImpl$substrateCryptoType = mapEncryptionToCryptoType(substrateImportData.multiChainEncryption.encryptionType)</ID>
    <ID>MaxLineLength:AccountRepositoryImpl.kt$AccountRepositoryImpl$val account = accountDao.getAccount(address) ?: throw NoSuchElementException("No account found for address $address")</ID>
    <ID>MaxLineLength:AccountRepositoryImpl.kt$AccountRepositoryImpl$val address = metaAccount.address(chain) ?: throw IllegalArgumentException("No address specified for chain ${chain.name}")</ID>
    <ID>MaxLineLength:AccountRepositoryImpl.kt$AccountRepositoryImpl$val ethereumDerivationPathOrDefault = ethereumDerivationPath.nullIfEmpty() ?: BIP32JunctionDecoder.DEFAULT_DERIVATION_PATH</ID>
    <ID>MaxLineLength:AccountRepositoryImpl.kt$AccountRepositoryImpl$val ethereumKeypair = EthereumKeypairFactory.generate(ethereumSeed, junctions = decodedEthereumDerivationPath.junctions)</ID>
    <ID>MaxLineLength:AccountRepositoryImpl.kt$AccountRepositoryImpl$val ethereumSeed = EthereumSeedFactory.deriveSeed32(mnemonicWords, password = decodedEthereumDerivationPath.password).seed</ID>
    <ID>MaxLineLength:AccountRepositoryImpl.kt$AccountRepositoryImpl$val multiChainEncryption = if (chain.isEthereumBased) MultiChainEncryption.Ethereum else MultiChainEncryption.Substrate(cryptoType)</ID>
    <ID>MaxLineLength:AccountRewardDestinationUpdater.kt$AccountRewardDestinationUpdater$)</ID>
    <ID>MaxLineLength:AccountRouter.kt$AccountRouter$fun</ID>
    <ID>MaxLineLength:AccountStakingDao.kt$AccountStakingDao$protected</ID>
    <ID>MaxLineLength:AccountStakingScope.kt$AccountStakingScope$StakingType.RELAYCHAIN -&gt; accountStakingDao.observeDistinct(chain.id, chainAsset.id, account.accountId(chain)!!)</ID>
    <ID>MaxLineLength:AccountValidatorPrefsUpdater.kt$AccountValidatorPrefsUpdater$)</ID>
    <ID>MaxLineLength:AccountsForExportFragment.kt$AccountsForExportFragment$class</ID>
    <ID>MaxLineLength:AccountsForExportFragment.kt$AccountsForExportFragment.Companion$fun getBundle(metaAccountId: Long, from: AccountInChain.From)</ID>
    <ID>MaxLineLength:AccountsForExportViewModel.kt$AccountsForExportViewModel$.</ID>
    <ID>MaxLineLength:AccountsForExportViewModel.kt$AccountsForExportViewModel$iconGenerator.createAddressIcon(it.accountId, AddressIconGenerator.SIZE_SMALL, backgroundColorRes = R.color.account_icon_dark)</ID>
    <ID>MaxLineLength:AddNodeViewModel.kt$AddNodeViewModel$name.isEmpty() -&gt; LabeledButtonState(ButtonState.DISABLED, resourceManager.getString(R.string.error_message_enter_the_name))</ID>
    <ID>MaxLineLength:AddressBookRepositoryImpl.kt$AddressBookRepositoryImpl$override fun observeAddressBook(chainId: ChainId): Flow&lt;List&lt;AddressBookContact&gt;&gt;</ID>
    <ID>MaxLineLength:AddressHistoryContent.kt$Address("Address 1 name of a very long text to show how it looks in UI", "address1qasd32dqa32e32r3qqed", R.drawable.ic_plus_circle, "", true)</ID>
    <ID>MaxLineLength:AddressHistoryViewModel.kt$AddressHistoryViewModel$addressIconGenerator.createAddressIcon(chain.isEthereumBased, contact.address, AddressIconGenerator.SIZE_BIG)</ID>
    <ID>MaxLineLength:AddressIconGenerator.kt$CachingAddressIconGenerator$override suspend</ID>
    <ID>MaxLineLength:AddressIconGenerator.kt$StatelessAddressIconGenerator$override suspend</ID>
    <ID>MaxLineLength:AddressIconGenerator.kt$suspend</ID>
    <ID>MaxLineLength:AlertsInteractor.kt$AlertsInteractor$fun</ID>
    <ID>MaxLineLength:AlertsInteractor.kt$AlertsInteractor$private</ID>
    <ID>MaxLineLength:AmountInput.kt$AmountInputViewState.Companion$fun</ID>
    <ID>MaxLineLength:AmountInput.kt$textStyle = MaterialTheme.customTypography.displayS.copy(textAlign = TextAlign.End, color = textColorState)</ID>
    <ID>MaxLineLength:AmountView.kt$AmountView$amountInput.inputType = if (enabled) InputType.TYPE_CLASS_NUMBER or InputType.TYPE_NUMBER_FLAG_DECIMAL else InputType.TYPE_NULL</ID>
    <ID>MaxLineLength:AppConfig.kt$fun AppConfigRemote.toDomain()</ID>
    <ID>MaxLineLength:AppDatabase.kt$AppDatabase.Companion$.</ID>
    <ID>MaxLineLength:Asset.kt$Asset$val transferableInPlanks = freeInPlanks?.let { it - miscFrozenInPlanks.orZero().max(feeFrozenInPlanks.orZero()) }.orZero()</ID>
    <ID>MaxLineLength:Asset.kt$Asset.Companion$token = Token(configuration = utilityAsset, fiatRate = null, fiatSymbol = null, recentRateChange = null)</ID>
    <ID>MaxLineLength:AssetCache.kt$AssetCache$cachedAsset == null -&gt; assetDao.insertAsset(builder.invoke(AssetLocal.createEmpty(accountId, assetId, chainId, metaId, priceId)))</ID>
    <ID>MaxLineLength:AssetDao.kt$AssetDao$@Query("DELETE FROM assets WHERE metaId = :metaId AND accountId = :accountId AND chainId = :chainId AND id = :assetId")</ID>
    <ID>MaxLineLength:AssetDao.kt$AssetDao$override</ID>
    <ID>MaxLineLength:AssetDao.kt$AssetDao$override suspend</ID>
    <ID>MaxLineLength:AssetListItem.kt$AssetListItem(state.copy(isTestnet = true, assetTransferableBalance = "123,456,123,456,123,456,789,456,789.01234")) {}</ID>
    <ID>MaxLineLength:AssetListItem.kt$val assetIconUrl = "https://raw.githubusercontent.com/soramitsu/fearless-utils/master/icons/chains/white/Polkadot.svg"</ID>
    <ID>MaxLineLength:AssetSelectContent.kt$CorneredInput(state = state.searchQuery, onInput = callback::onSearchInput, hintLabel = stringResource(id = R.string.assets_search_hint))</ID>
    <ID>MaxLineLength:AssetSelectContent.kt$imageUrl = "https://raw.githubusercontent.com/soramitsu/fearless-utils/master/icons/chains/white/Kusama.svg"</ID>
    <ID>MaxLineLength:AssetSelectContent.kt$imageUrl = "https://raw.githubusercontent.com/soramitsu/fearless-utils/master/icons/chains/white/Moonriver.svg"</ID>
    <ID>MaxLineLength:AssetSelectViewModel.kt$AssetSelectViewModel$.</ID>
    <ID>MaxLineLength:AssetSelectViewModel.kt$AssetSelectViewModel$val</ID>
    <ID>MaxLineLength:AssetSelector.kt$iconUrl = "https://raw.githubusercontent.com/soramitsu/fearless-utils/master/icons/chains/white/Karura.svg"</ID>
    <ID>MaxLineLength:AssetSelectorView.kt$AssetSelectorView$private</ID>
    <ID>MaxLineLength:AssetSelectorView.kt$AssetSelectorView$val backgroundStyle: BackgroundStyle = it.getEnum(R.styleable.AssetSelectorView_backgroundStyle, BackgroundStyle.BORDERED)</ID>
    <ID>MaxLineLength:AssetsList.kt$AssetsListInterface$fun</ID>
    <ID>MaxLineLength:AstarContributeFactory.kt$AstarContributeFactory$override fun createView(context: Context, step: MoonbeamCrowdloanStep?): CustomContributeView</ID>
    <ID>MaxLineLength:AstarContributeView.kt$AstarContributeView$findViewById&lt;InputField&gt;(R.id.referralReferralCodeInput).hint = context.getString(R.string.crowdloan_astar_referral_code_hint)</ID>
    <ID>MaxLineLength:AstarContributeViewState.kt$AstarContributeViewState$if (!isReferralValid) throw IllegalArgumentException(resourceManager.getString(R.string.crowdloan_astar_referral_code_invalid))</ID>
    <ID>MaxLineLength:AstarContributeViewState.kt$AstarContributeViewState$override</ID>
    <ID>MaxLineLength:AstarContributeViewState.kt$AstarContributeViewState$referral.isEmpty() -&gt; ApplyActionState.Unavailable(reason = resourceManager.getString(R.string.crowdloan_enter_referral_address))</ID>
    <ID>MaxLineLength:BalanceDetailFragment.kt$BalanceDetailFragment$override</ID>
    <ID>MaxLineLength:BalanceDetailViewModel.kt$BalanceDetailViewModel$is TransactionHistoryUi.SideEffect.Error -&gt; showError(it.message ?: resourceManager.getString(R.string.common_undefined_error_message))</ID>
    <ID>MaxLineLength:BalanceDetailViewModel.kt$BalanceDetailViewModel$transferableBalance = balanceModel.transferable.orZero().formatCryptoDetail(balanceModel.token.configuration.symbol)</ID>
    <ID>MaxLineLength:BalanceDetailViewModel.kt$BalanceDetailViewModel$val newTransferableState = defaultState.transferableViewState.copy(value = transferableFormatted, additionalValue = transferableFiat)</ID>
    <ID>MaxLineLength:BalanceDetailViewModel.kt$BalanceDetailViewModel$val transferableFiat = balanceModel.token.fiatAmount(balanceModel.transferable)?.formatFiat(balanceModel.token.fiatSymbol)</ID>
    <ID>MaxLineLength:BalanceDetailViewModel.kt$BalanceDetailViewModel$val transferableFormatted = balanceModel.transferable.formatCryptoDetail(balanceModel.token.configuration.symbol)</ID>
    <ID>MaxLineLength:BalanceDetailsScreen.kt$private</ID>
    <ID>MaxLineLength:BalanceListFragment.kt$BalanceListFragment$override</ID>
    <ID>MaxLineLength:BalanceListFragment.kt$BalanceListFragment$private</ID>
    <ID>MaxLineLength:BalanceListViewModel.kt$BalanceListViewModel$)</ID>
    <ID>MaxLineLength:BalanceListViewModel.kt$BalanceListViewModel$chains.groupBy { if (it.isTestNet) ChainEcosystem.STANDALONE else it.ecosystem() }</ID>
    <ID>MaxLineLength:BalanceListViewModel.kt$BalanceListViewModel$override</ID>
    <ID>MaxLineLength:BalanceListViewModel.kt$BalanceListViewModel$private</ID>
    <ID>MaxLineLength:BalanceListViewModel.kt$BalanceListViewModel$val accessTokenExpired = accessTokenExpirationTime &lt; TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis())</ID>
    <ID>MaxLineLength:BalanceListViewModel.kt$BalanceListViewModel$val hasFreeKycAttempt = kycRepository.hasFreeKycAttempt(soraCardInfo.accessToken).getOrNull()</ID>
    <ID>MaxLineLength:BalanceListViewModel.kt$BalanceListViewModel$val items = processAssets(chainAssets, listOf(chain), selectedChainId, networkIssues, hideZeroBalancesEnabled, ecosystem)</ID>
    <ID>MaxLineLength:BalanceListViewModel.kt$BalanceListViewModel$val items = processAssets(filtered, ecosystemChains, selectedChainId, networkIssues, hideZeroBalancesEnabled, ecosystem)</ID>
    <ID>MaxLineLength:BalanceModel.kt$BalanceModel$else -&gt; totalTransferableBalanceChange.divide(totalTransferableBalance, RoundingMode.HALF_UP).fractionToPercentage()</ID>
    <ID>MaxLineLength:BalanceModel.kt$BalanceModel$val toAdd = current.asset.availableFiat?.multiply(current.asset.token.recentRateChange.orZero())?.percentageToFraction().orZero()</ID>
    <ID>MaxLineLength:BalanceModel.kt$BalanceModel$val toAdd = current.asset.totalFiat?.multiply(current.asset.token.recentRateChange.orZero())?.percentageToFraction().orZero()</ID>
    <ID>MaxLineLength:BalancesUpdateSystem.kt$BalancesUpdateSystem$.</ID>
    <ID>MaxLineLength:BalancesUpdateSystem.kt$BalancesUpdateSystem$val queryResults = withContext(Dispatchers.IO) { bulkRetriever.queryKeys(socketService, storageKeyToMapId.keys.toList()) }</ID>
    <ID>MaxLineLength:BalancesUpdateSystem.kt$BalancesUpdateSystem$val runtime = runCatching { chainRegistry.getRuntime(chain.id) }.getOrNull() ?: return@singleChainUpdate</ID>
    <ID>MaxLineLength:BalancesUpdateSystem.kt$BalancesUpdateSystem$val socketService = runCatching { chainRegistry.getSocket(chain.id) }.getOrNull() ?: return@singleChainUpdate</ID>
    <ID>MaxLineLength:BaseBottomSheetDialogFragment.kt$BaseBottomSheetDialogFragment$abstract</ID>
    <ID>MaxLineLength:BaseConfirmViewModel.kt$BaseConfirmViewModel$open</ID>
    <ID>MaxLineLength:BaseConfirmViewModel.kt$BaseConfirmViewModel$throwable.localizedMessage ?: throwable.message ?: resourceManager.getString(R.string.common_undefined_error_message)</ID>
    <ID>MaxLineLength:BaseEnterAmountViewModel.kt$BaseEnterAmountViewModel$message = throwable.localizedMessage ?: throwable.message ?: resourceManager.getString(R.string.common_undefined_error_message)</ID>
    <ID>MaxLineLength:BeaconInteractor.kt$BeaconInteractor$beaconClient().respond(PermissionSubstrateResponse.from(request = request.copy(scopes = emptyList()), accounts = listOf(account), scopes = emptyList()))</ID>
    <ID>MaxLineLength:BeaconInteractor.kt$BeaconInteractor$return@map SubstrateAccount(network = it, publicKey = pubKey?.toHexString().orEmpty(), address = address.orEmpty(), client = beaconClient())</ID>
    <ID>MaxLineLength:BeaconInteractor.kt$BeaconInteractor$suspend</ID>
    <ID>MaxLineLength:BeaconInteractor.kt$BeaconInteractor$val secrets = accountRepository.getMetaAccountSecrets(currentMetaAccount.id) ?: error("There are no secrets for metaId: ${currentMetaAccount.id}")</ID>
    <ID>MaxLineLength:BeaconStateMachine.kt$BeaconStateMachine.SideEffect$AskSignApproval : SideEffect</ID>
    <ID>MaxLineLength:BeaconViewModel.kt$BeaconViewModel$Log.e(BeaconViewModel::class.java.name, it.localizedMessage ?: it.message ?: "Failed connect to beacon qr code")</ID>
    <ID>MaxLineLength:BifrostApi.kt$BifrostApi$suspend</ID>
    <ID>MaxLineLength:BifrostApi.kt$suspend fun BifrostApi.getAccountByReferralCode(code: String)</ID>
    <ID>MaxLineLength:BifrostContributeFactory.kt$BifrostContributeFactory$override fun createView(context: Context, step: MoonbeamCrowdloanStep?): CustomContributeView</ID>
    <ID>MaxLineLength:BifrostContributeViewState.kt$BifrostContributeViewState$override</ID>
    <ID>MaxLineLength:BindingHelpers.kt$fun &lt;T&gt; Type&lt;T&gt;.fromHexOrIncompatible(scale: String, runtime: RuntimeSnapshot)</ID>
    <ID>MaxLineLength:BlockProducer.kt$suspend</ID>
    <ID>MaxLineLength:BottomSheetScreen.kt$fun</ID>
    <ID>MaxLineLength:BottomSheetScreen.kt$val sheetBackgroundModifier = Modifier.background(backgroundBlack, RoundedCornerShape(topEnd = 24.dp, topStart = 24.dp))</ID>
    <ID>MaxLineLength:Button.kt$FearlessButton(text = text, enabled = enabled, textStyle = textStyle, colors = colors, modifier = modifier, onClick = onClick)</ID>
    <ID>MaxLineLength:Button.kt$TextButton(text = state.text, enabled = state.enabled, colors = accentButtonColors, modifier = modifier, onClick = onClick)</ID>
    <ID>MaxLineLength:Button.kt$TextButton(text = state.text, enabled = state.enabled, colors = accentDarkDisabledButtonColors, modifier = modifier, onClick = onClick)</ID>
    <ID>MaxLineLength:Button.kt$TextButton(text = text, enabled = enabled, colors = customButtonColors(Color.Unspecified, colorAccentDark), modifier = modifier, onClick = onClick)</ID>
    <ID>MaxLineLength:Button.kt$TextButton(text = text, enabled = enabled, colors = customButtonColors(grayButtonBackground), modifier = modifier, onClick = onClick)</ID>
    <ID>MaxLineLength:Button.kt$contentPadding = PaddingValues(vertical = 0.dp, horizontal = ButtonDefaults.TextButtonContentPadding.calculateLeftPadding(LayoutDirection.Ltr))</ID>
    <ID>MaxLineLength:BuyCryptoFragment.kt$BuyCryptoFragment$override</ID>
    <ID>MaxLineLength:BuyMixinProvider.kt$BuyMixinProvider$else -&gt; showProviderChooserEvent.value = Event(ProviderChooserPayload(availableProviders, asset, accountAddress))</ID>
    <ID>MaxLineLength:CapExceededValidation.kt$CapExceededValidation$raisedAmount &gt;= capAmount -&gt; ValidationStatus.NotValid(DefaultFailureLevel.ERROR, ContributeValidationFailure.CapExceeded.FromRaised)</ID>
    <ID>MaxLineLength:CapExceededValidation.kt$CapExceededValidation$val reason = ContributeValidationFailure.CapExceeded.FromAmount(maxAllowedContribution, token.configuration)</ID>
    <ID>MaxLineLength:Chain.kt$fun</ID>
    <ID>MaxLineLength:ChainAccountsAdapter.kt$ChainAccountHolder$AccountInChain.From.META_ACCOUNT -&gt; context.getCutLeftBottomCornerDrawableFromColors(context.getColor(R.color.white_50))</ID>
    <ID>MaxLineLength:ChainAccountsAdapter.kt$ChainAccountHolder$findViewById&lt;TextView&gt;(R.id.chainAccountAccountAddress).text = if (item.isSupported) item.address else resources.getString(R.string.common_unsupported)</ID>
    <ID>MaxLineLength:ChainDao.kt$ChainDao$deleteChains(newOrUpdated.map(JoinedChainInfo::chain))</ID>
    <ID>MaxLineLength:ChainRegistry.kt$ChainRegistry$fun</ID>
    <ID>MaxLineLength:ChainRegistry.kt$ChainRegistry$suspend fun updateNode(id: NodeId, name: String, url: String)</ID>
    <ID>MaxLineLength:ChainSelectContent.kt$imageUrl = "https://raw.githubusercontent.com/soramitsu/fearless-utils/master/icons/chains/white/Kusama.svg"</ID>
    <ID>MaxLineLength:ChainSelectContent.kt$imageUrl = "https://raw.githubusercontent.com/soramitsu/fearless-utils/master/icons/chains/white/Moonriver.svg"</ID>
    <ID>MaxLineLength:ChainSelectViewModel.kt$ChainSelectViewModel$assetSpecified(assetId = chain.assets.filter { it.currencyId == tokenCurrencyId }[0].id, chainId = chain.id)</ID>
    <ID>MaxLineLength:ChainSelectViewModel.kt$ChainSelectViewModel$val</ID>
    <ID>MaxLineLength:ChainStateRepository.kt$ChainStateRepository$private fun currentBlockStorageKey(runtime: RuntimeSnapshot)</ID>
    <ID>MaxLineLength:ChainSyncService.kt$ChainSyncService$!it.disabled &amp;&amp; (it.assets?.isNotEmpty() == true) &amp;&amp; it.chainId != genshiroChainId // todo add genshiro type to json</ID>
    <ID>MaxLineLength:CollatorDetailsViewModel.kt$CollatorDetailsViewModel$effectiveAmountBonded = (collator.stake.totalStake - collator.stake.selfBonded).formatCryptoDetailFromPlanks(asset.token.configuration)</ID>
    <ID>MaxLineLength:CollatorDetailsViewModel.kt$CollatorDetailsViewModel$private suspend</ID>
    <ID>MaxLineLength:CollatorProvider.kt$CollatorProvider$stakingParachainScenarioRepository.getSelectedCandidates(chainId)?.filter { candidate -&gt; usedCollatorIds.any { it.contentEquals(candidate) }.not() }</ID>
    <ID>MaxLineLength:CollatorRecommendator.kt$CollatorRecommendator$override suspend</ID>
    <ID>MaxLineLength:CollatorRecommendatorFactory.kt$CollatorRecommendatorFactory$private suspend</ID>
    <ID>MaxLineLength:CollatorsAdapter.kt$CollatorDiffCallback$return oldItem.scoring == newItem.scoring &amp;&amp; oldItem.title == newItem.title &amp;&amp; oldItem.isChecked == newItem.isChecked</ID>
    <ID>MaxLineLength:CollatorsAdapter.kt$CollatorViewHolder$private val itemValidatorScoringPrimary: TextView by lazy { containerView.findViewById(R.id.itemValidatorScoringPrimary) }</ID>
    <ID>MaxLineLength:CollatorsAdapter.kt$CollatorViewHolder$private val itemValidatorScoringSecondary: TextView by lazy { containerView.findViewById(R.id.itemValidatorScoringSecondary) }</ID>
    <ID>MaxLineLength:ComposeExt.kt$fun</ID>
    <ID>MaxLineLength:ConfirmBondMoreViewModel.kt$ConfirmBondMoreViewModel$val supportedExplorers = chain.explorers.getSupportedExplorers(BlockExplorerUrlBuilder.Type.ACCOUNT, payload.stashAddress)</ID>
    <ID>MaxLineLength:ConfirmContributeViewModel.kt$ConfirmContributeViewModel$payload.metadata.isInterlay &amp;&amp; (it as? InterlayBonusPayload)?.referralCode.isNullOrEmpty().not()</ID>
    <ID>MaxLineLength:ConfirmContributeViewModel.kt$ConfirmContributeViewModel$val maxAllowedStatusLevel = if (suppressWarnings) TransferValidityLevel.Warning else TransferValidityLevel.Ok</ID>
    <ID>MaxLineLength:ConfirmContributeViewModel.kt$ConfirmContributeViewModel$val supportedExplorers = chain.explorers.getSupportedExplorers(BlockExplorerUrlBuilder.Type.ACCOUNT, accountAddress)</ID>
    <ID>MaxLineLength:ConfirmCreatePoolViewModel.kt$ConfirmCreatePoolViewModel$val nominator = TitleValueViewState(resourceManager.getString(R.string.pool_staking_nominator), nominatorDisplay)</ID>
    <ID>MaxLineLength:ConfirmCreatePoolViewModel.kt$ConfirmCreatePoolViewModel$val poolId = TitleValueViewState(resourceManager.getString(R.string.pool_staking_pool_id), createState.requirePoolId.toString())</ID>
    <ID>MaxLineLength:ConfirmCreatePoolViewModel.kt$ConfirmCreatePoolViewModel$val stateToggler = TitleValueViewState(resourceManager.getString(R.string.pool_staking_bouncer), stateTogglerDisplay)</ID>
    <ID>MaxLineLength:ConfirmCreatePoolViewModel.kt$private suspend</ID>
    <ID>MaxLineLength:ConfirmJoinPoolFragment.kt$ConfirmJoinPoolFragment$ConfirmJoinPoolScreen(state = state.value, onNavigationClick = viewModel::onBackClick, onConfirm = viewModel::onConfirm)</ID>
    <ID>MaxLineLength:ConfirmJoinPoolScreen.kt$GradientIcon(icon = state.assetIcon, color = colorAccentDark, modifier = Modifier.align(CenterHorizontally))</ID>
    <ID>MaxLineLength:ConfirmJoinPoolScreen.kt$assetIcon = GradientIconState.Remote("https://raw.githubusercontent.com/soramitsu/fearless-utils/master/icons/chains/white/Karura.svg", "ffffff")</ID>
    <ID>MaxLineLength:ConfirmMnemonicViewModel.kt$ConfirmMnemonicViewModel$interactor.createChainAccount(metaId, chainId, accountName, mnemonicString, cryptoType, substrateDerivationPath, ethereumDerivationPath)</ID>
    <ID>MaxLineLength:ConfirmMnemonicViewModel.kt$ConfirmMnemonicViewModel$val</ID>
    <ID>MaxLineLength:ConfirmMnemonicViewModel.kt$ConfirmMnemonicViewModel$val result = interactor.createAccount(accountName, mnemonicString, cryptoType, substrateDerivationPath, ethereumDerivationPath)</ID>
    <ID>MaxLineLength:ConfirmNominationsFragment.kt$ConfirmNominationsFragment$class</ID>
    <ID>MaxLineLength:ConfirmPayoutViewModel.kt$ConfirmPayoutViewModel$PayoutValidationFailure.CannotPayFee -&gt; R.string.common_not_enough_funds_title to R.string.common_not_enough_funds_message</ID>
    <ID>MaxLineLength:ConfirmPayoutViewModel.kt$ConfirmPayoutViewModel$PayoutValidationFailure.UnprofitablePayout -&gt; R.string.common_confirmation_title to R.string.staking_warning_tiny_payout</ID>
    <ID>MaxLineLength:ConfirmPayoutViewModel.kt$ConfirmPayoutViewModel$addressModelGenerator.createAddressModel(destinationAddress, AddressIconGenerator.SIZE_SMALL, destinationAddressDisplay)</ID>
    <ID>MaxLineLength:ConfirmPayoutViewModel.kt$ConfirmPayoutViewModel$val</ID>
    <ID>MaxLineLength:ConfirmPayoutViewModel.kt$ConfirmPayoutViewModel$val payoutStakersPayloads = payouts.map { MakePayoutPayload.PayoutStakersPayload(it.era, it.validatorAddress) }</ID>
    <ID>MaxLineLength:ConfirmPoolRedeemViewModel.kt$ConfirmPoolRedeemViewModel$feeEstimator = { stakingPoolInteractor.estimateRedeemFee(requireNotNull(poolSharedStateProvider.mainState.get()?.address)) }</ID>
    <ID>MaxLineLength:ConfirmPoolUnbondViewModel.kt$ConfirmPoolUnbondViewModel$feeEstimator = { stakingPoolInteractor.estimateUnstakeFee(poolSharedStateProvider.requireMainState.requireAddress, requireNotNull(it)) }</ID>
    <ID>MaxLineLength:ConfirmRebondViewModel.kt$ConfirmRebondViewModel$val supportedExplorers = chain.explorers.getSupportedExplorers(BlockExplorerUrlBuilder.Type.ACCOUNT, originAddressModel.address)</ID>
    <ID>MaxLineLength:ConfirmRewardDestinationFragment.kt$ConfirmRewardDestinationFragment$class</ID>
    <ID>MaxLineLength:ConfirmRewardDestinationFragment.kt$ConfirmRewardDestinationFragment$viewModel.rewardDestinationLiveData.observe(binding.confirmRewardDestinationRewardDestination::showRewardDestination)</ID>
    <ID>MaxLineLength:ConfirmRewardDestinationViewModel.kt$ConfirmRewardDestinationViewModel$val addressModel = addressIconGenerator.createAddressModel(address, AddressIconGenerator.SIZE_SMALL, accountDisplay)</ID>
    <ID>MaxLineLength:ConfirmScreen.kt$GradientIcon(icon = state.assetIcon, color = colorAccentDark, modifier = Modifier.align(Alignment.CenterHorizontally))</ID>
    <ID>MaxLineLength:ConfirmScreen.kt$assetIcon = GradientIconState.Remote("https://raw.githubusercontent.com/soramitsu/fearless-utils/master/icons/chains/white/Karura.svg", "")</ID>
    <ID>MaxLineLength:ConfirmSelectValidatorsViewModel.kt$ConfirmSelectValidatorsViewModel$override</ID>
    <ID>MaxLineLength:ConfirmSendViewModel.kt$ConfirmSendViewModel$clickState = phishingType?.let { TitleValueViewState.ClickState.Value(R.drawable.ic_alert_16, ConfirmSendViewState.CODE_WARNING_CLICK) }</ID>
    <ID>MaxLineLength:ConfirmSendViewModel.kt$ConfirmSendViewModel$private val _openValidationWarningEvent = MutableLiveData&lt;Event&lt;Pair&lt;TransferValidationResult, ValidationWarning&gt;&gt;&gt;()</ID>
    <ID>MaxLineLength:ConfirmSendViewModel.kt$ConfirmSendViewModel$private val assetFlow = interactor.assetFlow(transferDraft.assetPayload.chainId, transferDraft.assetPayload.chainAssetId)</ID>
    <ID>MaxLineLength:ConfirmSendViewModel.kt$ConfirmSendViewModel$private val transferDraft = savedStateHandle.get&lt;TransferDraft&gt;(ConfirmSendFragment.KEY_DRAFT) ?: error("Required data not provided for send confirmation")</ID>
    <ID>MaxLineLength:ConfirmSendViewModel.kt$ConfirmSendViewModel$val contactName = contacts.firstOrNull { it.address.equals(transferDraft.recipientAddress, ignoreCase = true) }?.name</ID>
    <ID>MaxLineLength:ConfirmSendViewModel.kt$ConfirmSendViewModel$val openValidationWarningEvent: LiveData&lt;Event&lt;Pair&lt;TransferValidationResult, ValidationWarning&gt;&gt;&gt; = _openValidationWarningEvent</ID>
    <ID>MaxLineLength:ConfirmSendViewModel.kt$ConfirmSendViewModel$val supportedExplorers = chain.explorers.getSupportedExplorers(BlockExplorerUrlBuilder.Type.ACCOUNT, transferDraft.recipientAddress)</ID>
    <ID>MaxLineLength:ConfirmSetControllerFragment.kt$ConfirmSetControllerFragment$class</ID>
    <ID>MaxLineLength:ConfirmSetControllerViewModel.kt$ConfirmSetControllerViewModel$val supportedExplorers = chain.explorers.getSupportedExplorers(BlockExplorerUrlBuilder.Type.ACCOUNT, payload.controllerAddress)</ID>
    <ID>MaxLineLength:ConfirmSetControllerViewModel.kt$ConfirmSetControllerViewModel$val supportedExplorers = chain.explorers.getSupportedExplorers(BlockExplorerUrlBuilder.Type.ACCOUNT, payload.stashAddress)</ID>
    <ID>MaxLineLength:ConfirmStakingViewModel.kt$ConfirmStakingViewModel$emit(resourceManager.getString(R.string.staking_hint_rewards_format, resourceManager.getQuantityString(R.plurals.common_hours_format, hours, hours)))</ID>
    <ID>MaxLineLength:ConfirmStakingViewModel.kt$ConfirmStakingViewModel$setupStakingInteractor.estimateFinalParachainFee(collator, it.planksFromAmount(amount), delegationCount)</ID>
    <ID>MaxLineLength:ConfirmStakingViewModel.kt$ConfirmStakingViewModel$setupStakingInteractor.setupStaking(collator, token.planksFromAmount(amount), delegationCount, accountAddress)</ID>
    <ID>MaxLineLength:ConfirmStakingViewModel.kt$ConfirmStakingViewModel$val accountAddress = (scenarioInteractor.stakingStateFlow().first() as StakingState.Parachain).accountAddress</ID>
    <ID>MaxLineLength:ConfirmStakingViewModel.kt$ConfirmStakingViewModel$val collators = (currentProcessState as? SetupStakingProcess.ReadyToSubmit.Parachain)?.payload?.blockProducers ?: return@liveData emit(null)</ID>
    <ID>MaxLineLength:ConfirmStakingViewModel.kt$ConfirmStakingViewModel$val supportedExplorers = chain.explorers.getSupportedExplorers(BlockExplorerUrlBuilder.Type.ACCOUNT, account.address)</ID>
    <ID>MaxLineLength:ConfirmStakingViewModel.kt$ConfirmStakingViewModel$val supportedExplorers = chain.explorers.getSupportedExplorers(BlockExplorerUrlBuilder.Type.ACCOUNT, payoutDestination.destination.address)</ID>
    <ID>MaxLineLength:ConfirmStakingViewModel.kt$ConfirmStakingViewModel$validatorAccountIds = currentProcessState.payload.blockProducers.map(Validator::accountIdHex)</ID>
    <ID>MaxLineLength:ConfirmUnbondViewModel.kt$ConfirmUnbondViewModel$stakingScenarioInteractor.stakeLess(this, amountInPlanks, validPayload.stash, validPayload.asset.bondedInPlanks.orZero())</ID>
    <ID>MaxLineLength:ConfirmUnbondViewModel.kt$ConfirmUnbondViewModel$val supportedExplorers = chain.explorers.getSupportedExplorers(BlockExplorerUrlBuilder.Type.ACCOUNT, originAddressModel.address)</ID>
    <ID>MaxLineLength:ConnectionPool.kt$ConnectionPool$fun</ID>
    <ID>MaxLineLength:ContributeValidationFailure.kt$resourceManager.getString(R.string.common_existential_warning_title) to resourceManager.getString(R.string.common_existential_warning_message)</ID>
    <ID>MaxLineLength:ControllerDeprecationWarningModel.kt$message = resourceManager.getString(R.string.stash_account_issue_message, stashAddress.shortenAddress(8))</ID>
    <ID>MaxLineLength:ControllerInteractor.kt$ControllerInteractor$suspend</ID>
    <ID>MaxLineLength:ControllerInteractor.kt$ControllerInteractor$val nonNullChainId = chainId.takeIf { it.isNullOrEmpty().not() } ?: sharedStakingSate.assetWithChain.first().chain.id</ID>
    <ID>MaxLineLength:CreateAccountViewModel.kt$CreateAccountViewModel$private val isFromGoogleBackup = savedStateHandle.get&lt;Boolean&gt;(CreateAccountScreenKeys.IS_FROM_GOOGLE_BACKUP_KEY) ?: false</ID>
    <ID>MaxLineLength:CreatePoolSetupScreen.kt$tokenImage = "https://raw.githubusercontent.com/soramitsu/fearless-utils/master/icons/chains/white/Karura.svg"</ID>
    <ID>MaxLineLength:CreatePoolSetupViewModel.kt$CreatePoolSetupViewModel$)</ID>
    <ID>MaxLineLength:CreatePoolSetupViewModel.kt$CreatePoolSetupViewModel$private val defaultPoolNameInputState = TextInputViewState("", resourceManager.getString(R.string.pool_staking_pool_name))</ID>
    <ID>MaxLineLength:CreatePoolSetupViewModel.kt$CreatePoolSetupViewModel$val feeInPlanks = poolInteractor.estimateCreateFee(poolId.toBigInteger(), poolName, amountInPlanks, address, selectedNominator, selectedStateToggler)</ID>
    <ID>MaxLineLength:CrossChainConfirmViewModel.kt$CrossChainConfirmViewModel$)</ID>
    <ID>MaxLineLength:CrossChainConfirmViewModel.kt$CrossChainConfirmViewModel$clickState = phishingType?.let { TitleValueViewState.ClickState.Value(R.drawable.ic_alert_16, CrossChainConfirmViewState.CODE_WARNING_CLICK) }</ID>
    <ID>MaxLineLength:CrossChainConfirmViewModel.kt$CrossChainConfirmViewModel$private val _openValidationWarningEvent = MutableLiveData&lt;Event&lt;Pair&lt;TransferValidationResult, ValidationWarning&gt;&gt;&gt;()</ID>
    <ID>MaxLineLength:CrossChainConfirmViewModel.kt$CrossChainConfirmViewModel$val contactName = contacts.firstOrNull { it.address.equals(transferDraft.recipientAddress, ignoreCase = true) }?.name</ID>
    <ID>MaxLineLength:CrossChainConfirmViewModel.kt$CrossChainConfirmViewModel$val openValidationWarningEvent: LiveData&lt;Event&lt;Pair&lt;TransferValidationResult, ValidationWarning&gt;&gt;&gt; = _openValidationWarningEvent</ID>
    <ID>MaxLineLength:CrossChainConfirmViewModel.kt$CrossChainConfirmViewModel$val supportedExplorers = chain.explorers.getSupportedExplorers(BlockExplorerUrlBuilder.Type.ACCOUNT, transferDraft.recipientAddress)</ID>
    <ID>MaxLineLength:CrossChainSetupContent.kt$FeeInfo(state = state.destinationFeeInfoState, modifier = Modifier.defaultMinSize(minHeight = 52.dp))</ID>
    <ID>MaxLineLength:CrossChainSetupFragment.kt$CrossChainSetupFragment$private</ID>
    <ID>MaxLineLength:CrossChainSetupViewModel.kt$CrossChainSetupViewModel$val openValidationWarningEvent: LiveData&lt;Event&lt;Pair&lt;TransferValidationResult, ValidationWarning&gt;&gt;&gt; = _openValidationWarningEvent</ID>
    <ID>MaxLineLength:CrossChainTransfer.kt$CrossChainTransfer$!isUtilityToken &amp;&amp; (senderUtilityBalance - extraSpends &lt; utilityExistentialDeposit) -&gt; TransferValidityLevel.Warning.Status.WillRemoveAccount</ID>
    <ID>MaxLineLength:CrossChainTransfer.kt$CrossChainTransfer$senderTotal - transactionTotal &lt; existentialDeposit -&gt; TransferValidityLevel.Warning.Status.WillRemoveAccount</ID>
    <ID>MaxLineLength:CrossChainTransfer.kt$CrossChainTransfer$val fullAmountInPlanks: BigInteger = chainAsset.planksFromAmount(amount) + chainAsset.planksFromAmount(destinationFee)</ID>
    <ID>MaxLineLength:CrowdloanAdapter.kt$CrowdloanChildHolder$containerView.findViewById&lt;LinearLayout&gt;(R.id.itemReferralCode).setVisible(item.myContribution != null &amp;&amp; item.referral != null)</ID>
    <ID>MaxLineLength:CrowdloanAdapter.kt$CrowdloanChildHolder$findViewById&lt;LinearLayout&gt;(R.id.itemReferralCode).setOnClickListener { item.referral?.let(handler::copyReferralClicked) }</ID>
    <ID>MaxLineLength:CrowdloanAdapter.kt$CrowdloanDiffCallback$private</ID>
    <ID>MaxLineLength:CrowdloanContributeInteractor.kt$CrowdloanContributeInteractor$is IOException -&gt; BaseException.networkError(resourceManager.getString(R.string.connection_error_message), exception)</ID>
    <ID>MaxLineLength:CrowdloanContributeInteractor.kt$CrowdloanContributeInteractor$val validityStatus = walletRepository.checkTransferValidity(metaAccount.id, accountId, chain, transfer, additional, batchAll)</ID>
    <ID>MaxLineLength:CrowdloanContributeViewModel.kt$CrowdloanContributeViewModel$!isPrivacyAccepted -&gt; ApplyActionState.Unavailable(reason = resourceManager.getString(R.string.crowdloan_agreement_required))</ID>
    <ID>MaxLineLength:CrowdloanContributeViewModel.kt$CrowdloanContributeViewModel$isAcala -&gt; (router.latestCustomBonus as? AcalaBonusPayload)?.apply { this.contributionType = contributionType }</ID>
    <ID>MaxLineLength:CrowdloanContributeViewModel.kt$CrowdloanContributeViewModel$isAcala -&gt; contributionTypeFlow.map { index -&gt; AcalaContributionType.values().find { it.ordinal == index } }.firstOrNull() ?: return@launch</ID>
    <ID>MaxLineLength:CrowdloanContributeViewModel.kt$CrowdloanContributeViewModel$val parachainLink = payload.parachainMetadata?.flow?.data?.getString(FLOW_CROWDLOAN_INFO_URL) ?: parachainMetadata?.website ?: return</ID>
    <ID>MaxLineLength:CrowdloanContributeViewModel.kt$CrowdloanContributeViewModel$val totalReward = payload.parachainMetadata.flow?.data?.getString(FLOW_TOTAL_REWARD)?.toBigDecimalOrNull() ?: 170_000_000.toBigDecimal()</ID>
    <ID>MaxLineLength:CrowdloanRepository.kt$CrowdloanRepository$suspend fun getContribution(chainId: ChainId, accountId: AccountId, paraId: ParaId, fundIndex: FundIndex): Contribution?</ID>
    <ID>MaxLineLength:CrowdloanViewModel.kt$CrowdloanViewModel$private</ID>
    <ID>MaxLineLength:CrowdloanViewModel.kt$CrowdloanViewModel$true -&gt; accountUseCase.selectedAccountFlow().firstOrNull()?.address?.toByteArray()?.blake2b256()?.toHexString(true)</ID>
    <ID>MaxLineLength:CurrentAccountAddressUseCase.kt$CurrentAccountAddressUseCase$class</ID>
    <ID>MaxLineLength:CurrentValidatorsAdapter.kt$CurrentValidatorsDiffCallback$BaseGroupedDiffCallback&lt;NominatedValidatorStatusModel, NominatedValidatorModel&gt;(NominatedValidatorStatusModel::class.java)</ID>
    <ID>MaxLineLength:CurrentValidatorsAdapter.kt$CurrentValidatorsDiffCallback$override</ID>
    <ID>MaxLineLength:CurrentValidatorsFragment.kt$CurrentValidatorsFragment$class</ID>
    <ID>MaxLineLength:CurrentValidatorsInteractor.kt$CurrentValidatorsInteractor$Status.Active(nomination = userIndividualExposure.value, willUserBeRewarded = willBeRewarded)</ID>
    <ID>MaxLineLength:CurrentValidatorsInteractor.kt$CurrentValidatorsInteractor$val totalElectiveCount = with(groupedByStatusClass) { groupSize(Status.Active::class) + groupSize(Status.Elected::class) }</ID>
    <ID>MaxLineLength:CurrentValidatorsViewModel.kt$CurrentValidatorsViewModel$.</ID>
    <ID>MaxLineLength:CurrentValidatorsViewModel.kt$CurrentValidatorsViewModel$addressModel = iconGenerator.createAddressModel(validatorAddress, AddressIconGenerator.SIZE_MEDIUM, validator.identity?.display)</ID>
    <ID>MaxLineLength:CurrentValidatorsViewModel.kt$CurrentValidatorsViewModel$private</ID>
    <ID>MaxLineLength:CurrentValidatorsViewModel.kt$CurrentValidatorsViewModel$val</ID>
    <ID>MaxLineLength:CurrentValidatorsViewModel.kt$CurrentValidatorsViewModel$val (_, validators) = groupedList.entries.firstOrNull { (group, _) -&gt; group is NominatedValidator.Status.Group.Active } ?: return@map false</ID>
    <ID>MaxLineLength:CurrentValidatorsViewModel.kt$CurrentValidatorsViewModel$val currentStateValidators = setupStakingSharedState.getOrNull&lt;SetupStakingProcess.SelectBlockProducersStep.Validators&gt;()</ID>
    <ID>MaxLineLength:CustomBlockProducersAdapter.kt$BlockProducerDiffCallback$return oldItem.name == newItem.name &amp;&amp; oldItem.rewardsPercent == newItem.rewardsPercent &amp;&amp; oldItem.selected == newItem.selected</ID>
    <ID>MaxLineLength:CustomBlockProducersAdapter.kt$BlockProducerViewHolder$class</ID>
    <ID>MaxLineLength:CustomBlockProducersAdapter.kt$CustomBlockProducersAdapter$return BlockProducerViewHolder(binding, { itemHandler.blockProducerInfoClicked(getItem(it)) }, { itemHandler.blockProducerClicked(getItem(it)) })</ID>
    <ID>MaxLineLength:CustomContributeManager.kt$CustomContributeManager$private fun noFactoryFound(flowType: String): Nothing</ID>
    <ID>MaxLineLength:CustomContributeViewModel.kt$CustomContributeViewModel$.</ID>
    <ID>MaxLineLength:CustomContributeViewModel.kt$CustomContributeViewModel$_viewStateFlow.emit(customContributeManager.createNewState(customFlowType, viewModelScope, nextStepPayload))</ID>
    <ID>MaxLineLength:CustomContributeViewModel.kt$CustomContributeViewModel$additionalOnChainSubmission(it, customFlowType, BigDecimal.ZERO, customContributeManager)</ID>
    <ID>MaxLineLength:CustomContributeViewModel.kt$CustomContributeViewModel$contributionInteractor.estimateFee(payload.paraId, amount, additional, useBatchAll, signature)</ID>
    <ID>MaxLineLength:CustomContributeViewModel.kt$CustomContributeViewModel$enteredEtheriumAddress = enteredEtheriumAddress.firstOrNull()?.let { it to (isCorrectAndOld?.second?.not() ?: false) }</ID>
    <ID>MaxLineLength:CustomContributeViewModel.kt$CustomContributeViewModel$private val _viewStateFlow = MutableStateFlow(customContributeManager.createNewState(customFlowType, viewModelScope, payload))</ID>
    <ID>MaxLineLength:CustomContributeViewModel.kt$CustomContributeViewModel$val customContributePayload = (_viewStateFlow.value as? MoonbeamContributeViewState)?.customContributePayload!!</ID>
    <ID>MaxLineLength:CustomContributeViewModel.kt$CustomContributeViewModel$val isCorrectAndOld = (_viewStateFlow.value as? MoonbeamContributeViewState)?.isEtheriumAddressCorrectAndOld()</ID>
    <ID>MaxLineLength:CustomContributeViewModel.kt$CustomContributeViewModel$val isPrivacyAccepted = (_viewStateFlow.value as? MoonbeamContributeViewState)?.customContributePayload?.isPrivacyAccepted ?: (nextStep.step &gt; 0)</ID>
    <ID>MaxLineLength:CustomContributeViewModel.kt$CustomContributeViewModel$val payloadMoonbeam = (_viewStateFlow.value as? MoonbeamContributeViewState)?.generatePayload()?.getOrNull()</ID>
    <ID>MaxLineLength:CustomContributeViewModel.kt$CustomContributeViewModel$val signature = (_viewStateFlow.value as? MoonbeamContributeViewState)?.getContributionSignature(amountPlanks)</ID>
    <ID>MaxLineLength:CustomValidatorsSettingsFragment.kt$CustomValidatorsSettingsFragment$// binding.customValidatorSettingsSortOwnStake.text = getString(R.string.staking_filter_title_own_stake_token, it)</ID>
    <ID>MaxLineLength:CustomValidatorsSettingsFragment.kt$CustomValidatorsSettingsFragment$// binding.customValidatorSettingsSortTotalStake.text = getString(R.string.staking_validator_total_stake_token, it)</ID>
    <ID>MaxLineLength:CustomValidatorsSettingsViewModel.kt$CustomValidatorsSettingsViewModel$private val stakingType = savedStateHandle.get&lt;Asset.StakingType&gt;(CustomValidatorsSettingsFragment.STAKING_TYPE_KEY)!!</ID>
    <ID>MaxLineLength:CustomValidatorsSettingsViewModel.kt$CustomValidatorsSettingsViewModel$val</ID>
    <ID>MaxLineLength:Data.kt$dynamicInstance.name == DataType.BLAKE_2B_256 -&gt; Data.Hash(dynamicInstance.value.cast(), Data.Hash.Type.BLAKE_2B_256)</ID>
    <ID>MaxLineLength:Data.kt$dynamicInstance.name == DataType.KECCAK_256 -&gt; Data.Hash(dynamicInstance.value.cast(), Data.Hash.Type.KECCAK_256)</ID>
    <ID>MaxLineLength:Declarations.kt$typealias IsNotControllerAccountValidation = AccountIsNotControllerValidation&lt;SetControllerValidationPayload, SetControllerValidationFailure&gt;</ID>
    <ID>MaxLineLength:Declarations.kt$typealias RewardDestinationControllerRequiredValidation = AccountRequiredValidation&lt;RewardDestinationValidationPayload, RewardDestinationValidationFailure&gt;</ID>
    <ID>MaxLineLength:Declarations.kt$typealias RewardDestinationFeeValidation = EnoughToPayFeesValidation&lt;RewardDestinationValidationPayload, RewardDestinationValidationFailure&gt;</ID>
    <ID>MaxLineLength:Declarations.kt$typealias RewardDestinationValidationSystem = ValidationSystem&lt;RewardDestinationValidationPayload, RewardDestinationValidationFailure&gt;</ID>
    <ID>MaxLineLength:Declarations.kt$typealias SetControllerFeeValidation = EnoughToPayFeesValidation&lt;SetControllerValidationPayload, SetControllerValidationFailure&gt;</ID>
    <ID>MaxLineLength:Declarations.kt$typealias SetControllerValidationSystem = ValidationSystem&lt;SetControllerValidationPayload, SetControllerValidationFailure&gt;</ID>
    <ID>MaxLineLength:Declarations.kt$typealias SetupStakingMaximumNominatorsValidation = MaxNominatorsReachedValidation&lt;SetupStakingPayload, SetupStakingValidationFailure&gt;</ID>
    <ID>MaxLineLength:Declarations.kt$typealias WelcomeStakingMaxNominatorsValidation = MaxNominatorsReachedValidation&lt;WelcomeStakingValidationPayload, WelcomeStakingValidationFailure&gt;</ID>
    <ID>MaxLineLength:Declarations.kt$typealias WelcomeStakingValidationSystem = ValidationSystem&lt;WelcomeStakingValidationPayload, WelcomeStakingValidationFailure&gt;</ID>
    <ID>MaxLineLength:Definitions.kt$typealias ContributeEnoughToPayFeesValidation = EnoughToPayFeesValidation&lt;ContributeValidationPayload, ContributeValidationFailure&gt;</ID>
    <ID>MaxLineLength:Definitions.kt$typealias ContributeExistentialDepositValidation = ExistentialDepositValidation&lt;ContributeValidationPayload, ContributeValidationFailure&gt;</ID>
    <ID>MaxLineLength:DelegationRecyclerViewAdapter.kt$DelegationDiffCallback$override</ID>
    <ID>MaxLineLength:DelegationRecyclerViewAdapter.kt$DelegationViewHolder$DelegatorViewState.CollatorDelegationModel.Status.ReadyToUnlock -&gt; StakeSummaryView.Status.ReadyToUnlockCollator</ID>
    <ID>MaxLineLength:DelegationRecyclerViewAdapter.kt$DelegationViewHolder$fun</ID>
    <ID>MaxLineLength:DelegationRecyclerViewAdapter.kt$DelegationViewHolder$is DelegatorViewState.CollatorDelegationModel.Status.Active -&gt; StakeSummaryView.Status.ActiveCollator(item.status.nextRoundTimeLeft)</ID>
    <ID>MaxLineLength:DelegationRecyclerViewAdapter.kt$DelegationViewHolder$is DelegatorViewState.CollatorDelegationModel.Status.Leaving -&gt; StakeSummaryView.Status.LeavingCollator(item.status.collatorLeaveTimeLeft ?: 0L)</ID>
    <ID>MaxLineLength:DelegatorStateUpdater.kt$DelegatorStateUpdater$)</ID>
    <ID>MaxLineLength:DragAndDropTouchHelperCallback.kt$DragAndDropTouchHelperCallback$class</ID>
    <ID>MaxLineLength:DragAndDropTouchHelperCallback.kt$DragAndDropTouchHelperCallback$override</ID>
    <ID>MaxLineLength:EditPoolConfirmViewModel.kt$EditPoolConfirmViewModel$val nameState = editState.newPoolName?.let { TitleValueViewState(resourceManager.getString(R.string.pool_staking_pool_name), it) }</ID>
    <ID>MaxLineLength:EditPoolScreen.kt$TextInput(state = nameInputState, onInput = screenInterface::onNameInput, onEndIconClick = screenInterface::onClearNameClick)</ID>
    <ID>MaxLineLength:EditPoolViewModel.kt$EditPoolViewModel$val</ID>
    <ID>MaxLineLength:EditPoolViewModel.kt$EditPoolViewModel$val canContinue = poolName.isNotEmpty() &amp;&amp; (poolName != poolEditInfo.initialPoolName || rootChanged || nominatorChanged || stateTogglerChanged)</ID>
    <ID>MaxLineLength:EditPoolViewModel.kt$EditPoolViewModel$val newStateToggler = selectedStateTogglerFlow.value.takeIf { !it.contentEquals(poolEditInfo.initialStateToggler) }</ID>
    <ID>MaxLineLength:EmailValidator.kt$EmailValidator.Companion$"^[a-z0-9!#\$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#\$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\$"</ID>
    <ID>MaxLineLength:EncryptionTypeChooserBottomSheetDialog.kt$EncryptionTypeViewHolder$override</ID>
    <ID>MaxLineLength:EncryptionUtil.kt$EncryptionUtil$context.getSharedPreferences(KEY_ALIAS, Context.MODE_PRIVATE).edit().putString(SECRET_KEY, encryptRsa(secretKey.encoded)).apply()</ID>
    <ID>MaxLineLength:EraCalculatorFactory.kt$EraTimeCalculator$- Difference between current index and start index multiplied by epoch duration gives us progress in slots for active era but we are missing progress inside session.</ID>
    <ID>MaxLineLength:EraCalculatorFactory.kt$EraTimeCalculator$- To estimate progress of the session one needs: currentSlot (storage Babe.CurrentSlot) and genesisSlot (Babe.GenesisSlot).</ID>
    <ID>MaxLineLength:EraCalculatorFactory.kt$EraTimeCalculator$// Doing math takes very long time. By finishing all requests and calculations the time will be outdated for ~5 seconds</ID>
    <ID>MaxLineLength:Error.kt$fun noValidatorPrefs(accountIdHex: String): Nothing</ID>
    <ID>MaxLineLength:Error.kt$fun notElected(accountIdHex: String): Nothing</ID>
    <ID>MaxLineLength:EthereumDerivationPathMigration.kt$EthereumDerivationPathMigration$Keypair(publicKey = struct[KeyPairSchema.PublicKey], privateKey = struct[KeyPairSchema.PrivateKey], nonce = struct[KeyPairSchema.Nonce])</ID>
    <ID>MaxLineLength:EthereumDerivationPathMigration.kt$EthereumDerivationPathMigration$update(MetaAccountLocal.TABLE_NAME, SQLiteDatabase.CONFLICT_REPLACE, contentValues, "id=?", arrayOf(metaId.toString()))</ID>
    <ID>MaxLineLength:EthereumDerivationPathMigration.kt$EthereumDerivationPathMigration$val ethereumSeed = EthereumSeedFactory.deriveSeed32(mnemonic.words, password = decodedEthereumDerivationPath.password).seed</ID>
    <ID>MaxLineLength:EthereumDerivationPathMigration.kt$EthereumDerivationPathMigration$val newEthereumKeypair = EthereumKeypairFactory.generate(ethereumSeed, junctions = decodedEthereumDerivationPath.junctions)</ID>
    <ID>MaxLineLength:Exceptions.kt$MinPoolCreationThresholdException$class</ID>
    <ID>MaxLineLength:ExistentialDepositUseCaseImpl.kt$ExistentialDepositUseCaseImpl$ChainAssetType.StableAssetPoolToken -&gt; "stableAssetPoolToken" to (asset.currencyId?.toBigInteger() ?: return null)</ID>
    <ID>MaxLineLength:ExistentialDepositUseCaseImpl.kt$ExistentialDepositUseCaseImpl$Log.e("ExistentialDepositUseCaseImpl", "ExistentialDepositUseCaseImpl error: ${it.localizedMessage ?: it.message ?: it.toString()}")</ID>
    <ID>MaxLineLength:ExpandableLazyListNestedScrollConnection.kt$ExpandableLazyListNestedScrollConnection$get() = runCatching { (height.value - blockHeight.value) / (parentHeight.value - blockHeight.value) }.getOrNull() ?: 0f</ID>
    <ID>MaxLineLength:ExpandableLazyListNestedScrollConnection.kt$ExpandableLazyListNestedScrollConnection$val isListScrolledToTheEnd = listState.layoutInfo.visibleItemsInfo.lastOrNull()?.index == listState.layoutInfo.totalItemsCount - 1</ID>
    <ID>MaxLineLength:ExperimentalViewModel.kt$ExperimentalViewModel$val status = if (isBeaconConnected()) ExperimentalState.ExperimentStatus.Connected else ExperimentalState.ExperimentStatus.Disconnected</ID>
    <ID>MaxLineLength:ExportExt.kt$inline</ID>
    <ID>MaxLineLength:ExportJsonPasswordViewModel.kt$ExportJsonPasswordViewModel$chain.isSupported &amp;&amp; chain.isEthereumBased &amp;&amp; accountInteractor.getMetaAccount(payload.metaId).hasChainAccount(chain.id).not()</ID>
    <ID>MaxLineLength:ExportJsonPasswordViewModel.kt$ExportJsonPasswordViewModel$private</ID>
    <ID>MaxLineLength:ExportJsonPasswordViewModel.kt$ExportJsonPasswordViewModel$val</ID>
    <ID>MaxLineLength:ExportMnemonicFragment.kt$ExportMnemonicFragment$viewModel.derivationPathLiveData</ID>
    <ID>MaxLineLength:ExportMnemonicViewModel.kt$ExportMnemonicViewModel$it?.get(ChainAccountSecrets.Entropy)?.let { MnemonicCreator.fromEntropy(it) } ?: throw IllegalArgumentException("Mnemonic not specified")</ID>
    <ID>MaxLineLength:ExportMnemonicViewModel.kt$ExportMnemonicViewModel$it?.get(MetaAccountSecrets.Entropy)?.let { MnemonicCreator.fromEntropy(it) } ?: throw IllegalArgumentException("Mnemonic not specified")</ID>
    <ID>MaxLineLength:ExportMnemonicViewModel.kt$ExportMnemonicViewModel$val</ID>
    <ID>MaxLineLength:ExportSeedFragment.kt$ExportSeedFragment$val derivationPathFieldState = if (derivationPath.isNullOrBlank()) FieldState.HIDDEN else FieldState.DISABLED</ID>
    <ID>MaxLineLength:ExportSeedFragment.kt$ExportSeedFragment$val ethereumEncryptionTypeFieldState = if (ethereumSeed.isNullOrBlank()) FieldState.HIDDEN else FieldState.DISABLED</ID>
    <ID>MaxLineLength:ExportSeedViewModel.kt$ExportSeedViewModel$if (isEthereum.value == true) it?.get(ChainAccountSecrets.Keypair)?.get(KeyPairSchema.PrivateKey) else null</ID>
    <ID>MaxLineLength:ExportSeedViewModel.kt$ExportSeedViewModel$private</ID>
    <ID>MaxLineLength:ExportSource.kt$ExportSource$Mnemonic : ExportSource</ID>
    <ID>MaxLineLength:ExportSource.kt$ExportSource$Seed : ExportSource</ID>
    <ID>MaxLineLength:ExportSource.kt$ExportSource$sealed</ID>
    <ID>MaxLineLength:Ext.kt$fun String.camelCaseToCapitalizedWords()</ID>
    <ID>MaxLineLength:Ext.kt$return</ID>
    <ID>MaxLineLength:Extensions.kt$fun</ID>
    <ID>MaxLineLength:ExternalActionsUi.kt$fun</ID>
    <ID>MaxLineLength:Extrinsic.kt$(if (desired == WithDesired.INPUT) "desired_amount_in" to "min_amount_out" else "desired_amount_out" to "max_amount_in")</ID>
    <ID>MaxLineLength:ExtrinsicBuilderExt.kt$@Deprecated("Replace with createPoolBouncer when polkadot runtime upgrades to 9390", replaceWith = ReplaceWith("ExtrinsicBuilder.createPoolBouncer"))</ID>
    <ID>MaxLineLength:ExtrinsicBuilderExt.kt$fun</ID>
    <ID>MaxLineLength:ExtrinsicDetailFragment.kt$ExtrinsicDetailFragment$explorers = viewModel.getSupportedExplorers(BlockExplorerUrlBuilder.Type.EXTRINSIC, viewModel.payload.operation.hash)</ID>
    <ID>MaxLineLength:FearlessException.kt$FearlessException.Companion$return FearlessException(Kind.UNEXPECTED, exception.message ?: "", exception)</ID>
    <ID>MaxLineLength:FearlessLibExt.kt$// fun SeedFactory.deriveSeed32(mnemonicWords: String, password: String?) = cropSeedTo32Bytes(deriveSeed(mnemonicWords, password))</ID>
    <ID>MaxLineLength:FearlessLibExt.kt$fun Module.numberConstant(name: String, runtimeSnapshot: RuntimeSnapshot)</ID>
    <ID>MaxLineLength:FearlessLibExt.kt$fun Module.optionalNumberConstant(name: String, runtimeSnapshot: RuntimeSnapshot)</ID>
    <ID>MaxLineLength:FearlessLibExt.kt$fun SeedFactory.createSeed32(length: Mnemonic.Length, password: String?)</ID>
    <ID>MaxLineLength:FearlessLibExt.kt$fun String.u32ArgumentFromStorageKey()</ID>
    <ID>MaxLineLength:FearlessLibExt.kt$fun SubstrateSeedFactory.deriveSeed32(mnemonicWords: String, password: String?)</ID>
    <ID>MaxLineLength:FiatCurrenciesChooserBottomSheetDialog.kt$FiatCurrencyHolder$private</ID>
    <ID>MaxLineLength:FixedListBottomSheet.kt$view.findViewById&lt;TextView&gt;(R.id.itemExternalActionContent).setDrawableStart(icon, widthInDp = 24, tint = R.color.white)</ID>
    <ID>MaxLineLength:FlowExt.kt$*</ID>
    <ID>MaxLineLength:GetAvailableFiatCurrencies.kt$GetAvailableFiatCurrencies$val shouldRefreshRates = Calendar.getInstance().timeInMillis - syncTimeMillis &gt; minRatesRefreshDuration.toInt(DurationUnit.MILLISECONDS)</ID>
    <ID>MaxLineLength:GetSoraCardFragment.kt$GetSoraCardFragment$override</ID>
    <ID>MaxLineLength:GetSoraCardScreen.kt$painter = painterResource(id = if (state.enoughXor) R.drawable.ic_check_rounded else R.drawable.ic_cross_24)</ID>
    <ID>MaxLineLength:GetSoraCardViewModel.kt$GetSoraCardViewModel$val xorEurPrice = interactor.getXorEuroPrice(it.token.configuration.priceId) ?: error("XOR price not found")</ID>
    <ID>MaxLineLength:GetSoraCardViewModel.kt$GetSoraCardViewModel$val xorRealRequiredBalance = KYC_REAL_REQUIRED_BALANCE.divide(xorEurPrice, defaultScale, RoundingMode.HALF_EVEN)</ID>
    <ID>MaxLineLength:GetSoraCardViewModel.kt$GetSoraCardViewModel$val xorRequiredBalanceWithBacklash = KYC_REQUIRED_BALANCE_WITH_BACKLASH.divide(xorEurPrice, defaultScale, RoundingMode.HALF_EVEN)</ID>
    <ID>MaxLineLength:HistoryRepository.kt$HistoryRepository$if</ID>
    <ID>MaxLineLength:HistoryRepository.kt$HistoryRepository$val operations = historySource?.getOperations(pageSize, cursor, filters, accountId, chain, chainAsset, accountAddress)</ID>
    <ID>MaxLineLength:HistorySourceProvider.kt$HistorySourceProvider$Chain.ExternalApi.Section.Type.SUBQUERY -&gt; SubqueryHistorySource(walletOperationsApi, chainRegistry, historyUrl)</ID>
    <ID>MaxLineLength:HistorySourceProvider.kt$HistorySourceProvider$SoraHistorySource(soramitsuNetworkClient, soraSubqueryFactory, soraProdRemoteConfigBuilder, soraStageRemoteConfigBuilder)</ID>
    <ID>MaxLineLength:HttpExceptionHandler.kt$HttpExceptionHandler$is IOException -&gt; BaseException.networkError(resourceManager.getString(R.string.connection_error_message), exception)</ID>
    <ID>MaxLineLength:IdentityRepositoryImpl.kt$IdentityRepositoryImpl$override suspend</ID>
    <ID>MaxLineLength:ImportAccountFragment.kt$ImportAccountFragment$binding.advancedBlockView.ethereumDerivationPathEditText.bindTo(viewModel.ethereumDerivationPathLiveData, viewLifecycleOwner)</ID>
    <ID>MaxLineLength:ImportAccountFragment.kt$ImportAccountFragment$binding.advancedBlockView.substrateDerivationPathEditText.bindTo(viewModel.substrateDerivationPathLiveData, viewLifecycleOwner)</ID>
    <ID>MaxLineLength:ImportAccountFragment.kt$ImportAccountFragment$private</ID>
    <ID>MaxLineLength:ImportAccountViewModel.kt$ImportAccountViewModel$initialBlockchainType.value != null</ID>
    <ID>MaxLineLength:ImportAccountViewModel.kt$ImportAccountViewModel$val isSubstrateDerivationPathValid = substrateDerivationPathLiveData.value?.matches(substrateDerivationPathRegex)</ID>
    <ID>MaxLineLength:ImportSourceModel.kt$ImportSource$sealed</ID>
    <ID>MaxLineLength:ImportSourceModel.kt$MnemonicImportSource$class</ID>
    <ID>MaxLineLength:ImportSourceModel.kt$RawSeedImportSource$class</ID>
    <ID>MaxLineLength:InfoDialog.kt$InfoDialogContent("Liquidity provider fee", "A portion of each trade (0.3%) goes to liquidity providers as a protocol incentive.")</ID>
    <ID>MaxLineLength:InfoTable.kt$"0xEBN4KURhvkURhvkURhvkURhvkURhvkURhvkN4KURhvkURhvkURhvkURhvkURhvkURhvkN4KURhvkURhvkURhvkURhvkURhvkURhvk"</ID>
    <ID>MaxLineLength:InfoTableItem.kt$"84848348484834848483484848348484834848483484848348484834848483484848348484834848483484848348484834"</ID>
    <ID>MaxLineLength:InfoTableItem.kt$val</ID>
    <ID>MaxLineLength:InputWithHint.kt$keyboardOptions = KeyboardOptions(autoCorrect = false, keyboardType = KeyboardType.Text, imeAction = ImeAction.None)</ID>
    <ID>MaxLineLength:InputWithHint.kt$textStyle = MaterialTheme.customTypography.body1.copy(textAlign = TextAlign.Start, background = Color.Unspecified)</ID>
    <ID>MaxLineLength:InterlayContributeFactory.kt$InterlayContributeFactory$override fun createView(context: Context, step: MoonbeamCrowdloanStep?): CustomContributeView</ID>
    <ID>MaxLineLength:InterlayContributeViewState.kt$InterlayContributeViewState$if (!isReferralValid) throw IllegalArgumentException(resourceManager.getString(R.string.crowdloan_referral_code_invalid))</ID>
    <ID>MaxLineLength:JsonImportView.kt$JsonImportView$constructor</ID>
    <ID>MaxLineLength:KaruraContributeFactory.kt$KaruraContributeFactory$override fun createView(context: Context, step: MoonbeamCrowdloanStep?): CustomContributeView</ID>
    <ID>MaxLineLength:KaruraContributeViewState.kt$KaruraContributeViewState$if (!isReferralValid) throw IllegalArgumentException(resourceManager.getString(R.string.crowdloan_referral_code_invalid))</ID>
    <ID>MaxLineLength:KaruraContributeViewState.kt$KaruraContributeViewState$override</ID>
    <ID>MaxLineLength:KaruraContributeViewState.kt$KaruraContributeViewState$return KaruraBonusPayload(referralCode, customContributePayload.chainId, customContributePayload.parachainMetadata.rewardRate)</ID>
    <ID>MaxLineLength:KoltinExt.kt$inline</ID>
    <ID>MaxLineLength:LanguagesAdapter.kt$LanguagesAdapter$return LanguageViewHolder(LayoutInflater.from(viewGroup.context).inflate(R.layout.item_language, viewGroup, false))</ID>
    <ID>MaxLineLength:LeaseIndexFromBlock.kt$fun leaseIndexFromBlock(block: BigInteger, blocksPerLeasePeriod: BigInteger, leaseOffset: BigInteger)</ID>
    <ID>MaxLineLength:LockBottomSheetBehavior.kt$LockBottomSheetBehavior$return if (isDraggable) super.onNestedPreFling(coordinatorLayout, child, target, velocityX, velocityY) else false</ID>
    <ID>MaxLineLength:ManagePoolStakeScreen.kt$H2(text = stringResource(id = R.string.pool_your_total_stake), color = black2, modifier = Modifier.align(Alignment.CenterHorizontally))</ID>
    <ID>MaxLineLength:ManagePoolStakeScreen.kt$ListDialog</ID>
    <ID>MaxLineLength:ManagePoolStakeScreen.kt$TitleValueViewState("Pool Info", "⚡️Everlight☀️", clickState = TitleValueViewState.ClickState.Value(R.drawable.ic_info_14, 1))</ID>
    <ID>MaxLineLength:ManagePoolStakeScreen.kt$listOf(MenuIconItem(R.drawable.ic_dots_horizontal_24, onClick = { scope.launch { sheetState.show() } }))</ID>
    <ID>MaxLineLength:ManagePoolStakeScreen.kt$state.poolInfo.copy(clickState = TitleValueViewState.ClickState.Value(R.drawable.ic_chevron_right, POOL_INFO_CLICK_IDENTIFIER))</ID>
    <ID>MaxLineLength:ManagePoolStakeViewModel.kt$ManagePoolStakeViewModel$val claimable = asset.token.amountFromPlanks(pool.pendingRewards).formatCryptoDetail(asset.token.configuration.symbol)</ID>
    <ID>MaxLineLength:ManagePoolStakeViewModel.kt$ManagePoolStakeViewModel$val redeemableFormatted = asset.token.amountFromPlanks(redeemable).formatCryptoDetail(asset.token.configuration.symbol)</ID>
    <ID>MaxLineLength:ManageStakingBottomSheet.kt$ManageStakingBottomSheet$manageItem(R.drawable.ic_finance_wallet_24, R.string.staking_rewards_destination_title, ManageStakeAction.REWARD_DESTINATION)</ID>
    <ID>MaxLineLength:ManualRewardCalculator.kt$ManualRewardCalculator$(INTEREST_IDEAL * STAKED_PORTION_IDEAL - MINIMUM_INFLATION) * 2.0.pow((STAKED_PORTION_IDEAL - stakedPortion) / DECAY_RATE)</ID>
    <ID>MaxLineLength:ManualRewardCalculator.kt$ManualRewardCalculator$val yearlyRewardPercentage = averageValidatorRewardPercentage * averageValidatorStake / validator.totalStake.toDouble()</ID>
    <ID>MaxLineLength:MapFundInfoToCrowdloan.kt$isCrowdloanActive(fundInfo, currentBlockNumber, blocksPerLeasePeriod, leaseOffset, hasWonAuction, minContribution)</ID>
    <ID>MaxLineLength:MapFundInfoToCrowdloan.kt$val leasePeriodInMillis = leasePeriodInMillis(blocksPerLeasePeriod, leaseOffset, currentBlockNumber, fundInfo.lastSlot, expectedBlockTimeInMillis)</ID>
    <ID>MaxLineLength:MapRewardDestinationModelToRewardDestination.kt$is RewardDestinationModel.Payout -&gt; RewardDestination.Payout(rewardDestinationModel.destination.address.toAccountId())</ID>
    <ID>MaxLineLength:Mappers.kt$private fun mapSectionTypeLocalToSectionType(sectionType: String): Chain.ExternalApi.Section.Type</ID>
    <ID>MaxLineLength:Mappers.kt$private fun mapToList(json: String?)</ID>
    <ID>MaxLineLength:Migrations.kt$&lt;no name provided&gt;$// So we need to recreate all the tables with new FK which were created after the renaming chains to _chains (Migration_41_42)</ID>
    <ID>MaxLineLength:Migrations.kt$&lt;no name provided&gt;$database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_accounts_accountId` ON `chain_accounts` (`accountId`)")</ID>
    <ID>MaxLineLength:Migrations.kt$&lt;no name provided&gt;$database.execSQL("CREATE INDEX IF NOT EXISTS `index_meta_accounts_ethereumAddress` ON `meta_accounts` (`ethereumAddress`)")</ID>
    <ID>MaxLineLength:Migrations.kt$&lt;no name provided&gt;$database.execSQL("CREATE INDEX IF NOT EXISTS `index_meta_accounts_substrateAccountId` ON `meta_accounts` (`substrateAccountId`)")</ID>
    <ID>MaxLineLength:Migrations.kt$&lt;no name provided&gt;$database.execSQL("DELETE FROM `address_book` where `id` NOT IN (SELECT `id` FROM `_address_book` GROUP BY `address`, `chainId`)")</ID>
    <ID>MaxLineLength:MinContributionValidation.kt$MinContributionValidation$val minContribution = value.customMinContribution ?: chainAsset.amountFromPlanks(crowdloanRepository.minContribution(chainAsset.chainId))</ID>
    <ID>MaxLineLength:MinimumAmountValidation.kt$MinimumAmountValidation$ValidationStatus.NotValid(DefaultFailureLevel.ERROR, SetupStakingValidationFailure.TooSmallAmount(minimumBond))</ID>
    <ID>MaxLineLength:MnemonicAgreementsViewModel.kt$MnemonicAgreementsViewModel$private val isFromGoogleBackup = savedStateHandle.get&lt;Boolean&gt;(MnemonicAgreementsDialog.IS_FROM_GOOGLE_BACKUP_KEY) ?: false</ID>
    <ID>MaxLineLength:MnemonicContainerView.kt$MnemonicContainerView$(mnemonicWordView.layoutParams as LayoutParams).setMargins(leftMargin, lastViewTop, wordMargin, wordMargin)</ID>
    <ID>MaxLineLength:MnemonicContainerView.kt$MnemonicContainerView$(mnemonicWordView.layoutParams as LayoutParams).setMargins(wordMargin, lastViewBottom + wordMargin, wordMargin, wordMargin)</ID>
    <ID>MaxLineLength:MnemonicContainerView.kt$MnemonicContainerView$currentElement.wordView.layout(viewLeft, currentElement.wordView.top, viewRight, currentElement.wordView.bottom)</ID>
    <ID>MaxLineLength:MnemonicContainerView.kt$MnemonicContainerView$currentElement.wordView.layout(viewLeft.toInt(), currentElement.wordView.top, viewRight.toInt(), currentElement.wordView.bottom)</ID>
    <ID>MaxLineLength:MnemonicContainerView.kt$MnemonicContainerView$private val wordMargin = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, WORD_MARGIN_DP, resources.displayMetrics).toInt()</ID>
    <ID>MaxLineLength:MnemonicContainerView.kt$MnemonicContainerView$val lastChildRight = (lastView.layoutParams as LayoutParams).leftMargin + lastView.measuredWidth + wordMargin</ID>
    <ID>MaxLineLength:MnemonicContainerView.kt$MnemonicContainerView$val lastViewBottom = (lastView.layoutParams as LayoutParams).topMargin + lastView.measuredHeight + wordMargin</ID>
    <ID>MaxLineLength:MnemonicContainerView.kt$MnemonicContainerView$val viewRight = previousElement.wordView.right + wordMargin + wordMargin + currentElement.wordView.width</ID>
    <ID>MaxLineLength:MoonbeamContributeInteractor.kt$MoonbeamContributeInteractor$suspend</ID>
    <ID>MaxLineLength:MoonbeamContributeViewState.kt$MoonbeamContributeViewState$amount.isEmpty() -&gt; ApplyActionState.Unavailable(reason = resourceManager.getString(R.string.common_continue))</ID>
    <ID>MaxLineLength:MoonbeamContributeViewState.kt$MoonbeamContributeViewState$ethAddress.isEmpty() -&gt; ApplyActionState.Unavailable(reason = resourceManager.getString(R.string.common_continue))</ID>
    <ID>MaxLineLength:MoonbeamStep2Registration.kt$MoonbeamStep2Registration$binding.tvMoonbeamRegistrationDesc.text</ID>
    <ID>MaxLineLength:MultiAddress.kt$fun bindMultiAddressId(dynamicInstance: DictEnum.Entry&lt;*&gt;)</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$navController!!.previousBackStackEntry!!.savedStateHandle.set(CrowdloanContributeFragment.KEY_BONUS_LIVE_DATA, payload)</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$navController!!.previousBackStackEntry!!.savedStateHandle.set(SignBeaconTransactionFragment.SIGN_RESULT_KEY, status)</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$navController?.currentBackStackEntry?.savedStateHandle?.getLiveData&lt;Boolean&gt;(StoryFragment.KEY_STORY) ?: return flowOf(false)</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$navController?.navigate(R.id.action_crowdloanContributeFragment_to_confirmContributeFragment, ConfirmContributeFragment.getBundle(payload))</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$navController?.navigate(R.id.action_crowdloanContributeFragment_to_customContributeFragment, CustomContributeFragment.getBundle(payload))</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$navController?.navigate(R.id.action_customContributeFragment_to_confirmContributeFragment, ConfirmContributeFragment.getBundle(payload))</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$navController?.navigate(R.id.action_mainFragment_to_crowdloanContributeFragment, CrowdloanContributeFragment.getBundle(payload))</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$navController?.navigate(R.id.action_mainFragment_to_customContributeFragment, CustomContributeFragment.getBundle(payload))</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$navController?.navigate(R.id.action_nodesFragment_to_nodeDetailsFragment, NodeDetailsFragment.getBundle(payload))</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$navController?.navigate(R.id.action_payoutsListFragment_to_payoutDetailsFragment, PayoutDetailsFragment.getBundle(payout))</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$navController?.navigate(R.id.action_selectBondMoreFragment_to_confirmBondMoreFragment, ConfirmBondMoreFragment.getBundle(payload))</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$navController?.navigate(R.id.action_selectUnbondFragment_to_confirmUnbondFragment, ConfirmUnbondFragment.getBundle(payload))</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$navController?.navigate(R.id.action_stakingBalanceFragment_to_selectUnbondFragment, SelectUnbondFragment.getBundle(payload))</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$navController?.navigate(R.id.signBeaconTransactionFragment, SignBeaconTransactionFragment.getBundle(payload, dAppMetadata))</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$override</ID>
    <ID>MaxLineLength:Navigator.kt$Navigator$val resultBackStackEntry = resultDestinationId?.let { navController?.getBackStackEntry(it) } ?: navController?.previousBackStackEntry</ID>
    <ID>MaxLineLength:NodeDetailsFragment.kt$NodeDetailsFragment$viewModel.updateClicked(nodeDetailsNameField.content.text.toString(), nodeDetailsHostField.content.text.toString())</ID>
    <ID>MaxLineLength:NodeDetailsRootViewModel.kt$NodeDetailsRootViewModel$is NodeAlreadyExistsException -&gt; showError(resourceManager.getString(R.string.connection_add_already_exists_error))</ID>
    <ID>MaxLineLength:NominatedValidator.kt$NominatedValidator.Status.Group$WaitingForNextEra : Group</ID>
    <ID>MaxLineLength:NotZeroBalanceValidation.kt$NotZeroBalanceValidation$ValidationStatus.NotValid(DefaultFailureLevel.WARNING, SetControllerValidationFailure.ZERO_CONTROLLER_BALANCE)</ID>
    <ID>MaxLineLength:NotZeroBalanceValidation.kt$NotZeroBalanceValidation$override suspend</ID>
    <ID>MaxLineLength:NotZeroBalanceValidation.kt$NotZeroBalanceValidation$val controllerBalance = walletRepository.getAccountFreeBalance(asset, chain.accountIdOf(value.controllerAddress)).toBigDecimal()</ID>
    <ID>MaxLineLength:NumberFormatters.kt$fun Long.formatDateTime(context: Context)</ID>
    <ID>MaxLineLength:ObserveBrowserEvents.kt$fun</ID>
    <ID>MaxLineLength:ObserveRewardDestinationChooser.kt$chooser.findViewById&lt;LabeledTextView&gt;(R.id.rewardDestinationChooserPayoutTarget).setVisible(it is RewardDestinationModel.Payout)</ID>
    <ID>MaxLineLength:ObserveRewardDestinationChooser.kt$chooser.findViewById&lt;RewardDestinationView&gt;(R.id.rewardDestinationChooserPayout).isChecked = it is RewardDestinationModel.Payout</ID>
    <ID>MaxLineLength:ObserveRewardDestinationChooser.kt$chooser.findViewById&lt;RewardDestinationView&gt;(R.id.rewardDestinationChooserRestake).isChecked = it is RewardDestinationModel.Restake</ID>
    <ID>MaxLineLength:OperationDao.kt$private const val ID_FILTER = "address = :address AND chainId = :chainId AND :chainAssetId IN (chainAssetId, targetAssetId)"</ID>
    <ID>MaxLineLength:OperationMappers.kt$Operation.Status.COMPLETED -&gt; resourceManager.getString(R.string.polkaswap_confirmation_swapped_stub)</ID>
    <ID>MaxLineLength:OperationMappers.kt$amount = chainAsset.planksFromAmount(data?.firstOrNull { it.paramName == "amount" }?.paramValue?.toBigDecimal().orZero())</ID>
    <ID>MaxLineLength:OperationMappers.kt$fun</ID>
    <ID>MaxLineLength:OperationMappers.kt$operationIcon = iconGenerator.createAddressIcon(operationType.displayAddress, AddressIconGenerator.SIZE_BIG)</ID>
    <ID>MaxLineLength:OperationMappers.kt$val baseAssetAmount = data?.firstOrNull { it.paramName == "baseAssetAmount" }?.paramValue?.toBigDecimal().orZero()</ID>
    <ID>MaxLineLength:OperationMappers.kt$val feeFormatted = operationType.fee?.formatFee(chainAsset) ?: resourceManager.getString(R.string.common_unknown)</ID>
    <ID>MaxLineLength:OperationMappers.kt$val liquidityProviderFee = data?.firstOrNull { it.paramName == "liquidityProviderFee" }?.paramValue?.toBigDecimal().orZero()</ID>
    <ID>MaxLineLength:OperationMappers.kt$val targetAssetAmount = data?.firstOrNull { it.paramName == "targetAssetAmount" }?.paramValue?.toBigDecimal().orZero()</ID>
    <ID>MaxLineLength:ParachainNetworkInfoView.kt$ParachainNetworkInfoView$private val binding = ViewParachainNetworkInfoBinding.bind(inflate(context, R.layout.view_parachain_network_info, this))</ID>
    <ID>MaxLineLength:PaymentUpdater.kt$.</ID>
    <ID>MaxLineLength:PaymentUpdater.kt$ChainAssetType.Assets -&gt; runtime.metadata.module(Modules.ASSETS).storage("Account").storageKey(runtime, currency, accountId)</ID>
    <ID>MaxLineLength:PaymentUpdater.kt$ChainAssetType.LiquidCrowdloan</ID>
    <ID>MaxLineLength:PaymentUpdater.kt$ChainAssetType.SoraUtilityAsset</ID>
    <ID>MaxLineLength:PaymentUpdater.kt$PaymentUpdater$.</ID>
    <ID>MaxLineLength:PaymentUpdater.kt$PaymentUpdater$val</ID>
    <ID>MaxLineLength:PaymentUpdater.kt$val currency = asset.currency ?: return@runCatching runtime.metadata.system().storage("Account").storageKey(runtime, accountId)</ID>
    <ID>MaxLineLength:PayoutDetailsViewModel.kt$PayoutDetailsViewModel$val supportedExplorers = chain.explorers.getSupportedExplorers(BlockExplorerUrlBuilder.Type.ACCOUNT, payout.validatorInfo.address)</ID>
    <ID>MaxLineLength:PayoutRepository.kt$PayoutRepository$val exposure = allResults[exposureKey]?.let { bindExposure(it, runtime, exposureClippedStorage.returnType()) }</ID>
    <ID>MaxLineLength:PayoutRepository.kt$PayoutRepository$val ledger = ledgerResults[ledgerKeysMapping[validatorAddress]]?.let { bindStakingLedger(it, runtime) } ?: return@mapNotNull null</ID>
    <ID>MaxLineLength:PayoutRepository.kt$PayoutRepository$val nominatorReward = validatorTotalReward * (1 - validatorCommission) * (nominatorStakeInEra / validatorTotalStake)</ID>
    <ID>MaxLineLength:PayoutRepository.kt$PayoutRepository$val prefs = allResults[prefsKey]?.let { bindValidatorPrefs(it, runtime, validatorPrefsStorage.returnType()) }</ID>
    <ID>MaxLineLength:PayoutRepository.kt$PayoutRepository$val validatorRewardFromStake = validatorTotalReward * (1 - validatorCommission) * (validatorOwnStake / validatorTotalStake)</ID>
    <ID>MaxLineLength:PayoutRepository.kt$PayoutRepository$val validatorStats = getValidatorHistoricalStats(runtime, connection.socketService, historicalRange, validatorAddresses)</ID>
    <ID>MaxLineLength:PayoutRepository.kt$PayoutRepository$val validatorTotalReward = calculateValidatorTotalReward(totalEraReward, eraValidatorPointsDistribution, validatorAccountId) ?: return null</ID>
    <ID>MaxLineLength:PayoutsListFragment.kt$PayoutsListFragment$class</ID>
    <ID>MaxLineLength:PayoutsListViewModel.kt$PayoutsListViewModel$val errorMessage = throwable.message ?: resourceManager.getString(R.string.common_undefined_error_message)</ID>
    <ID>MaxLineLength:PayoutsListViewModel.kt$PayoutsListViewModel$val totalAmount = token.amountFromPlanks(statistics.totalAmountInPlanks).formatCrypto(token.configuration.symbol)</ID>
    <ID>MaxLineLength:PendingPayoutModel.kt$PendingPayoutModel$val createdAt: Long</ID>
    <ID>MaxLineLength:PinCodeViewModel.kt$PinCodeViewModel$is ScreenState.Confirmation -&gt; matchPinCodeWithCodeToConfirm(pin, (currentState as ScreenState.Confirmation).codeToConfirm)</ID>
    <ID>MaxLineLength:PolkaswapDisclaimerViewModel.kt$PolkaswapDisclaimerViewModel$TextWithHighlights.HighlightedTextParameters(colorAccent, "https://wiki.sora.org/ecosystem/what-is-polkaswap/privacy")</ID>
    <ID>MaxLineLength:PolkaswapDisclaimerViewModel.kt$PolkaswapDisclaimerViewModel$TextWithHighlights.HighlightedTextParameters(colorAccent, "https://wiki.sora.org/ecosystem/what-is-polkaswap/terms")</ID>
    <ID>MaxLineLength:PolkaswapFeatureBindModule.kt$PolkaswapFeatureModule$return PolkaswapRepositoryImpl(remoteConfigFetcher, remoteSource, extrinsicService, chainRegistry, rpcCalls, accountRepository)</ID>
    <ID>MaxLineLength:PolkaswapInteractorImpl.kt$PolkaswapInteractorImpl$override suspend</ID>
    <ID>MaxLineLength:PolkaswapInteractorImpl.kt$PolkaswapInteractorImpl$return feeAsset.token.configuration.amountFromPlanks(fee) + feeAsset.token.configuration.amountFromPlanks(liquidityProxyFee)</ID>
    <ID>MaxLineLength:PolkaswapInteractorImpl.kt$PolkaswapInteractorImpl$return polkaswapRepository.swap(polkaswapChainId, dexId, inputAssetId, outputAssetId, amount, limit, filter, markets, desired)</ID>
    <ID>MaxLineLength:PolkaswapInteractorImpl.kt$PolkaswapInteractorImpl$return walletRepository.getAsset(metaAccount.id, metaAccount.accountId(chain)!!, chainAsset, chain.minSupportedVersion)!!</ID>
    <ID>MaxLineLength:PolkaswapRepository.kt$PolkaswapRepository$suspend fun getAvailableSources(chainId: ChainId, tokenId1: String, tokenId2: String, dexes: List&lt;Int&gt;): Map&lt;Int, List&lt;Market&gt;&gt;</ID>
    <ID>MaxLineLength:PolkaswapRepositoryImpl.kt$PolkaswapRepositoryImpl$override suspend</ID>
    <ID>MaxLineLength:PolkaswapRepositoryImpl.kt$PolkaswapRepositoryImpl$val markets = rpcCalls.liquidityProxyListEnabledSourcesForPath(chainId, dexId, tokenId1, tokenId2).toMarkets()</ID>
    <ID>MaxLineLength:PoolBondMoreViewModel.kt$PoolBondMoreViewModel$stakingPoolSharedStateProvider.manageState.get()?.copy(amountInPlanks = amount)?.let { stakingPoolSharedStateProvider.manageState.set(it) }</ID>
    <ID>MaxLineLength:PoolFullUnstakeDepositorAlertFragment.kt$PoolFullUnstakeDepositorAlertFragment$H3(text = stringResource(R.string.pool_depositor_unstake_error_title), modifier = Modifier.align(Alignment.CenterHorizontally))</ID>
    <ID>MaxLineLength:PoolFullUnstakeDepositorAlertFragment.kt$PoolFullUnstakeDepositorAlertFragment$text = stringResource(id = R.string.pool_depositor_unstake_polkadot_js_plus_button_text)</ID>
    <ID>MaxLineLength:PoolInfoScreen.kt$state.validators.copy(clickState = TitleValueViewState.ClickState.Value(R.drawable.ic_chevron_right, VALIDATORS_CLICK_STATE_IDENTIFIER))</ID>
    <ID>MaxLineLength:PoolInfoViewModel.kt$PoolInfoViewModel$TitleValueViewState(resourceManager.getString(R.string.staking_recommended_title), validators.size.toString()) to validators.isNotEmpty()</ID>
    <ID>MaxLineLength:PoolInfoViewModel.kt$PoolInfoViewModel$members = TitleValueViewState(resourceManager.getString(R.string.pool_info_members), poolInfo.members.toString())</ID>
    <ID>MaxLineLength:PoolInfoViewModel.kt$PoolInfoViewModel$poolId = TitleValueViewState(resourceManager.getString(R.string.pool_info_index), poolInfo.poolId.toString())</ID>
    <ID>MaxLineLength:PoolInfoViewModel.kt$PoolInfoViewModel$stakingPoolSharedStateProvider.selectedValidatorsState.mutate { requireNotNull(it).copy(selectedValidators = validators) }</ID>
    <ID>MaxLineLength:PoolInfoViewModel.kt$PoolInfoViewModel$val</ID>
    <ID>MaxLineLength:PoolInfoViewModel.kt$PoolInfoViewModel$val canChangeValidators = poolInfo.root.contentEquals(currentUserAccountId) || poolInfo.nominator.contentEquals(currentUserAccountId)</ID>
    <ID>MaxLineLength:PoolInfoViewModel.kt$PoolInfoViewModel$val roles = setOf(poolInfo.root, poolInfo.depositor, poolInfo.nominator, poolInfo.stateToggler).filterNotNull().toList()</ID>
    <ID>MaxLineLength:PoolInfoViewModel.kt$PoolInfoViewModel$}</ID>
    <ID>MaxLineLength:PoolRedeemViewModel.kt$PoolRedeemViewModel$feeEstimator = { stakingPoolInteractor.estimateRedeemFee(requireNotNull(stakingPoolSharedStateProvider.mainState.get()?.address)) }</ID>
    <ID>MaxLineLength:PoolUnstakeViewModel.kt$PoolUnstakeViewModel$availableAmountForOperation = { it.token.amountFromPlanks(stakingPoolSharedStateProvider.requireManageState.stakedInPlanks) }</ID>
    <ID>MaxLineLength:PoolUnstakeViewModel.kt$PoolUnstakeViewModel$stakingPoolSharedStateProvider.manageState.get()?.copy(amountInPlanks = amount)?.let { stakingPoolSharedStateProvider.manageState.set(it) }</ID>
    <ID>MaxLineLength:PoolUnstakeViewModel.kt$PoolUnstakeViewModel$val minToCreate = stakingPoolInteractor.getMinToCreate(stakingPoolSharedStateProvider.requireMainState.requireChain.id)</ID>
    <ID>MaxLineLength:ProfileModule.kt$ProfileModule$fun</ID>
    <ID>MaxLineLength:QrCodeGenerator.kt$QrCodeGenerator$bitmap.setPixel(x, y, if (byteMatrix.get(x - PADDING_SIZE / 2, y - PADDING_SIZE / 2).toInt() == 1) firstColor else secondColor)</ID>
    <ID>MaxLineLength:RampProvider.kt$"https://raw.githubusercontent.com/soramitsu/fearless-Android/dff3ebbed4a125621732ee039f2bc74c74f5b58f/common/src/main/res/drawable-xxxhdpi/ic_wallet.png"</ID>
    <ID>MaxLineLength:RebondValidationsModule.kt$RebondValidationsModule$fun</ID>
    <ID>MaxLineLength:ReceiveFragment.kt$ReceiveFragment$val imageUri = FileProvider.getUriForFile(requireActivity(), "${requireActivity().packageName}.provider", qrSharingPayload.qrFile)</ID>
    <ID>MaxLineLength:RecommendationSettingsProvider.kt$RecommendationSettingsProvider.RelayChain$Filters.NotOverSubscribed -&gt; BlockProducerFilters.ValidatorFilter.NotOverSubscribedFilter(maximumRewardedNominators)</ID>
    <ID>MaxLineLength:RecommendedValidatorsFragment.kt$RecommendedValidatorsFragment$class</ID>
    <ID>MaxLineLength:RedeemViewModel.kt$RedeemViewModel$val retrieveAmount = stakingScenarioInteractor.getUnstakeAvailableAmount(it, payload.collatorAddress?.fromHex())</ID>
    <ID>MaxLineLength:ReferralContributeViewState.kt$ReferralContributeViewState$customContributePayload.parachainMetadata.flow?.data?.getString(FLOW_TERMS_URL) ?: customContributePayload.parachainMetadata.website</ID>
    <ID>MaxLineLength:ReferralContributeViewState.kt$ReferralContributeViewState$privacyAccepted.not() -&gt; ApplyActionState.Unavailable(reason = resourceManager.getString(R.string.crowdloan_empty_bonus_title))</ID>
    <ID>MaxLineLength:ReferralContributeViewState.kt$ReferralContributeViewState$private val fearlessReferral = customContributePayload.parachainMetadata.flow?.data?.getString(FLOW_FEARLESS_REFERRAL)</ID>
    <ID>MaxLineLength:ReferralContributeViewState.kt$ReferralContributeViewState$referral.isEmpty() -&gt; ApplyActionState.Unavailable(reason = resourceManager.getString(R.string.crowdloan_enter_referral))</ID>
    <ID>MaxLineLength:ReferralContributeViewState.kt$ReferralContributeViewState$text = resourceManager.getString(R.string.crowdloan_learn_bonuses, customContributePayload.parachainMetadata.name)</ID>
    <ID>MaxLineLength:Reused.kt$typealias BalanceAccountRequiredValidation = AccountRequiredValidation&lt;ManageStakingValidationPayload, ManageStakingValidationFailure&gt;</ID>
    <ID>MaxLineLength:Reused.kt$typealias BalanceUnlockingLimitValidation = UnbondingRequestsLimitValidation&lt;ManageStakingValidationPayload, ManageStakingValidationFailure&gt;</ID>
    <ID>MaxLineLength:ReviewCustomValidatorsViewModel.kt$ReviewCustomValidatorsViewModel$(it as? SetupStakingProcess.SelectBlockProducersStep.Validators)?.next(validators, SetupStakingProcess.ReadyToSubmit.SelectionMethod.CUSTOM)</ID>
    <ID>MaxLineLength:ReviewCustomValidatorsViewModel.kt$ReviewCustomValidatorsViewModel$resourceManager.getString(R.string.staking_custom_proceed_button_disabled_title, maxValidatorsPerNominator)</ID>
    <ID>MaxLineLength:ReviewCustomValidatorsViewModel.kt$ReviewCustomValidatorsViewModel$selectedHeaderText = resourceManager.getString(R.string.staking_selected_validators_count, validators.size, maxValidatorsPerNominator)</ID>
    <ID>MaxLineLength:Reward.kt$val gainWithSuffix = rewardSuffix.suffixResourceId?.let { resourceManager.getString(it, gainFormatted) } ?: gainFormatted</ID>
    <ID>MaxLineLength:RewardCalculatorFactory.kt$RewardCalculatorFactory$val validatorsPayouts = relayChainRepository.getErasValidatorRewards(chainId).values.filterNotNull().map { asset.amountFromPlanks(it).toDouble() }</ID>
    <ID>MaxLineLength:RewardDestinationProvider.kt$RewardDestinationProvider$override</ID>
    <ID>MaxLineLength:RewardDestinationProvider.kt$RewardDestinationProvider$private suspend</ID>
    <ID>MaxLineLength:RewardDestinationProvider.kt$RewardDestinationProvider$private val initialRewardDestination = MutableSharedFlow&lt;RewardDestinationModel&gt;(replay = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST)</ID>
    <ID>MaxLineLength:RewardDestinationProvider.kt$RewardDestinationProvider$return addressIconGenerator.createAddressModel(address, AddressIconGenerator.SIZE_MEDIUM, accountDisplayUseCase(address))</ID>
    <ID>MaxLineLength:RewardDestinationProvider.kt$RewardDestinationProvider$showDestinationChooserEvent.value = Event(DynamicListBottomSheet.Payload(accountsInNetwork, selectedDestination.destination))</ID>
    <ID>MaxLineLength:RewardDestinationProvider.kt$RewardDestinationProvider$val payoutEstimations = mapPeriodReturnsToRewardEstimation(payoutReturns, rewardAsset, resourceManager, RewardSuffix.APR)</ID>
    <ID>MaxLineLength:RewardDestinationProvider.kt$RewardDestinationProvider$val restakeEstimations = mapPeriodReturnsToRewardEstimation(restakeReturns, rewardAsset, resourceManager, RewardSuffix.APY)</ID>
    <ID>MaxLineLength:RewardDestinationProvider.kt$RewardDestinationProvider$val selectedDestination = rewardDestinationModelFlow.first() as? RewardDestinationModel.Payout ?: return@launch</ID>
    <ID>MaxLineLength:RewardDestinationViewer.kt$RewardDestinationViewer$binding.viewRewardDestinationDestination.setDividerVisible(rewardDestinationModel is RewardDestinationModel.Restake)</ID>
    <ID>MaxLineLength:RewardDetailFragment.kt$RewardDetailFragment$explorers = viewModel.getSupportedExplorers(BlockExplorerUrlBuilder.Type.EVENT, viewModel.payload!!.operation.eventId)</ID>
    <ID>MaxLineLength:RewardDetailViewModel.kt$RewardDetailViewModel$private suspend fun getIcon(address: String)</ID>
    <ID>MaxLineLength:RootActivity.kt$RootActivity$view.updatePadding(top = WindowInsetsCompat.toWindowInsetsCompat(insets, view).getInsets(WindowInsetsCompat.Type.systemBars()).top)</ID>
    <ID>MaxLineLength:RuntimeProvider.kt$RuntimeProvider$(runtimeSyncResult.metadataHash != null &amp;&amp; currentVersion.metadataHash != runtimeSyncResult.metadataHash)</ID>
    <ID>MaxLineLength:RuntimeProvider.kt$RuntimeProvider$private val runtimeFlow = MutableSharedFlow&lt;ConstructedRuntime&gt;(replay = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST)</ID>
    <ID>MaxLineLength:RuntimeSyncService.kt$RuntimeSyncService$val runtimeMetadata = connectionPool.getConnection(chainId).socketService.executeAsync(GetMetadataRequest, mapper = pojo&lt;String&gt;().nonNull())</ID>
    <ID>MaxLineLength:RuntimeVersionSubscription.kt$RuntimeVersionSubscription$Log.e("RuntimeVersionSubscription", "Failed to subscribe runtime version for chain: $chainId. Error: $it")</ID>
    <ID>MaxLineLength:SearchAssetsFragment.kt$SearchAssetsFragment$override</ID>
    <ID>MaxLineLength:SearchAssetsScreen.kt$&lt;no name provided&gt;$override fun actionItemClicked(actionType: ActionItemType, chainId: ChainId, chainAssetId: String, swipeableState: SwipeableState&lt;SwipeState&gt;)</ID>
    <ID>MaxLineLength:SearchAssetsViewModel.kt$SearchAssetsViewModel$chains.groupBy { if (it.isTestNet) ChainEcosystem.STANDALONE else it.ecosystem() }</ID>
    <ID>MaxLineLength:SearchAssetsViewModel.kt$SearchAssetsViewModel$override</ID>
    <ID>MaxLineLength:SearchAssetsViewModel.kt$SearchAssetsViewModel$searchQuery.isEmpty() || it.assetSymbol.contains(searchQuery, true) || it.assetName.contains(searchQuery, true)</ID>
    <ID>MaxLineLength:SearchAssetsViewModel.kt$SearchAssetsViewModel$val assetChainUrls = ecosystemChains.getWithToken(symbol, assetIdsWithBalance).associate { it.id to it.icon }</ID>
    <ID>MaxLineLength:SearchAssetsViewModel.kt$SearchAssetsViewModel$val items = processAssets(chainAssets, listOf(chain), chainConnectings, hideZeroBalancesEnabled, ecosystem)</ID>
    <ID>MaxLineLength:SearchAssetsViewModel.kt$SearchAssetsViewModel$val items = processAssets(ecosystemAssets, ecosystemChains, chainConnectings, hideZeroBalancesEnabled, ecosystem)</ID>
    <ID>MaxLineLength:SearchBlockProducerModel.kt$SearchBlockProducerModel</ID>
    <ID>MaxLineLength:SearchCustomBlockProducerInteractor.kt$BlockedValidatorException : Exception</ID>
    <ID>MaxLineLength:SearchCustomBlockProducerInteractor.kt$SearchCustomBlockProducerInteractor$BlockProducer</ID>
    <ID>MaxLineLength:SearchCustomBlockProducerInteractor.kt$SearchCustomBlockProducerInteractor$private suspend</ID>
    <ID>MaxLineLength:SearchCustomBlockProducerInteractor.kt$SearchCustomBlockProducerInteractor$setupStakingProcess.get&lt;SetupStakingProcess.ReadyToSubmit.Stash&gt;().payload.blockProducers.toSet().toggle(selectedValidator)</ID>
    <ID>MaxLineLength:SearchCustomBlockProducerInteractor.kt$SearchCustomBlockProducerInteractor$suspend</ID>
    <ID>MaxLineLength:SearchCustomValidatorsFragment.kt$SearchCustomValidatorsFragment$binding.searchCustomValidatorProgress.setVisible(it is SearchBlockProducersState.Loading, falseState = View.INVISIBLE)</ID>
    <ID>MaxLineLength:SearchCustomValidatorsFragment.kt$SearchCustomValidatorsFragment$binding.searchCustomValidatorsList.setVisible(it is SearchBlockProducersState.Success, falseState = View.INVISIBLE)</ID>
    <ID>MaxLineLength:SearchCustomValidatorsFragment.kt$SearchCustomValidatorsFragment$binding.searchCustomValidatorsPlaceholder.setCompoundDrawablesRelativeWithIntrinsicBounds(0, R.drawable.ic_no_search_results, 0, 0)</ID>
    <ID>MaxLineLength:SearchCustomValidatorsFragment.kt$SearchCustomValidatorsFragment$binding.searchCustomValidatorsPlaceholder.setCompoundDrawablesRelativeWithIntrinsicBounds(0, R.drawable.ic_placeholder, 0, 0)</ID>
    <ID>MaxLineLength:SearchCustomValidatorsFragment.kt$SearchCustomValidatorsFragment$binding.searchCustomValidatorsPlaceholder.setVisible(it is SearchBlockProducersState.NoResults || it is SearchBlockProducersState.NoInput)</ID>
    <ID>MaxLineLength:SearchCustomValidatorsFragment.kt$SearchCustomValidatorsFragment$binding.searchCustomValidatorsPlaceholder.text = getString(R.string.staking_validator_search_empty_title)</ID>
    <ID>MaxLineLength:SearchCustomValidatorsViewModel.kt$SearchBlockProducersState$Success : SearchBlockProducersState</ID>
    <ID>MaxLineLength:SearchCustomValidatorsViewModel.kt$SearchCustomValidatorsViewModel$blockProducersState is LoadingState.Loaded &amp;&amp; blockProducersState.data == null -&gt; SearchBlockProducersState.NoInput</ID>
    <ID>MaxLineLength:SearchCustomValidatorsViewModel.kt$SearchCustomValidatorsViewModel$blockProducersState is LoadingState.Loaded &amp;&amp; blockProducersState.data?.isEmpty() == true -&gt; SearchBlockProducersState.NoResults</ID>
    <ID>MaxLineLength:SearchCustomValidatorsViewModel.kt$SearchCustomValidatorsViewModel$return SearchBlockProducerModel(name, address, selected, rewardsPercent, searchCustomBlockProducerInteractor.getIcon(address, SIZE_MEDIUM, type))</ID>
    <ID>MaxLineLength:SearchCustomValidatorsViewModel.kt$SearchCustomValidatorsViewModel$val result = searchCustomBlockProducerInteractor.blockProducerSelected(validatorModel.address, sharedStateSetup, router.currentStackEntryLifecycle)</ID>
    <ID>MaxLineLength:SecretStoreV1.kt$SecretStoreV1Impl$override suspend</ID>
    <ID>MaxLineLength:SecretStoreV2.kt$SecretStoreV2$encryptedPreferences.getDecryptedString(chainAccountKey(metaId, accountId, ACCESS_SECRETS))?.let(ChainAccountSecrets::read)</ID>
    <ID>MaxLineLength:SecretStoreV2.kt$SecretStoreV2$encryptedPreferences.putEncryptedString(chainAccountKey(metaId, accountId, ACCESS_SECRETS), secrets.toHexString())</ID>
    <ID>MaxLineLength:SecretStoreV2.kt$SecretStoreV2$private fun chainAccountKey(metaId: Long, accountId: ByteArray, secretName: String)</ID>
    <ID>MaxLineLength:SecretStoreV2.kt$SecretStoreV2$suspend</ID>
    <ID>MaxLineLength:SecretStoreV2.kt$val secrets = getChainAccountSecrets(metaId, accountId) ?: error("No secrets found for meta account $metaId for account ${accountId.toHexString()}")</ID>
    <ID>MaxLineLength:SeedImportView.kt$SeedImportView$ImportAccountType.Ethereum -&gt; binding.importSeedTitle.setText(R.string.account_import_ethereum_raw_seed_placeholder)</ID>
    <ID>MaxLineLength:SeedImportView.kt$SeedImportView$ImportAccountType.Substrate -&gt; binding.importSeedTitle.setText(R.string.account_import_substrate_raw_seed_placeholder)</ID>
    <ID>MaxLineLength:SegmentedButtonView.kt$SegmentedButtonView.ExtendedState$private</ID>
    <ID>MaxLineLength:SelectBondMoreViewModel.kt$SelectBondMoreViewModel$stakingScenarioInteractor.stakeMore(this, amountInPlanks, this@SelectBondMoreViewModel.payload.collatorAddress)</ID>
    <ID>MaxLineLength:SelectCustomCollatorsFragment.kt$SelectCustomCollatorsFragment$class</ID>
    <ID>MaxLineLength:SelectCustomCollatorsViewModel.kt$SelectCustomCollatorsViewModel$BlockProducersSorting.CollatorSorting.CollatorsOwnStakeSorting -&gt; resourceManager.getString(R.string.collator_staking_sorting_own_stake)</ID>
    <ID>MaxLineLength:SelectCustomCollatorsViewModel.kt$SelectCustomCollatorsViewModel$BlockProducersSorting.CollatorSorting.DelegationsSorting -&gt; resourceManager.getString(R.string.collator_staking_sorting_delegations)</ID>
    <ID>MaxLineLength:SelectCustomCollatorsViewModel.kt$SelectCustomCollatorsViewModel$BlockProducersSorting.CollatorSorting.MinimumBondSorting -&gt; resourceManager.getString(R.string.collator_staking_sorting_minimum_bond)</ID>
    <ID>MaxLineLength:SelectCustomCollatorsViewModel.kt$SelectCustomCollatorsViewModel$resourceManager.getString(R.string.staking_custom_header_collators_title, it.size, recommendator().availableCollators.size)</ID>
    <ID>MaxLineLength:SelectCustomCollatorsViewModel.kt$SelectCustomCollatorsViewModel$val</ID>
    <ID>MaxLineLength:SelectCustomValidatorsViewModel.kt$SelectCustomValidatorsViewModel$BlockProducersSorting.ValidatorSorting.TotalStakeSorting -&gt; resourceManager.getString(R.string.staking_validator_total_stake)</ID>
    <ID>MaxLineLength:SelectCustomValidatorsViewModel.kt$SelectCustomValidatorsViewModel$BlockProducersSorting.ValidatorSorting.ValidatorOwnStakeSorting -&gt; resourceManager.getString(R.string.staking_filter_title_own_stake)</ID>
    <ID>MaxLineLength:SelectCustomValidatorsViewModel.kt$SelectCustomValidatorsViewModel$addressIconGenerator.createAddressModel(it, AddressIconGenerator.SIZE_MEDIUM, validator.identity?.display)</ID>
    <ID>MaxLineLength:SelectCustomValidatorsViewModel.kt$SelectCustomValidatorsViewModel$resourceManager.getString(R.string.staking_custom_header_validators_title, it.size, recommendator().availableValidators.size)</ID>
    <ID>MaxLineLength:SelectCustomValidatorsViewModel.kt$SelectCustomValidatorsViewModel$text = resourceManager.getString(R.string.staking_custom_proceed_button_disabled_title, maxSelectedValidators)</ID>
    <ID>MaxLineLength:SelectCustomValidatorsViewModel.kt$SelectCustomValidatorsViewModel$text = resourceManager.getString(R.string.staking_custom_proceed_button_enabled_title, it.size, maxSelectedValidators)</ID>
    <ID>MaxLineLength:SelectCustomValidatorsViewModel.kt$SelectCustomValidatorsViewModel$val</ID>
    <ID>MaxLineLength:SelectPoolScreen.kt$items</ID>
    <ID>MaxLineLength:SelectRewardDestinationFragment.kt$SelectRewardDestinationFragment$class</ID>
    <ID>MaxLineLength:SelectRewardDestinationViewModel.kt$SelectRewardDestinationViewModel$is RewardDestinationModel.Payout -&gt; RewardDestinationParcelModel.Payout(rewardDestination.destination.address)</ID>
    <ID>MaxLineLength:SelectRewardDestinationViewModel.kt$SelectRewardDestinationViewModel$private</ID>
    <ID>MaxLineLength:SelectRewardDestinationViewModel.kt$SelectRewardDestinationViewModel$private val rewardCalculator = viewModelScope.async { rewardCalculatorFactory.create(interactor.currentAssetFlow().first().token.configuration) }</ID>
    <ID>MaxLineLength:SelectUnbondViewModel.kt$SelectUnbondViewModel$resourceManager.getQuantityString(R.plurals.common_hours_format, networkInfo.lockupPeriodInHours, networkInfo.lockupPeriodInHours)</ID>
    <ID>MaxLineLength:SelectUnbondViewModel.kt$SelectUnbondViewModel$stakingScenarioInteractor.stakeLess(this, amountInPlanks, stashState, asset.bondedInPlanks.orZero(), payload.collatorAddress)</ID>
    <ID>MaxLineLength:SelectUnbondViewModel.kt$SelectUnbondViewModel$val</ID>
    <ID>MaxLineLength:SelectUnbondViewModel.kt$SelectUnbondViewModel$val retrieveAmount = stakingScenarioInteractor.getUnstakeAvailableAmount(asset, payload.collatorAddress?.fromHex())</ID>
    <ID>MaxLineLength:SelectUnbondViewModel.kt$SelectUnbondViewModel$val retrieveAmount = stakingScenarioInteractor.getUnstakeAvailableAmount(it, payload.collatorAddress?.fromHex())</ID>
    <ID>MaxLineLength:SelectValidatorsVariantPanel.kt$additionalInfo = listOf("Most profitable", "Not oversubscribed", "Having onchain identity", "Not slashed", "Limit of 2 validators per identity")</ID>
    <ID>MaxLineLength:SelectValidatorsVariantPanel.kt$description</ID>
    <ID>MaxLineLength:SelectValidatorsViewModel.kt$BlockProducersSorting.ValidatorSorting.ValidatorOwnStakeSorting -&gt; resourceManager.getString(R.string.staking_filter_title_own_stake)</ID>
    <ID>MaxLineLength:SelectValidatorsViewModel.kt$SelectValidatorsViewModel$SelectValidatorFlowState.ValidatorSelectMode.CUSTOM -&gt; resourceManager.getString(R.string.staking_select_custom)</ID>
    <ID>MaxLineLength:SelectValidatorsViewModel.kt$SelectValidatorsViewModel$SelectValidatorFlowState.ValidatorSelectMode.RECOMMENDED -&gt; resourceManager.getString(R.string.staking_select_suggested)</ID>
    <ID>MaxLineLength:SelectValidatorsViewModel.kt$SelectValidatorsViewModel$combine</ID>
    <ID>MaxLineLength:SelectValidatorsViewModel.kt$SelectValidatorsViewModel$identityNameLowerCase.contains(searchQueryLowerCase) || addressLowerCase.contains(searchQueryLowerCase)</ID>
    <ID>MaxLineLength:SelectValidatorsViewModel.kt$SelectValidatorsViewModel$private val validatorRecommendator by lazyAsync { validatorRecommendatorFactory.create(router.currentStackEntryLifecycle) }</ID>
    <ID>MaxLineLength:SelectValidatorsViewModel.kt$SelectValidatorsViewModel$val isOverSubscribed = item.additionalStatuses.contains(SelectableListItemState.SelectableListItemAdditionalStatus.OVERSUBSCRIBED)</ID>
    <ID>MaxLineLength:SelectWalletContent.kt$items</ID>
    <ID>MaxLineLength:SelectWalletContent.kt$wallets = listOf(walletState, walletState, walletState, walletState, walletState, walletState, walletState, walletState)</ID>
    <ID>MaxLineLength:SelectableListItem.kt$SelectableListItemState.SelectableListItemAdditionalStatus$WARNING : SelectableListItemAdditionalStatus</ID>
    <ID>MaxLineLength:SelectedValidatorsViewModel.kt$SelectedValidatorsViewModel$private val canChangeValidators: Boolean = poolSharedStateProvider.requireSelectedValidatorsState.requireCanChangeValidators</ID>
    <ID>MaxLineLength:SelectedValidatorsViewModel.kt$SelectedValidatorsViewModel$private val validatorsFlow: MutableStateFlow&lt;GroupedList&lt;NominatedValidator.Status.Group, NominatedValidator&gt;?&gt; = MutableStateFlow(null)</ID>
    <ID>MaxLineLength:SelectedValidatorsViewModel.kt$SelectedValidatorsViewModel$private val validatorsToShow: List&lt;AccountId&gt; = poolSharedStateProvider.requireSelectedValidatorsState.selectedValidators</ID>
    <ID>MaxLineLength:SelectedValidatorsViewModel.kt$SelectedValidatorsViewModel$title = if (!hasActive) resourceManager.getString(R.string.staking_your_elected_format, statusGroup.numberOfValidators) else null</ID>
    <ID>MaxLineLength:SendSetupFragment.kt$SendSetupFragment$private</ID>
    <ID>MaxLineLength:SendSetupViewModel.kt$SendSetupViewModel$)</ID>
    <ID>MaxLineLength:SendSetupViewModel.kt$SendSetupViewModel$else -&gt; addressIconGenerator.createAddressIcon(chain?.isEthereumBased == true, address, AddressIconGenerator.SIZE_BIG)</ID>
    <ID>MaxLineLength:SendSetupViewModel.kt$SendSetupViewModel$private val _openValidationWarningEvent = MutableLiveData&lt;Event&lt;Pair&lt;TransferValidationResult, ValidationWarning&gt;&gt;&gt;()</ID>
    <ID>MaxLineLength:SendSetupViewModel.kt$SendSetupViewModel$val openValidationWarningEvent: LiveData&lt;Event&lt;Pair&lt;TransferValidationResult, ValidationWarning&gt;&gt;&gt; = _openValidationWarningEvent</ID>
    <ID>MaxLineLength:SetControllerViewModel.kt$SetControllerViewModel$selectedController.address != stakingState.controllerAddress</ID>
    <ID>MaxLineLength:SetControllerViewModel.kt$SetControllerViewModel$val supportedExplorers = chain.explorers.getSupportedExplorers(BlockExplorerUrlBuilder.Type.ACCOUNT, stashAddress)</ID>
    <ID>MaxLineLength:SettingsFiltersAdapter.kt$SettingsFilterViewHolder$class</ID>
    <ID>MaxLineLength:SettingsFiltersAdapter.kt$SettingsFilterViewHolder$itemView.findViewById&lt;SwitchMaterial&gt;(R.id.settingsFilterItem).setOnClickListener { onCheckListener(adapterPosition) }</ID>
    <ID>MaxLineLength:SettingsSortingAdapter.kt$SettingsSortingViewHolder$class</ID>
    <ID>MaxLineLength:SettingsSortingAdapter.kt$SettingsSortingViewHolder$itemView.findViewById&lt;MaterialRadioButton&gt;(R.id.settingsSortingItem).setOnClickListener { onCheckListener(adapterPosition) }</ID>
    <ID>MaxLineLength:SetupStakingInteractor.kt$SetupStakingInteractor$delegate(selectedCollator.address.fromHex(), amountInPlanks, selectedCollator.delegationCount, delegationCount.toBigInteger())</ID>
    <ID>MaxLineLength:SetupStakingInteractor.kt$SetupStakingInteractor$suspend</ID>
    <ID>MaxLineLength:SetupStakingPoolViewModel.kt$SetupStakingPoolViewModel$amountInPlanks + feeInPlanks &gt;= transferableInPlanks -&gt; Result.failure(StakeInsufficientBalanceException(resourceManager))</ID>
    <ID>MaxLineLength:SetupStakingPoolViewModel.kt$SetupStakingPoolViewModel$amountInPlanks &lt; minToJoinInPlanks -&gt; Result.failure(AmountTooLowToStakeException(resourceManager, minToJoinFormatted))</ID>
    <ID>MaxLineLength:SetupStakingPoolViewModel.kt$SetupStakingPoolViewModel$private val toolbarViewState = ToolbarViewState(resourceManager.getString(R.string.pool_staking_join_title), R.drawable.ic_arrow_back_24dp)</ID>
    <ID>MaxLineLength:SetupStakingPoolViewModel.kt$SetupStakingPoolViewModel$throwable.localizedMessage ?: throwable.message ?: resourceManager.getString(R.string.common_undefined_error_message)</ID>
    <ID>MaxLineLength:SetupStakingPoolViewModel.kt$SetupStakingPoolViewModel$transferableInPlanks - amountInPlanks - feeInPlanks &lt;= existentialDeposit -&gt; Result.failure(ExistentialDepositCrossedException(resourceManager))</ID>
    <ID>MaxLineLength:SetupStakingPoolViewModel.kt$SetupStakingPoolViewModel$val feeInPlanks = feeInPlanksFlow.value ?: return Result.failure(WaitForFeeCalculationException(resourceManager))</ID>
    <ID>MaxLineLength:SetupStakingScreen.kt$tokenImage = "https://raw.githubusercontent.com/soramitsu/fearless-utils/master/icons/chains/white/Karura.svg"</ID>
    <ID>MaxLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit$abstract fun changeBlockProducers(newBlockProducers: List&lt;T&gt;, selectionMethod: SelectionMethod): ReadyToSubmit&lt;T&gt;</ID>
    <ID>MaxLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit$is Payload.Full -&gt; SelectBlockProducersStep.Payload.Full(payload.amount, payload.rewardDestination, payload.currentAccountAddress)</ID>
    <ID>MaxLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit$is Payload.Parachain -&gt; SelectBlockProducersStep.Payload.Parachain(payload.amount, payload.currentAccountAddress)</ID>
    <ID>MaxLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Parachain$override</ID>
    <ID>MaxLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Payload$// override fun changeBlockProducers(newBlockProducers: List&lt;Collator&gt;, selectionMethod: SelectionMethod): Payload&lt;Collator&gt; {</ID>
    <ID>MaxLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Payload$// override fun changeBlockProducers(newBlockProducers: List&lt;Validator&gt;, selectionMethod: SelectionMethod): Payload&lt;Validator&gt; {</ID>
    <ID>MaxLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Payload.ExistingStash$override</ID>
    <ID>MaxLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Payload.Full$override</ID>
    <ID>MaxLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Payload.Parachain$override</ID>
    <ID>MaxLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Payload.RelayChain$override</ID>
    <ID>MaxLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Stash$override</ID>
    <ID>MaxLineLength:SetupStakingSharedState.kt$SetupStakingProcess.SelectBlockProducersStep.Collators$setOf(Sorting.EstimatedRewards, Sorting.EffectiveAmountBonded, Sorting.CollatorsOwnStake, Sorting.Delegations, Sorting.MinimumBond)</ID>
    <ID>MaxLineLength:SetupStakingSharedState.kt$SetupStakingProcess.SelectBlockProducersStep.Validators$is Payload.Full -&gt; ReadyToSubmit.Payload.Full(amount, rewardDestination, controllerAddress, validators, selectionMethod)</ID>
    <ID>MaxLineLength:SetupStakingSharedState.kt$SetupStakingProcess.SelectBlockProducersStep.Validators$is Payload.Relaychain -&gt; ReadyToSubmit.Payload.RelayChain(amount, rewardDestination, controllerAddress, validators, selectionMethod)</ID>
    <ID>MaxLineLength:SetupStakingSharedState.kt$SetupStakingProcess.SetupStep.Parachain$return SelectBlockProducersStep.Collators(SelectBlockProducersStep.Payload.Parachain(payload.newAmount, payload.currentAccountAddress))</ID>
    <ID>MaxLineLength:SetupStakingViewModel.kt$SetupStakingViewModel$Asset.StakingType.PARACHAIN -&gt; SetupStakingProcess.SetupStep.Payload.Parachain(newAmount, currentAccountAddress)</ID>
    <ID>MaxLineLength:SetupStakingViewModel.kt$SetupStakingViewModel$Asset.StakingType.RELAYCHAIN -&gt; SetupStakingProcess.SetupStep.Payload.RelayChain(newAmount, rewardDestination, currentAccountAddress)</ID>
    <ID>MaxLineLength:SetupStakingViewModel.kt$SetupStakingViewModel$_showMinimumStakeAlert.value = Event(minimumStakeAmount.formatCryptoDetail(payload.asset.token.configuration.symbol))</ID>
    <ID>MaxLineLength:SetupStakingViewModel.kt$SetupStakingViewModel$val addressModel = addressIconGenerator.createEthereumAddressModel(projection.address, AddressIconGenerator.SIZE_MEDIUM, projection.name)</ID>
    <ID>MaxLineLength:SignBeaconTransactionFragment.kt$SignBeaconTransactionFragment$class</ID>
    <ID>MaxLineLength:SignBeaconTransactionViewModel.kt$SignBeaconTransactionViewModel$private</ID>
    <ID>MaxLineLength:SoraCardInteractorImpl.kt$SoraCardInteractorImpl$override suspend</ID>
    <ID>MaxLineLength:SoraCardInteractorImpl.kt$SoraCardInteractorImpl$return walletRepository.assetFlow(metaAccount.id, metaAccount.substrateAccountId, xorAsset, chain.minSupportedVersion)</ID>
    <ID>MaxLineLength:SoraHistorySource.kt$SoraHistorySource$soraTestChainId -&gt; soraSubqueryFactory.create(soramitsuNetworkClient, pageSize, soraStageRemoteConfigBuilder)</ID>
    <ID>MaxLineLength:SoraRewardCalculator.kt$SoraRewardCalculator$override suspend</ID>
    <ID>MaxLineLength:SoraStakingRewardsScenario.kt$SoraStakingRewardsScenario$class</ID>
    <ID>MaxLineLength:StakeInfoViewState.kt$fun</ID>
    <ID>MaxLineLength:StakeSummaryView.kt$StakeSummaryView$binding.stakeSummaryStatusHelper.startTimer(millis = status.timeLeft, extraMessage = status.extraMessage, hideZeroTimer = status.hideZeroTimer)</ID>
    <ID>MaxLineLength:StakeSummaryView.kt$StakeSummaryView.Status$Active : Status</ID>
    <ID>MaxLineLength:StakeSummaryView.kt$StakeSummaryView.Status$Inactive : Status</ID>
    <ID>MaxLineLength:StakeSummaryView.kt$StakeSummaryView.Status$ReadyToUnlockCollator : Status</ID>
    <ID>MaxLineLength:StakingAssetInfoViewState.kt$activeNominators = TitleValueViewState(resourceManager.getString(R.string.staking_main_active_nominators_title), null)</ID>
    <ID>MaxLineLength:StakingAssetInfoViewState.kt$existingPools = TitleValueViewState(resourceManager.getString(R.string.pool_staking_main_existing_pools_title), null)</ID>
    <ID>MaxLineLength:StakingAssetInfoViewState.kt$fun</ID>
    <ID>MaxLineLength:StakingAssetInfoViewState.kt$maxMembersInPool = TitleValueViewState(resourceManager.getString(R.string.pool_staking_main_max_members_inpool_title), null)</ID>
    <ID>MaxLineLength:StakingAssetInfoViewState.kt$maxPoolsMembers = TitleValueViewState(resourceManager.getString(R.string.pool_staking_main_max_pool_members_title), null)</ID>
    <ID>MaxLineLength:StakingAssetInfoViewState.kt$possiblePools = TitleValueViewState(resourceManager.getString(R.string.pool_staking_main_possible_pools_title), null)</ID>
    <ID>MaxLineLength:StakingAssetSelector.kt$StakingAssetSelector$val asset = availableAssetsToSelect.firstOrNull { it.token.configuration.id == selection.chainAssetId } ?: return@mapNotNull null</ID>
    <ID>MaxLineLength:StakingConstantsRepository.kt$StakingConstantsRepository$suspend fun maxRewardedNominatorPerValidator(chainId: ChainId): Int</ID>
    <ID>MaxLineLength:StakingConstantsRepository.kt$StakingConstantsRepository$suspend fun parachainLeaveCandidatesDelay(chainId: ChainId): BigInteger</ID>
    <ID>MaxLineLength:StakingConstantsRepository.kt$StakingConstantsRepository$suspend fun parachainLockupPeriodInRounds(chainId: ChainId): BigInteger</ID>
    <ID>MaxLineLength:StakingConstantsRepository.kt$StakingConstantsRepository$suspend fun parachainMinimumStaking(chainId: ChainId): BigInteger</ID>
    <ID>MaxLineLength:StakingFeatureModule.kt$StakingFeatureModule$)</ID>
    <ID>MaxLineLength:StakingFeatureModule.kt$StakingFeatureModule$return PayoutRepository(stakingRelayChainScenarioRepository, bulkRetriever, validatorSetFetcher, storageCache, chainRegistry)</ID>
    <ID>MaxLineLength:StakingFragment.kt$StakingFragment$AssetSelector(state = it.selectorState, onClick = { viewModel.assetSelectorMixin.assetSelectorClicked() })</ID>
    <ID>MaxLineLength:StakingFragment.kt$StakingFragment$class</ID>
    <ID>MaxLineLength:StakingFragment.kt$StakingFragment$val isEstimatesVisible = stakingState is RelaychainWelcomeViewState || stakingState is ParachainWelcomeViewState</ID>
    <ID>MaxLineLength:StakingInfoItem.kt$state is StakeStatus.WithTimer -&gt; Timer(state.timeLeft, modifier = Modifier.weight(1f), textAlign = TextAlign.End)</ID>
    <ID>MaxLineLength:StakingInfoItem.kt$state.extraMessage != null -&gt; Text(text = state.extraMessage, modifier = Modifier.weight(1f), textAlign = TextAlign.End)</ID>
    <ID>MaxLineLength:StakingInteractor.kt$StakingInteractor$chainRegistry.getRuntime(chain.id).metadata.module(Modules.STAKING).calls?.get("set_controller")?.arguments?.isEmpty() == true</ID>
    <ID>MaxLineLength:StakingInteractor.kt$StakingInteractor$val cachedBalance = stashMetaAccount?.let { walletRepository.getAsset(stashMetaAccount.id, stashId, configuration, null)?.availableForStaking }</ID>
    <ID>MaxLineLength:StakingInteractor.kt$StakingInteractor$val currentAccountHasAnotherController = controllerAccount != null &amp;&amp; !controllerAccount.contentEquals(accountId) // user needs to fix it</ID>
    <ID>MaxLineLength:StakingInteractor.kt$StakingInteractor$val currentAccountIsStashAndController = controllerAccount != null &amp;&amp; controllerAccount.contentEquals(accountId) // the case is resolved</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$Optional.of(iconGenerator.createEthereumAddressModel(it.address, AddressIconGenerator.SIZE_MEDIUM, it.name))</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$override</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$override suspend</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$private</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$redeemable = mapAmountToAmountModel(readyForUnlocking, asset, R.string.staking_balance_ready_for_unlocking)</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$return</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$return runCatching { stakingParachainScenarioRepository.getAtStakeOfCollator(chainId, collatorId, getCurrentRound(chainId).getOrThrow().current) }</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$return runCatching { stakingParachainScenarioRepository.getStaked(chainId, getCurrentRound(chainId).getOrThrow().current) }</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$stakingParachainScenarioRepository.stakingStateFlow(chain, accountId).filterIsInstance&lt;StakingState.Parachain.Delegator&gt;()</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$suspend</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$val accountId = accountRepository.getSelectedMetaAccount().accountId(chain) ?: error("cannot find accountId")</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$val accountId = accountRepository.getSelectedMetaAccount().accountId(useChain) ?: error("cannot find accountId")</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$val delegationScheduledRequestsFlow = stakingParachainScenarioRepository.getDelegationScheduledRequestsFlow(chain.id, collatorId)</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$val delegatorStateFlow = stakingParachainScenarioRepository.stakingStateFlow(chain, accountId).filterIsInstance&lt;StakingState.Parachain.Delegator&gt;()</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$val model = iconGenerator.createEthereumAddressModel(collatorAddress, AddressIconGenerator.SIZE_MEDIUM, name)</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$val roundsPart = resourceManager.getQuantityString(R.plurals.rounds_format, bondLessDelayInRounds, bondLessDelayInRounds)</ID>
    <ID>MaxLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$val unbondDurationHint = resourceManager.getString(R.string.parachain_staking_unbonding_period_template, roundsPart, chain.name, timePart)</ID>
    <ID>MaxLineLength:StakingParachainScenarioRepository.kt$StakingParachainScenarioRepository$runtime.metadata.parachainStakingOrNull()?.storage("DelegationScheduledRequests")?.storageKey(runtime, collatorId)</ID>
    <ID>MaxLineLength:StakingParachainScenarioViewModel.kt$StakingParachainScenarioViewModel$AlertModel.Type.CallToAction { baseViewModel.openStakingBalance(this.delegation.collatorId.toHexString(true)) }</ID>
    <ID>MaxLineLength:StakingParachainScenarioViewModel.kt$StakingParachainScenarioViewModel$override suspend</ID>
    <ID>MaxLineLength:StakingParachainScenarioViewModel.kt$StakingParachainScenarioViewModel$private suspend</ID>
    <ID>MaxLineLength:StakingParachainScenarioViewModel.kt$StakingParachainScenarioViewModel$resourceManager.getQuantityString(R.plurals.common_hours_format, networkInfo.lockupPeriodInHours, networkInfo.lockupPeriodInHours)</ID>
    <ID>MaxLineLength:StakingParachainScenarioViewModel.kt$StakingParachainScenarioViewModel$scenarioInteractor.stakingStateFlow().shareIn(baseViewModel.stakingStateScope, SharingStarted.Eagerly, replay = 1)</ID>
    <ID>MaxLineLength:StakingParachainScenarioViewModel.kt$StakingParachainScenarioViewModel$val amountToStakeMore = (token.amountFromPlanks(amountToStakeMoreInPlanks) * BigDecimal(1.1)).formatCryptoDetail(token.configuration.symbol)</ID>
    <ID>MaxLineLength:StakingPoolApi.kt$StakingPoolApi$createPoolStateToggler(amountInPlanks, rootMultiAddress, nominatorMultiAddress, stateTogglerMultiAddress)</ID>
    <ID>MaxLineLength:StakingPoolInteractor.kt$StakingPoolInteractor$private</ID>
    <ID>MaxLineLength:StakingPoolInteractor.kt$StakingPoolInteractor$return currentRewardCounter.subtract(rewardPool.lastRecordedRewardCounter).multiply(poolMember.points).divide(rewardCounterBase)</ID>
    <ID>MaxLineLength:StakingPoolInteractor.kt$StakingPoolInteractor$suspend fun estimateJoinFee(amount: BigInteger, poolId: BigInteger = BigInteger.ZERO)</ID>
    <ID>MaxLineLength:StakingPoolInteractor.kt$StakingPoolInteractor$suspend fun joinPool(address: String, amount: BigInteger, poolId: BigInteger)</ID>
    <ID>MaxLineLength:StakingPoolInteractor.kt$StakingPoolInteractor$val currentRewardCounter = payoutSinceLastRecord.multiply(rewardCounterBase).divide(bondedPool.points).add(rewardPool.lastRecordedRewardCounter)</ID>
    <ID>MaxLineLength:StakingPoolInteractor.kt$StakingPoolInteractor$val payoutSinceLastRecord = rewardsAccountBalance.add(rewardPool.totalRewardsClaimed).subtract(rewardPool.lastRecordedTotalPayouts)</ID>
    <ID>MaxLineLength:StakingPoolInteractor.kt$StakingPoolInteractor$val rewardsAccountBalance = stakingInteractor.getAccountBalance(chain.id, rewardsAccountId).data.free.subtract(existentialDeposit)</ID>
    <ID>MaxLineLength:StakingPoolViewModel.kt$StakingPoolViewModel$override suspend</ID>
    <ID>MaxLineLength:StakingPoolViewModel.kt$StakingPoolViewModel$private</ID>
    <ID>MaxLineLength:StakingPoolViewModel.kt$StakingPoolViewModel$private val currentAssetFlow = stakingInteractor.currentAssetFlow().filter { it.token.configuration.supportStakingPool }</ID>
    <ID>MaxLineLength:StakingPoolViewModel.kt$StakingPoolViewModel$return</ID>
    <ID>MaxLineLength:StakingPoolViewModel.kt$StakingPoolViewModel$returns.monthly.gain.nullIfEmpty()?.let { TitleValueViewState(it, returns.monthly.amount.nullIfEmpty(), returns.monthly.fiatAmount) }</ID>
    <ID>MaxLineLength:StakingPoolViewModel.kt$StakingPoolViewModel$returns.yearly.gain.nullIfEmpty()?.let { TitleValueViewState(it, returns.yearly.amount.nullIfEmpty(), returns.yearly.fiatAmount) }</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$isNominationActive(nominatorState.stashId, it.eraStakers.values, it.rewardedNominatorsPerValidator) -&gt; NominatorStatus.Active</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$override</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$override fun rebond(extrinsicBuilder: ExtrinsicBuilder, amount: BigInteger, candidate: String?)</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$override suspend</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$override suspend fun checkEnoughToRebondValidation(payload: RebondValidationPayload)</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$override suspend fun checkEnoughToUnbondValidation(payload: UnbondValidationPayload)</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$override suspend fun getRebondingUnbondings(collatorAddress: String?): List&lt;Unbonding&gt;</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$return</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$return stakingConstantsRepository.lockupPeriodInEras(chainId).toInt() * stakingRelayChainScenarioRepository.hoursInEra(chainId)</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$timeLeft = getCalculator(chainId).calculate(nominatorState.nominations.submittedInEra + ERA_OFFSET).toLong()</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$val</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$val controllerAsset = walletRepository.getAsset(meta.id, controllerId, it.asset.token.configuration, null)</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$val exposures = stakingRelayChainScenarioRepository.electedExposuresInActiveEra(chainAsset.chainId).firstOrNull()?.values ?: emptyList()</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$val identityMapping = identityRepository.getIdentitiesFromAddresses(currentStakingState.chain, allValidatorAddresses)</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$val leftTime = calculator.calculateTillEraSet(destinationEra = it.era + historyDepth + ERA_OFFSET).toLong()</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$val meta = accountRepository.findMetaAccount(controllerId) ?: return@ControllerCanPayFeeValidation BigDecimal.ZERO</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$val minBond = stashState.chain.utilityAsset?.let { stakingRelayChainScenarioRepository.minimumNominatorBond(it) }.orZero()</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$val minimumNominatorBond = chain.utilityAsset?.let { stakingRelayChainScenarioRepository.minimumNominatorBond(it) }.orZero()</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$val rewardedNominatorsPerValidator = stakingConstantsRepository.maxRewardedNominatorPerValidator(state.chain.id)</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$val statusResolutionContext = StatusResolutionContext(eraStakers, activeEraIndex, asset, rewardedNominatorsPerValidator)</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioRepository.kt$StakingRelayChainScenarioRepository$binding = { scale, runtime -&gt; bindRewardDestination(scale, runtime, stakingState.stashId, stakingState.controllerId) }</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioRepository.kt$StakingRelayChainScenarioRepository$nominations != null -&gt; StakingState.Stash.Nominator(chain, accountId, controllerId, stashId, nominations)</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioRepository.kt$StakingRelayChainScenarioRepository$prefixKeyBuilder = { it.metadata.moduleOrNull(Modules.STAKING)?.storage("ErasStakers")?.storageKey(it, eraIndex) }</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioRepository.kt$StakingRelayChainScenarioRepository$private suspend</ID>
    <ID>MaxLineLength:StakingRelayChainScenarioRepository.kt$StakingRelayChainScenarioRepository$suspend</ID>
    <ID>MaxLineLength:StakingRelaychainScenarioViewModel.kt$StakingRelaychainScenarioViewModel$override suspend</ID>
    <ID>MaxLineLength:StakingRelaychainScenarioViewModel.kt$StakingRelaychainScenarioViewModel$resourceManager.getQuantityString(R.plurals.common_hours_format, networkInfo.lockupPeriodInHours, networkInfo.lockupPeriodInHours)</ID>
    <ID>MaxLineLength:StakingScenarioInteractor.kt$StakingScenarioInteractor$suspend fun stakeMore(extrinsicBuilder: ExtrinsicBuilder, amountInPlanks: BigInteger, candidate: String? = null): ExtrinsicBuilder</ID>
    <ID>MaxLineLength:StakingScenarioViewModel.kt$StakingScenarioViewModel$suspend fun getBondMoreValidationSystem(): ValidationSystem&lt;ManageStakingValidationPayload, ManageStakingValidationFailure&gt;</ID>
    <ID>MaxLineLength:StakingScenarioViewModel.kt$StakingScenarioViewModel$suspend fun getRedeemValidationSystem(): ValidationSystem&lt;ManageStakingValidationPayload, ManageStakingValidationFailure&gt;</ID>
    <ID>MaxLineLength:StakingSharedState.kt$StakingSharedState$it.token.configuration.id in availableChainAssets.values &amp;&amp; it.token.configuration.chainId in availableChainAssets.keys</ID>
    <ID>MaxLineLength:StakingValidationFailure.kt$getString(R.string.common_amount_low) to getString(R.string.staking_setup_amount_too_low, formattedThreshold)</ID>
    <ID>MaxLineLength:StakingValidationFailure.kt$getString(R.string.staking_max_nominators_reached_title) to getString(R.string.staking_max_nominators_reached_message)</ID>
    <ID>MaxLineLength:StakingViewModel.kt$StakingViewModel$inline fun &lt;reified T : StakingAssetInfoViewState&gt; Map&lt;StakingType, StakingAssetInfoViewState&gt;.get(type: StakingType): T</ID>
    <ID>MaxLineLength:StakingViewModel.kt$StakingViewModel$is StakingNetworkInfoModel.Parachain -&gt; defaultNetworkInfoStates.get&lt;StakingAssetInfoViewState.Parachain&gt;(StakingType.PARACHAIN).update(state)</ID>
    <ID>MaxLineLength:StakingViewModel.kt$StakingViewModel$is StakingNetworkInfoModel.Pool -&gt; defaultNetworkInfoStates.get&lt;StakingAssetInfoViewState.StakingPool&gt;(StakingType.POOL).update(state)</ID>
    <ID>MaxLineLength:StakingViewModel.kt$StakingViewModel$is StakingNetworkInfoModel.RelayChain</ID>
    <ID>MaxLineLength:StakingViewModel.kt$StakingViewModel$setupStakingSharedState.set(SetupStakingProcess.SelectBlockProducersStep.Validators(SetupStakingProcess.SelectBlockProducersStep.Payload.ExistingStash))</ID>
    <ID>MaxLineLength:StakingViewModel.kt$StakingViewModel$val bondMorePayload = SelectBondMorePayload(overrideFinishAction = StakingRouter::returnToMain, collatorAddress = null)</ID>
    <ID>MaxLineLength:StakingViewModel.kt$StakingViewModel$val showRewardEstimationEvent: LiveData&lt;Event&lt;StakingRewardEstimationBottomSheet.Payload&gt;&gt; = _showRewardEstimationEvent</ID>
    <ID>MaxLineLength:StakingViewModel.kt$StakingViewModel$}</ID>
    <ID>MaxLineLength:StakingViewStateFactory.kt$StakingViewStateFactory$SyntheticStakingType.SORA -&gt; createSoraWelcomeViewState(currentAssetFlow, scope, welcomeStakingValidationSystem, errorDisplayer)</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$DelegatorViewState$status = candidateInfo.toModelStatus(millisecondsTillTheEndOfRound, millisecondsTillCandidateWillLeave, isReadyToUnlock)</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$DelegatorViewState$val</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$DelegatorViewState$val currentRound = parachainScenarioInteractor.getCurrentRound(chainId).getOrNull() ?: return@mapNotNull null</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$DelegatorViewState$val leaveCandidatesDelayInRounds = parachainScenarioInteractor.getLeaveCandidatesDelay().getOrNull() ?: return@mapNotNull null</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$DelegatorViewState$val readyToUnlockCollatorIds = parachainScenarioInteractor.getCollatorIdsWithReadyToUnlockingTokens(collatorsIds, delegatorState.accountId)</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$DelegatorViewState$val roundWhenCandidateWillLeave = (candidateInfo.status as? CandidateInfoStatus.LEAVING)?.leavingBlock?.let { it + leaveCandidatesDelayInRounds }</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$R.string.staking_nominator_status_alert_inactive_title to R.string.staking_nominator_status_alert_low_stake</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$R.string.staking_nominator_status_alert_inactive_title to R.string.staking_nominator_status_alert_no_validators</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$Reason.MIN_STAKE -&gt; R.string.staking_nominator_status_alert_inactive_title to R.string.staking_nominator_status_alert_low_stake</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$Reason.NO_ACTIVE_VALIDATOR -&gt; R.string.staking_nominator_status_alert_inactive_title to R.string.staking_nominator_status_alert_no_validators</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$RelaychainWelcomeViewState$override val rewardCalculator = scope.async { rewardCalculatorFactory.create(currentAssetFlow.first().token.configuration) }</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$RelaychainWelcomeViewState$val chainId = currentAssetFlow.filter { it.token.configuration.staking == CoreAsset.StakingType.RELAYCHAIN }.map { it.token.configuration.chainId }</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$SoraNominatorViewState$)</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$SoraNominatorViewState$.</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$SoraNominatorViewState$override suspend</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$StakeViewState$availableManageActionsFlow.value = initialManageActions.toMutableSet().apply { add(ManageStakeAction.PAYOUTS) }</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$StakeViewState$availableManageActionsFlow.value = initialManageActions.toMutableSet().apply { remove(ManageStakeAction.PAYOUTS) }</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$StakeViewState$val supportedValidatorsLoadingBlockExplorerTypes = setOf(Chain.ExternalApi.Section.Type.SUBQUERY, Chain.ExternalApi.Section.Type.SUBSQUID)</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$StakingPoolWelcomeViewState$override val rewardCalculator = scope.async { rewardCalculatorFactory.create(currentAssetFlow.first().token.configuration) }</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$StakingPoolWelcomeViewState$val chainId = currentAssetFlow.filter { it.token.configuration.staking == CoreAsset.StakingType.RELAYCHAIN }.map { it.token.configuration.chainId }</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$StashNoneStatus.INACTIVE -&gt; R.string.staking_nominator_status_alert_inactive_title to R.string.staking_bonded_inactive</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$StashNoneViewState$summaryFlowProvider = { relayChainScenarioInteractor.observeStashSummary(stashState).shareIn(scope, SharingStarted.Eagerly, replay = 1) }</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$ValidatorStatus.ACTIVE -&gt; R.string.staking_nominator_status_alert_active_title to R.string.staking_nominator_status_alert_active_message</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$ValidatorStatus.INACTIVE -&gt; R.string.staking_nominator_status_alert_inactive_title to R.string.staking_nominator_status_alert_no_validators</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$ValidatorViewState$summaryFlowProvider = { relayChainScenarioInteractor.observeValidatorSummary(validatorState).shareIn(scope, SharingStarted.Eagerly, replay = 1) }</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$WelcomeViewState$enteredAmountFlow.mapNotNull { it.toBigDecimalOrNull() ?: BigDecimal.ZERO }.stateIn(scope, SharingStarted.Eagerly, BigDecimal.ZERO)</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$WelcomeViewState$val</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$WelcomeViewState$val showRewardEstimationEvent: LiveData&lt;Event&lt;StakingRewardEstimationBottomSheet.Payload&gt;&gt; = _showRewardEstimationEvent</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$is DelegatorStatus.Active -&gt; R.string.staking_nominator_status_alert_active_title to R.string.staking_nominator_status_alert_active_message</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$is DelegatorStatus.Waiting -&gt; R.string.staking_nominator_status_waiting to R.string.staking_nominator_status_alert_waiting_message</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$is NominatorStatus.Active -&gt; R.string.staking_nominator_status_alert_active_title to R.string.staking_nominator_status_alert_active_message</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$is NominatorStatus.Waiting -&gt; R.string.staking_nominator_status_waiting to R.string.staking_nominator_status_alert_waiting_message</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$status == CandidateInfoStatus.ACTIVE -&gt; DelegatorViewState.CollatorDelegationModel.Status.Active(millisecondsTillTheEndOfRound)</ID>
    <ID>MaxLineLength:StakingViewStateOld.kt$status is CandidateInfoStatus.LEAVING -&gt; DelegatorViewState.CollatorDelegationModel.Status.Leaving(millisecondsTillCandidateWillLeave)</ID>
    <ID>MaxLineLength:StartChangeCollatorsFragment.kt$StartChangeCollatorsFragment$(layoutInflater.inflate(R.layout.item_algorithm_criteria, binding.startChangeCollatorsRecommendedFeatures, false) as? TextView)</ID>
    <ID>MaxLineLength:StartChangeCollatorsFragment.kt$StartChangeCollatorsFragment$class</ID>
    <ID>MaxLineLength:StartChangeCollatorsViewModel.kt$StartChangeCollatorsViewModel$setupStakingProcess is SetupStakingProcess.ReadyToSubmit.Parachain &amp;&amp; setupStakingProcess.payload.blockProducers.isNotEmpty()</ID>
    <ID>MaxLineLength:StartChangeCollatorsViewModel.kt$StartChangeCollatorsViewModel$setupStakingProcess is SetupStakingProcess.ReadyToSubmit&lt;*&gt; &amp;&amp; setupStakingProcess.payload.blockProducers.isNotEmpty()</ID>
    <ID>MaxLineLength:StartChangeCollatorsViewModel.kt$StartChangeCollatorsViewModel$val</ID>
    <ID>MaxLineLength:StartChangeValidatorsFragment.kt$StartChangeValidatorsFragment$(layoutInflater.inflate(R.layout.item_algorithm_criteria, binding.startChangeValidatorsRecommendedFeatures, false) as? TextView)</ID>
    <ID>MaxLineLength:StartChangeValidatorsFragment.kt$StartChangeValidatorsFragment$class</ID>
    <ID>MaxLineLength:StartSelectValidatorsScreen.kt$additionalInfo = listOf("Most profitable", "Not oversubscribed", "Having onchain identity", "Not slashed", "Limit of 2 validators per identity")</ID>
    <ID>MaxLineLength:StartSelectValidatorsScreen.kt$description</ID>
    <ID>MaxLineLength:StartSelectValidatorsViewModel.kt$StartSelectValidatorsViewModel$}</ID>
    <ID>MaxLineLength:StartStakingPoolScreen.kt$SingleValueInfoCard(R.drawable.ic_gift, R.string.staking_pool_start_reward_freq_text, state.rewardsPayoutDelay)</ID>
    <ID>MaxLineLength:StartStakingPoolScreen.kt$SingleValueInfoCard(R.drawable.ic_money, R.string.staking_pool_start_apr_text, state.yearlyEstimatedEarnings)</ID>
    <ID>MaxLineLength:StartStakingPoolScreen.kt$SingleValueInfoCard(R.drawable.ic_withdrawal, R.string.staking_pool_start_unstake_period_text, state.unstakingPeriod)</ID>
    <ID>MaxLineLength:StartStakingPoolViewModel.kt$StartStakingPoolViewModel$val</ID>
    <ID>MaxLineLength:StorageDao.kt$private const val SELECT_PREFIX_KEY_QUERY = "SELECT * from storage WHERE chainId = :chainId AND storageKey LIKE :keyPrefix || '%'"</ID>
    <ID>MaxLineLength:SubQueryDelegationHistoryFetcher.kt$SubQueryDelegationHistoryFetcher$suspend</ID>
    <ID>MaxLineLength:SubqueryRewardCalculator.kt$SubqueryRewardCalculator$kotlin.runCatching { stakingApi.getLastRoundId(stakingUrl, StakingLastRoundIdRequest()).data.rounds.nodes.firstOrNull()?.id?.toIntOrNull() }</ID>
    <ID>MaxLineLength:SubqueryRewardCalculator.kt$SubqueryRewardCalculator$override suspend</ID>
    <ID>MaxLineLength:SubqueryRewardCalculator.kt$SubqueryRewardCalculator$private suspend</ID>
    <ID>MaxLineLength:SubqueryRewardCalculator.kt$SubqueryRewardCalculator$stakingApi.getLastRoundId(stakingUrl, StakingLastRoundIdRequest()).data.rounds.nodes.firstOrNull()?.id?.toIntOrNull()</ID>
    <ID>MaxLineLength:SubqueryStakingRewardsDataSource.kt$SubqueryStakingRewardsDataSource$val rewards = stakingApi.getRelayRewardAmounts(stakingUrl, GiantsquidRewardAmountRequest(accountAddress.toAccountId().toHexString(true)))</ID>
    <ID>MaxLineLength:SuccessViewModel.kt$SuccessViewModel$clickState = TitleValueViewState.ClickState.Value(R.drawable.ic_copy_filled_24, SuccessViewState.CODE_HASH_CLICK)</ID>
    <ID>MaxLineLength:SwapDetailContent.kt$clickState = TitleValueViewState.ClickState.Value(R.drawable.ic_copy_16, SwapDetailViewModel.CODE_HASH_CLICK)</ID>
    <ID>MaxLineLength:SwapDetailViewModel.kt$SwapDetailViewModel$private val swap = savedStateHandle.get&lt;OperationParcelizeModel.Swap&gt;(SwapDetailFragment.KEY_SWAP) ?: error("Swap detail not specified")</ID>
    <ID>MaxLineLength:SwapDetailViewModel.kt$SwapDetailViewModel$swap.targetAsset?.amountFromPlanks(swap.targetAssetAmount.orZero()).orZero().divide(swap.chainAsset.amountFromPlanks(swap.baseAssetAmount))</ID>
    <ID>MaxLineLength:SwapDetailsViewState.kt$details.feeAsset.token.fiatAmount(details.liquidityProviderFee)?.formatFiat(details.feeAsset.token.fiatSymbol)</ID>
    <ID>MaxLineLength:SwapDetailsViewState.kt$fromTokenImage = GradientIconState.Remote(fromAsset.token.configuration.iconUrl, fromAsset.token.configuration.color)</ID>
    <ID>MaxLineLength:SwapPreviewFragment.kt$SwapPreviewFragment.Companion$fun</ID>
    <ID>MaxLineLength:SwapPreviewViewModel.kt$SwapPreviewViewModel$MutableStateFlow(SwapPreviewState(swapDetailsViewState = swapDetailsViewState, networkFee = swapDetailsParcelModel.networkFee, isLoading = false))</ID>
    <ID>MaxLineLength:SwapPreviewViewModel.kt$SwapPreviewViewModel$private val swapDetailsParcelModel = savedStateHandle.get&lt;SwapDetailsParcelModel&gt;(SwapPreviewFragment.KEY_SWAP_DETAILS_PARCEL)!!</ID>
    <ID>MaxLineLength:SwapPreviewViewModel.kt$SwapPreviewViewModel$private val swapDetailsViewState = savedStateHandle.get&lt;SwapDetailsViewState&gt;(SwapPreviewFragment.KEY_SWAP_DETAILS)!!</ID>
    <ID>MaxLineLength:SwapPreviewViewModel.kt$SwapPreviewViewModel$val markets = if (swapDetailsParcelModel.selectedMarket == Market.SMART) emptyList() else listOf(swapDetailsParcelModel.selectedMarket)</ID>
    <ID>MaxLineLength:SwapTokensContent.kt$SwapTokensContentViewState.Companion$fromAmountInputViewState = AmountInputViewState.default(resourceManager, R.string.common_available_format)</ID>
    <ID>MaxLineLength:SwapTokensContent.kt$val isFromFocused = state.fromAmountInputViewState.isFocused &amp;&amp; !state.fromAmountInputViewState.tokenName.isNullOrEmpty()</ID>
    <ID>MaxLineLength:SwapTokensViewModel.kt$SwapTokensViewModel$_showTooltipEvent.value = Event(resourceManager.getString(tooltip.first) to resourceManager.getString(tooltip.second))</ID>
    <ID>MaxLineLength:SwapTokensViewModel.kt$SwapTokensViewModel$combine</ID>
    <ID>MaxLineLength:SwapTokensViewModel.kt$SwapTokensViewModel$combine(swapDetails, networkFeeFlow) { details, networkFee -&gt; details to networkFee }</ID>
    <ID>MaxLineLength:SwapTokensViewModel.kt$SwapTokensViewModel$detailsToViewState(resourceManager, amountInput.value, fromAsset, toAsset, details, desired ?: return@map null)</ID>
    <ID>MaxLineLength:SwapTokensViewModel.kt$SwapTokensViewModel$private val dexes = flowOf { polkaswapInteractor.getAvailableDexes() }.stateIn(viewModelScope, SharingStarted.Eagerly, listOf())</ID>
    <ID>MaxLineLength:SwapTokensViewModel.kt$SwapTokensViewModel$private val fromAmountInputViewState = MutableStateFlow(AmountInputViewState.default(resourceManager, R.string.common_available_format))</ID>
    <ID>MaxLineLength:SwapTokensViewModel.kt$SwapTokensViewModel$return polkaswapInteractor.calcDetails(availableDexPaths, fromAsset.value!!, toAsset.value!!, amount, desired!!, slippageTolerance, selectedMarket)</ID>
    <ID>MaxLineLength:SwapTokensViewModel.kt$SwapTokensViewModel$transactionSettingsJob</ID>
    <ID>MaxLineLength:SwapTokensViewModel.kt$SwapTokensViewModel$val fromCurrencyId = fromAsset.token.configuration.currencyId ?: return@transform emit(LoadingState.Loaded(null))</ID>
    <ID>MaxLineLength:SwapTokensViewModel.kt$SwapTokensViewModel$val isFeeAsset = fromAsset.value?.token?.configuration?.id == polkaswapInteractor.getFeeAsset()?.token?.configuration?.id</ID>
    <ID>MaxLineLength:SwapTokensViewModel.kt$SwapTokensViewModel$val newResult = amount.minus(newNetworkFee).minus(newDetails.liquidityProviderFee).takeIf { it &gt;= BigDecimal.ZERO }.orZero()</ID>
    <ID>MaxLineLength:SwipeBox.kt$assetIconUrl = "https://raw.githubusercontent.com/soramitsu/fearless-utils/master/icons/chains/white/Polkadot.svg"</ID>
    <ID>MaxLineLength:SwipeableAssetListItem.kt$actionItemClicked: (actionType: ActionItemType, chainId: ChainId, chainAssetId: String, swipeableState: SwipeableState&lt;SwipeState&gt;) -&gt; Unit</ID>
    <ID>MaxLineLength:TernoaRewardCalculator.kt$TernoaRewardCalculator$override suspend</ID>
    <ID>MaxLineLength:TextFieldHint.kt$keyboardOptions = KeyboardOptions(autoCorrect = false, keyboardType = KeyboardType.Text, imeAction = ImeAction.None)</ID>
    <ID>MaxLineLength:TextFieldHint.kt$textStyle = MaterialTheme.customTypography.body1.copy(textAlign = TextAlign.Start, background = Color.Unspecified)</ID>
    <ID>MaxLineLength:TitleValue.kt$private</ID>
    <ID>MaxLineLength:TitleValue.kt$state?.let { TitleToValue(state = it, titleColor = green, modifier = modifier, testTag = testTag) } ?: TitleToValueShimmer(modifier)</ID>
    <ID>MaxLineLength:TokenRepositoryImpl.kt$TokenRepositoryImpl$val tokenPriceLocal = chainAsset.priceId?.let { tokenPriceDao.getTokenPrice(it) ?: TokenPriceLocal.createEmpty(it) }</ID>
    <ID>MaxLineLength:Toolbar.kt$Toolbar$val backgroundAttrDrawable = typedArray.getDrawable(R.styleable.Toolbar_contentBackground) ?: ColorDrawable(context.getColor(R.color.black))</ID>
    <ID>MaxLineLength:TotalBalanceUseCase.kt$TotalBalanceUseCase$*</ID>
    <ID>MaxLineLength:TotalBalanceUseCaseImpl.kt$TotalBalanceUseCaseImpl$val balanceChangeToAdd = fiatAmount?.multiply(current.token?.recentRateChange.orZero())?.percentageToFraction().orZero()</ID>
    <ID>MaxLineLength:TransactionDetailViewModel.kt$TransactionDetailViewModel$private suspend fun getIcon(address: String)</ID>
    <ID>MaxLineLength:TransactionDetailViewModel.kt$TransactionDetailViewModel$val retryAddressModelLiveData = if (operation.isIncome) senderAddressModelLiveData else recipientAddressModelLiveData</ID>
    <ID>MaxLineLength:TransactionHistoryFilterFragment.kt$TransactionHistoryFilterFragment$class</ID>
    <ID>MaxLineLength:TransactionHistoryProvider.kt$TransactionHistoryProvider$_sideEffects.emit(TransactionHistoryUi.SideEffect.Error(throwable.localizedMessage ?: throwable.localizedMessage))</ID>
    <ID>MaxLineLength:TransactionHistoryProvider.kt$TransactionHistoryProvider$is HistoryNotSupportedException -&gt; resourceManager.getString(R.string.wallet_transaction_history_unsupported_message)</ID>
    <ID>MaxLineLength:TransactionItem.kt$createHorizontalChain(image, imageSpacer, header, amount, statusSpacer, status, chainStyle = ChainStyle.SpreadInside)</ID>
    <ID>MaxLineLength:TransactionSettingsViewModel.kt$TransactionSettingsViewModel$number &lt;= MinWarningSlippageThreshold -&gt; resourceManager.getString(R.string.polkaswap_transaction_may_fail)</ID>
    <ID>MaxLineLength:TransactionSettingsViewModel.kt$TransactionSettingsViewModel$number &gt;= MaxWarningSlippageThreshold -&gt; resourceManager.getString(R.string.polkaswap_transaction_may_frontrun)</ID>
    <ID>MaxLineLength:TransactionSettingsViewModel.kt$TransactionSettingsViewModel$private val initialSettings = savedStateHandle.get&lt;TransactionSettingsModel&gt;(TransactionSettingsFragment.SETTINGS_MODEL_KEY)</ID>
    <ID>MaxLineLength:TransactionSettingsViewModel.kt$TransactionSettingsViewModel$private val slippageToleranceStringValue = MutableStateFlow(formatOrNull(initialSettings?.slippageTolerance) ?: DefaultSlippageTolerance)</ID>
    <ID>MaxLineLength:TransactionSettingsViewModel.kt$TransactionSettingsViewModel$slippageInputState = getSlippageTolerance(slippageToleranceValue, isSlippageInputFocused, slippageWarningText)</ID>
    <ID>MaxLineLength:Transfer.kt$Transfer$!isUtilityToken &amp;&amp; (senderUtilityBalance - extraSpends &lt; utilityExistentialDeposit) -&gt; TransferValidityLevel.Warning.Status.WillRemoveAccount</ID>
    <ID>MaxLineLength:Transfer.kt$Transfer$senderTotal - transactionTotal &lt; existentialDeposit -&gt; TransferValidityLevel.Warning.Status.WillRemoveAccount</ID>
    <ID>MaxLineLength:TransferCursorStorage.kt$TransferCursorStorage$private fun cursorKey(chainId: String, chainAssetId: String, accountId: AccountId)</ID>
    <ID>MaxLineLength:TransferValidityChecks.kt$TransferValidityLevel.Error.Status.DeadRecipient -&gt; R.string.common_amount_low to R.string.wallet_send_dead_recipient_message</ID>
    <ID>MaxLineLength:TransferValidityChecks.kt$TransferValidityLevel.Error.Status.NotEnoughFunds -&gt; R.string.common_error_general_title to R.string.choose_amount_error_too_big</ID>
    <ID>MaxLineLength:TransferValidityChecks.kt$errorDialog(context, childFragmentManager, context.resources.getString(titleRes), context.resources.getString(messageRes), errorConfirmed)</ID>
    <ID>MaxLineLength:UnbondingModel.kt$UnbondingModel$val calculatedAt: Long</ID>
    <ID>MaxLineLength:UnbondingsAdapter.kt$UnbondingsHolder$findViewById&lt;TextView&gt;(R.id.itemListElementTitleLeft).text = unbonding.amountModel.titleResId?.let { context.getString(it) }</ID>
    <ID>MaxLineLength:UpdatesProvider.kt$UpdatesProvider$// update chain here too - assume chain updated if we got balance; need logic research: somehow not applied in finishChainSyncUp</ID>
    <ID>MaxLineLength:V2Migration.kt$V2Migration$*</ID>
    <ID>MaxLineLength:V2Migration.kt$V2Migration$val ethereumSeed = EthereumSeedFactory.deriveSeed32(it.words, password = decodedEthereumDerivationPath.password).seed</ID>
    <ID>MaxLineLength:V2Migration.kt$V2Migration$val secrets = storeV1.getSecuritySource(account.address) ?: return@forEachIndexed // Possible RO account, ignore such accounts</ID>
    <ID>MaxLineLength:V2MigrationTest.kt$V2MigrationTest$val metaAccount = db.getMetaAccounts().firstOrNull() ?: error("There should be at least one account after migration")</ID>
    <ID>MaxLineLength:V2MigrationTest.kt$private val SUBSTRATE_KEYPAIR = SubstrateKeypairFactory.generate(CRYPTO_TYPE, seed = SUBSTRATE_SEED, junctions = emptyList())</ID>
    <ID>MaxLineLength:ValidateTransferUseCase.kt$fun</ID>
    <ID>MaxLineLength:ValidateTransferUseCaseImpl.kt$ValidateTransferUseCaseImpl$TransferValidationResult.DeadRecipient to (totalRecipientBalanceInPlanks + amountInPlanks &lt; assetExistentialDeposit)</ID>
    <ID>MaxLineLength:ValidateTransferUseCaseImpl.kt$ValidateTransferUseCaseImpl$TransferValidationResult.DeadRecipient to (totalRecipientBalanceInPlanks + amountInPlanks &lt; destinationExistentialDeposit)</ID>
    <ID>MaxLineLength:ValidateTransferUseCaseImpl.kt$ValidateTransferUseCaseImpl$TransferValidationResult.ExistentialDepositWarning to (transferable - amountInPlanks &lt; assetExistentialDeposit)</ID>
    <ID>MaxLineLength:ValidateTransferUseCaseImpl.kt$ValidateTransferUseCaseImpl$TransferValidationResult.TransferToTheSameAddress to (!transferMyselfAvailable &amp;&amp; recipientAddress == ownAddress)</ID>
    <ID>MaxLineLength:ValidateTransferUseCaseImpl.kt$ValidateTransferUseCaseImpl$TransferValidationResult.UtilityExistentialDepositWarning to (utilityAssetBalance - (fee + tip) &lt; utilityAssetExistentialDeposit)</ID>
    <ID>MaxLineLength:ValidateTransferUseCaseImpl.kt$ValidateTransferUseCaseImpl$getEquilibriumValidationChecks(asset, recipientAccountId, originChain, ownAddress, amountInPlanks, fee, tip)</ID>
    <ID>MaxLineLength:ValidateTransferUseCaseImpl.kt$ValidateTransferUseCaseImpl$if (amount &lt; amountInPlanks + fee + tip) return mapOf(TransferValidationResult.InsufficientBalance to true)</ID>
    <ID>MaxLineLength:ValidateTransferUseCaseImpl.kt$ValidateTransferUseCaseImpl$if (amount &lt; fee + tip) return mapOf(TransferValidationResult.InsufficientUtilityAssetBalance to true)</ID>
    <ID>MaxLineLength:ValidateTransferUseCaseImpl.kt$ValidateTransferUseCaseImpl$val totalRecipientBalanceInPlanks = destinationAsset?.let { substrateSource.getTotalBalance(it, recipientAccountId) }.orZero()</ID>
    <ID>MaxLineLength:ValidateTransferUseCaseImpl.kt$ValidateTransferUseCaseImpl$val utilityAssetExistentialDeposit = originChain.utilityAsset?.let { existentialDepositUseCase(it) }.orZero()</ID>
    <ID>MaxLineLength:ValidationSystems.kt$typealias ManageStakingValidationSystem = ValidationSystem&lt;ManageStakingValidationPayload, ManageStakingValidationFailure&gt;</ID>
    <ID>MaxLineLength:Validator.kt$)</ID>
    <ID>MaxLineLength:ValidatorDetailsFragment.kt$ValidatorDetailsFragment$class</ID>
    <ID>MaxLineLength:ValidatorDetailsFragment.kt$ValidatorDetailsFragment$validatorInfo.setNominatorsCount(activeStakeModel.nominatorsCount, activeStakeModel.maxNominations)</ID>
    <ID>MaxLineLength:ValidatorDetailsViewModel.kt$ValidatorDetailsViewModel$mapValidatorDetailsParcelToValidatorDetailsModel(chain, validator, asset, maxNominators, iconGenerator, resourceManager)</ID>
    <ID>MaxLineLength:ValidatorDetailsViewModel.kt$ValidatorDetailsViewModel$private suspend</ID>
    <ID>MaxLineLength:ValidatorInfoView.kt$Error$OversubscribedPaid : Error</ID>
    <ID>MaxLineLength:ValidatorInfoView.kt$Error$OversubscribedUnpaid : Error</ID>
    <ID>MaxLineLength:ValidatorInfoView.kt$ValidatorInfoView$is Error.OversubscribedPaid -&gt; binding.validatorStatusView.setDescription(context.getString(err.errorDescription), err.errorIcon)</ID>
    <ID>MaxLineLength:ValidatorInfoView.kt$ValidatorInfoView$is Error.OversubscribedUnpaid -&gt; binding.validatorStatusView.setDescription(context.getString(err.errorDescription), err.errorIcon)</ID>
    <ID>MaxLineLength:ValidatorInfoView.kt$ValidatorInfoView$is Error.Slashed -&gt; binding.validatorNominatorsView.setDescription(context.getString(err.errorDescription), err.errorIcon)</ID>
    <ID>MaxLineLength:ValidatorProvider.kt$ValidatorProvider$rewardCalculatorFactory.createSoraWithCustomValidatorsSettings(electedValidatorExposures, validatorPrefs, utilityAsset)</ID>
    <ID>MaxLineLength:ValidatorProvider.kt$ValidatorProvider$rewardCalculatorFactory.createTernoaWithCustomValidatorsSettings(electedValidatorExposures, validatorPrefs, utilityAsset)</ID>
    <ID>MaxLineLength:ValidatorProvider.kt$ValidatorProvider$val electedValidatorExposures = cachedExposures ?: stakingRepository.getActiveElectedValidatorsExposures(chainId)</ID>
    <ID>MaxLineLength:ValidatorProvider.kt$ValidatorProvider$val utilityAsset = chain.utilityAsset ?: error("Utility asset not specified for chain ${chain.name} - ${chain.id}")</ID>
    <ID>MaxLineLength:ValidatorRecommendator.kt$ValidatorRecommendator$override suspend</ID>
    <ID>MaxLineLength:ValidatorRecommendatorFactory.kt$ValidatorRecommendatorFactory$private suspend</ID>
    <ID>MaxLineLength:ValidatorsAdapter.kt$ValidatorDiffCallback$return oldItem.scoring == newItem.scoring &amp;&amp; oldItem.title == newItem.title &amp;&amp; oldItem.isChecked == newItem.isChecked</ID>
    <ID>MaxLineLength:ValidatorsSettingsViewModel.kt$ValidatorsSettingsViewModel$private fun SettingsSchema.Filter.toViewState()</ID>
    <ID>MaxLineLength:ValidatorsSettingsViewModel.kt$ValidatorsSettingsViewModel$private fun SettingsSchema.Sorting.toViewState()</ID>
    <ID>MaxLineLength:ViewExt.kt$val heightInPx = if (heightInDp != null) (resources.displayMetrics.density * heightInDp).toInt() else drawable.intrinsicHeight</ID>
    <ID>MaxLineLength:ViewExt.kt$val widthInPx = if (widthInDp != null) (resources.displayMetrics.density * widthInDp).toInt() else drawable.intrinsicWidth</ID>
    <ID>MaxLineLength:WalletExportViewModel.kt$WalletExportViewModel$amountsWithOneKeyAmountBadgeLiveData.postValue(resourceManager.getQuantityString(R.plurals.plus_others_template, it, it))</ID>
    <ID>MaxLineLength:WalletExportViewModel.kt$WalletExportViewModel$val icon = iconGenerator.createAddressIcon(metaAccount().substrateAccountId, AddressIconGenerator.SIZE_MEDIUM)</ID>
    <ID>MaxLineLength:WalletFeatureModule.kt$WalletFeatureModule$MoonPayProvider(host = BuildConfig.MOONPAY_HOST, publicKey = BuildConfig.MOONPAY_PUBLIC_KEY, privateKey = BuildConfig.MOONPAY_PRIVATE_KEY)</ID>
    <ID>MaxLineLength:WalletInteractorImpl.kt$WalletInteractorImpl$chainRegistry.getRuntime(it).metadata.module(Modules.STAKING).calls?.get("set_controller")?.arguments?.isEmpty() == true</ID>
    <ID>MaxLineLength:WalletInteractorImpl.kt$WalletInteractorImpl$historyRepository.operationsFirstPageFlow(accountId, chain, chainAsset).withIndex()</ID>
    <ID>MaxLineLength:WalletInteractorImpl.kt$WalletInteractorImpl$override suspend</ID>
    <ID>MaxLineLength:WalletInteractorImpl.kt$WalletInteractorImpl$override suspend fun getChainAddressForSelectedMetaAccount(chainId: ChainId)</ID>
    <ID>MaxLineLength:WalletInteractorImpl.kt$WalletInteractorImpl$private</ID>
    <ID>MaxLineLength:WalletInteractorImpl.kt$WalletInteractorImpl$return walletRepository.getAsset(metaAccount.id, metaAccount.accountId(chain)!!, chainAsset, chain.minSupportedVersion)!!</ID>
    <ID>MaxLineLength:WalletInteractorImpl.kt$WalletInteractorImpl$val currentAccountHasAnotherController = controllerAccount != null &amp;&amp; !controllerAccount.contentEquals(accountId) // user needs to fix it</ID>
    <ID>MaxLineLength:WalletInteractorImpl.kt$WalletInteractorImpl$val currentAccountIsStashAndController = controllerAccount != null &amp;&amp; controllerAccount.contentEquals(accountId) // the case is resolved</ID>
    <ID>MaxLineLength:WalletRepository.kt$WalletRepository$suspend fun getAsset(metaId: Long, accountId: AccountId, chainAsset: CoreAsset, minSupportedVersion: String?): Asset?</ID>
    <ID>MaxLineLength:WalletRepositoryImpl.kt$WalletRepositoryImpl$it.asset.token.configuration.chainToSymbol !in updatedAssets.map { it.asset.token.configuration.chainToSymbol }</ID>
    <ID>MaxLineLength:WalletRepositoryImpl.kt$WalletRepositoryImpl$override</ID>
    <ID>MaxLineLength:WalletRepositoryImpl.kt$WalletRepositoryImpl$override suspend</ID>
    <ID>MaxLineLength:WalletRepositoryImpl.kt$WalletRepositoryImpl$private suspend</ID>
    <ID>MaxLineLength:WalletRepositoryImpl.kt$WalletRepositoryImpl$sortIndex = Int.MAX_VALUE</ID>
    <ID>MaxLineLength:WalletRepositoryImpl.kt$WalletRepositoryImpl$val utilityAsset = chain.utilityAsset?.let { mapAssetLocalToAsset(utilityAssetLocal, it, chain.minSupportedVersion) }</ID>
    <ID>MaxLineLength:WalletRepositoryImpl.kt$WalletRepositoryImpl$val utilityAssetLocal = assetCache.getAsset(metaId, accountId, chainAsset.chainId, chain.utilityAsset?.id.orEmpty())!!</ID>
    <ID>MaxLineLength:WalletRepositoryImpl.kt$WalletRepositoryImpl$val utilityExistentialDepositInPlanks = chain.utilityAsset?.let { walletConstants.existentialDeposit(it) }.orZero()</ID>
    <ID>MaxLineLength:WalletScreen.kt$&lt;no name provided&gt;$override fun actionItemClicked(actionType: ActionItemType, chainId: ChainId, chainAssetId: String, swipeableState: SwipeableState&lt;SwipeState&gt;)</ID>
    <ID>MaxLineLength:WalletScreen.kt$balance = AssetBalanceViewState("TRANSFERABLE BALANCE", "ADDRESS", true, ChangeBalanceViewState("+100%", "+50$"))</ID>
    <ID>MaxLineLength:WalletScreen.kt$multiToggleButtonState = MultiToggleButtonState(AssetType.Currencies, listOf(AssetType.Currencies, AssetType.NFTs))</ID>
    <ID>MaxLineLength:WalletSelectorModal.kt$items</ID>
    <ID>MaxLineLength:WalletSelectorViewModel.kt$WalletSelectorViewModel$private val walletSelectionMode = savedStateHandle[WalletSelectorFragment.WALLET_SELECTION_MODE] ?: WalletSelectionMode.CurrentWallet</ID>
    <ID>MaxLineLength:WalletState.kt$WalletState.Companion$multiToggleButtonState = MultiToggleButtonState(AssetType.Currencies, listOf(AssetType.Currencies, AssetType.NFTs))</ID>
    <ID>MaxLineLength:WarningInfo.kt$message = "This address has been flagged due to evidence of a scam. We strongly recommend that you don\'t send DOT to this account."</ID>
    <ID>MaxLineLength:WelcomeStakingValidationFailure.kt$getString(R.string.staking_max_nominators_reached_title) to getString(R.string.staking_max_nominators_reached_message)</ID>
    <ID>MaxLineLength:WssSubstrateSource.kt$WssSubstrateSource$keyBuilder = { runtime -&gt; runtime.metadata.staking().storage("Bonded").storageKey(runtime, currentAccountId) }</ID>
    <ID>MaxLineLength:WssSubstrateSource.kt$WssSubstrateSource$keyBuilder = { runtime -&gt; runtime.metadata.staking().storage("Ledger").storageKey(runtime, currentAccountId) }</ID>
    <ID>MaxLineLength:WssSubstrateSource.kt$WssSubstrateSource$private</ID>
    <ID>MaxLineLength:WssSubstrateSource.kt$WssSubstrateSource$transfer.chainAsset.currency == null || transfer.chainAsset.typeExtra == null || transfer.chainAsset.typeExtra == ChainAssetType.Normal</ID>
    <ID>MaxLineLength:WssSubstrateSource.kt$WssSubstrateSource$val</ID>
    <ID>MaxLineLength:WssSubstrateSource.kt$WssSubstrateSource$val chainCanTransferAllowDeath = this.runtime.metadata.module(Modules.BALANCES).calls?.contains(Calls.BALANCES_TRANSFER_ALLOW_DEATH) ?: false</ID>
    <ID>MaxLineLength:kotlin-runtimepermissions-coroutines.kt$suspend</ID>
    <ID>MaxLineLength:kotlin-runtimepermissions.kt$fun</ID>
    <ID>MaximumLineLength:AboutFragment.kt$AboutFragment$ </ID>
    <ID>MaximumLineLength:AboutViewModel.kt$AboutViewModel$ </ID>
    <ID>MaximumLineLength:AcalaContributeFactory.kt$AcalaContributeFactory$ </ID>
    <ID>MaximumLineLength:AcalaContributeInteractor.kt$AcalaContributeInteractor$ </ID>
    <ID>MaximumLineLength:AcalaContributeSubmitter.kt$AcalaContributeSubmitter$ </ID>
    <ID>MaximumLineLength:AcalaContributeViewState.kt$AcalaContributeViewState$ </ID>
    <ID>MaximumLineLength:AccountDataSourceImpl.kt$AccountDataSourceImpl$ </ID>
    <ID>MaximumLineLength:AccountDetailsFragment.kt$AccountDetailsFragment$class</ID>
    <ID>MaximumLineLength:AccountDetailsInteractor.kt$AccountDetailsInteractor$ </ID>
    <ID>MaximumLineLength:AccountDetailsViewModel.kt$AccountDetailsViewModel$ </ID>
    <ID>MaximumLineLength:AccountInteractorImpl.kt$AccountInteractorImpl$ </ID>
    <ID>MaximumLineLength:AccountNominationsUpdater.kt$AccountNominationsUpdater$)</ID>
    <ID>MaximumLineLength:AccountRepositoryImpl.kt$AccountRepositoryImpl$ </ID>
    <ID>MaximumLineLength:AccountRewardDestinationUpdater.kt$AccountRewardDestinationUpdater$)</ID>
    <ID>MaximumLineLength:AccountRouter.kt$AccountRouter$ </ID>
    <ID>MaximumLineLength:AccountStakingDao.kt$AccountStakingDao$ </ID>
    <ID>MaximumLineLength:AccountStakingScope.kt$AccountStakingScope$ </ID>
    <ID>MaximumLineLength:AccountValidatorPrefsUpdater.kt$AccountValidatorPrefsUpdater$)</ID>
    <ID>MaximumLineLength:AccountsForExportFragment.kt$AccountsForExportFragment$class</ID>
    <ID>MaximumLineLength:AccountsForExportFragment.kt$AccountsForExportFragment.Companion$ </ID>
    <ID>MaximumLineLength:AccountsForExportViewModel.kt$AccountsForExportViewModel$ </ID>
    <ID>MaximumLineLength:AddNodeViewModel.kt$AddNodeViewModel$ </ID>
    <ID>MaximumLineLength:AddressBookRepositoryImpl.kt$AddressBookRepositoryImpl$ </ID>
    <ID>MaximumLineLength:AddressHistoryContent.kt$ </ID>
    <ID>MaximumLineLength:AddressHistoryViewModel.kt$AddressHistoryViewModel$ </ID>
    <ID>MaximumLineLength:AddressIconGenerator.kt$CachingAddressIconGenerator$ </ID>
    <ID>MaximumLineLength:AddressIconGenerator.kt$StatelessAddressIconGenerator$ </ID>
    <ID>MaximumLineLength:AddressIconGenerator.kt$suspend</ID>
    <ID>MaximumLineLength:AlertsInteractor.kt$AlertsInteractor$ </ID>
    <ID>MaximumLineLength:AmountInput.kt$ </ID>
    <ID>MaximumLineLength:AmountInput.kt$AmountInputViewState.Companion$ </ID>
    <ID>MaximumLineLength:AmountView.kt$AmountView$ </ID>
    <ID>MaximumLineLength:AppConfig.kt$fun</ID>
    <ID>MaximumLineLength:AppDatabase.kt$AppDatabase.Companion$ </ID>
    <ID>MaximumLineLength:Asset.kt$Asset$ </ID>
    <ID>MaximumLineLength:Asset.kt$Asset.Companion$ </ID>
    <ID>MaximumLineLength:AssetCache.kt$AssetCache$ </ID>
    <ID>MaximumLineLength:AssetDao.kt$AssetDao$ </ID>
    <ID>MaximumLineLength:AssetListItem.kt$ </ID>
    <ID>MaximumLineLength:AssetSelectContent.kt$ </ID>
    <ID>MaximumLineLength:AssetSelectViewModel.kt$AssetSelectViewModel$ </ID>
    <ID>MaximumLineLength:AssetSelector.kt$ </ID>
    <ID>MaximumLineLength:AssetSelectorView.kt$AssetSelectorView$ </ID>
    <ID>MaximumLineLength:AssetsList.kt$AssetsListInterface$ </ID>
    <ID>MaximumLineLength:AstarContributeFactory.kt$AstarContributeFactory$ </ID>
    <ID>MaximumLineLength:AstarContributeView.kt$AstarContributeView$ </ID>
    <ID>MaximumLineLength:AstarContributeViewState.kt$AstarContributeViewState$ </ID>
    <ID>MaximumLineLength:BalanceDetailFragment.kt$BalanceDetailFragment$ </ID>
    <ID>MaximumLineLength:BalanceDetailViewModel.kt$BalanceDetailViewModel$ </ID>
    <ID>MaximumLineLength:BalanceDetailsScreen.kt$private</ID>
    <ID>MaximumLineLength:BalanceListFragment.kt$BalanceListFragment$ </ID>
    <ID>MaximumLineLength:BalanceListViewModel.kt$BalanceListViewModel$ </ID>
    <ID>MaximumLineLength:BalanceModel.kt$BalanceModel$ </ID>
    <ID>MaximumLineLength:BalancesUpdateSystem.kt$BalancesUpdateSystem$ </ID>
    <ID>MaximumLineLength:BaseBottomSheetDialogFragment.kt$BaseBottomSheetDialogFragment$abstract</ID>
    <ID>MaximumLineLength:BaseConfirmViewModel.kt$BaseConfirmViewModel$ </ID>
    <ID>MaximumLineLength:BaseEnterAmountViewModel.kt$BaseEnterAmountViewModel$ </ID>
    <ID>MaximumLineLength:BeaconInteractor.kt$BeaconInteractor$ </ID>
    <ID>MaximumLineLength:BeaconStateMachine.kt$BeaconStateMachine.SideEffect$ </ID>
    <ID>MaximumLineLength:BeaconViewModel.kt$BeaconViewModel$ </ID>
    <ID>MaximumLineLength:BifrostApi.kt$BifrostApi$ </ID>
    <ID>MaximumLineLength:BifrostApi.kt$suspend</ID>
    <ID>MaximumLineLength:BifrostContributeFactory.kt$BifrostContributeFactory$ </ID>
    <ID>MaximumLineLength:BifrostContributeViewState.kt$BifrostContributeViewState$ </ID>
    <ID>MaximumLineLength:BindingHelpers.kt$fun</ID>
    <ID>MaximumLineLength:BlockProducer.kt$suspend</ID>
    <ID>MaximumLineLength:BottomSheetScreen.kt$ </ID>
    <ID>MaximumLineLength:BottomSheetScreen.kt$fun</ID>
    <ID>MaximumLineLength:Button.kt$ </ID>
    <ID>MaximumLineLength:BuyCryptoFragment.kt$BuyCryptoFragment$ </ID>
    <ID>MaximumLineLength:BuyMixinProvider.kt$BuyMixinProvider$ </ID>
    <ID>MaximumLineLength:CapExceededValidation.kt$CapExceededValidation$ </ID>
    <ID>MaximumLineLength:Chain.kt$fun</ID>
    <ID>MaximumLineLength:ChainAccountsAdapter.kt$ChainAccountHolder$ </ID>
    <ID>MaximumLineLength:ChainDao.kt$ChainDao$ </ID>
    <ID>MaximumLineLength:ChainRegistry.kt$ChainRegistry$ </ID>
    <ID>MaximumLineLength:ChainSelectContent.kt$ </ID>
    <ID>MaximumLineLength:ChainSelectViewModel.kt$ChainSelectViewModel$ </ID>
    <ID>MaximumLineLength:ChainStateRepository.kt$ChainStateRepository$ </ID>
    <ID>MaximumLineLength:ChainSyncService.kt$ChainSyncService$ </ID>
    <ID>MaximumLineLength:CollatorDetailsViewModel.kt$CollatorDetailsViewModel$ </ID>
    <ID>MaximumLineLength:CollatorProvider.kt$CollatorProvider$ </ID>
    <ID>MaximumLineLength:CollatorRecommendator.kt$CollatorRecommendator$ </ID>
    <ID>MaximumLineLength:CollatorRecommendatorFactory.kt$CollatorRecommendatorFactory$ </ID>
    <ID>MaximumLineLength:CollatorsAdapter.kt$CollatorDiffCallback$ </ID>
    <ID>MaximumLineLength:CollatorsAdapter.kt$CollatorViewHolder$ </ID>
    <ID>MaximumLineLength:ComposeExt.kt$fun</ID>
    <ID>MaximumLineLength:ConfirmBondMoreViewModel.kt$ConfirmBondMoreViewModel$ </ID>
    <ID>MaximumLineLength:ConfirmContributeViewModel.kt$ConfirmContributeViewModel$ </ID>
    <ID>MaximumLineLength:ConfirmCreatePoolViewModel.kt$ConfirmCreatePoolViewModel$ </ID>
    <ID>MaximumLineLength:ConfirmCreatePoolViewModel.kt$private</ID>
    <ID>MaximumLineLength:ConfirmJoinPoolFragment.kt$ConfirmJoinPoolFragment$ </ID>
    <ID>MaximumLineLength:ConfirmJoinPoolScreen.kt$ </ID>
    <ID>MaximumLineLength:ConfirmMnemonicViewModel.kt$ConfirmMnemonicViewModel$ </ID>
    <ID>MaximumLineLength:ConfirmNominationsFragment.kt$ConfirmNominationsFragment$class</ID>
    <ID>MaximumLineLength:ConfirmPayoutViewModel.kt$ConfirmPayoutViewModel$ </ID>
    <ID>MaximumLineLength:ConfirmPoolRedeemViewModel.kt$ConfirmPoolRedeemViewModel$ </ID>
    <ID>MaximumLineLength:ConfirmPoolUnbondViewModel.kt$ConfirmPoolUnbondViewModel$ </ID>
    <ID>MaximumLineLength:ConfirmRebondViewModel.kt$ConfirmRebondViewModel$ </ID>
    <ID>MaximumLineLength:ConfirmRewardDestinationFragment.kt$ConfirmRewardDestinationFragment$ </ID>
    <ID>MaximumLineLength:ConfirmRewardDestinationFragment.kt$ConfirmRewardDestinationFragment$class</ID>
    <ID>MaximumLineLength:ConfirmRewardDestinationViewModel.kt$ConfirmRewardDestinationViewModel$ </ID>
    <ID>MaximumLineLength:ConfirmScreen.kt$ </ID>
    <ID>MaximumLineLength:ConfirmSelectValidatorsViewModel.kt$ConfirmSelectValidatorsViewModel$ </ID>
    <ID>MaximumLineLength:ConfirmSendViewModel.kt$ConfirmSendViewModel$ </ID>
    <ID>MaximumLineLength:ConfirmSetControllerFragment.kt$ConfirmSetControllerFragment$class</ID>
    <ID>MaximumLineLength:ConfirmSetControllerViewModel.kt$ConfirmSetControllerViewModel$ </ID>
    <ID>MaximumLineLength:ConfirmStakingViewModel.kt$ConfirmStakingViewModel$ </ID>
    <ID>MaximumLineLength:ConfirmUnbondViewModel.kt$ConfirmUnbondViewModel$ </ID>
    <ID>MaximumLineLength:ConnectionPool.kt$ConnectionPool$ </ID>
    <ID>MaximumLineLength:ContributeValidationFailure.kt$ </ID>
    <ID>MaximumLineLength:ControllerDeprecationWarningModel.kt$ </ID>
    <ID>MaximumLineLength:ControllerInteractor.kt$ControllerInteractor$ </ID>
    <ID>MaximumLineLength:CreateAccountViewModel.kt$CreateAccountViewModel$ </ID>
    <ID>MaximumLineLength:CreatePoolSetupScreen.kt$ </ID>
    <ID>MaximumLineLength:CreatePoolSetupViewModel.kt$CreatePoolSetupViewModel$ </ID>
    <ID>MaximumLineLength:CrossChainConfirmViewModel.kt$CrossChainConfirmViewModel$ </ID>
    <ID>MaximumLineLength:CrossChainSetupContent.kt$ </ID>
    <ID>MaximumLineLength:CrossChainSetupFragment.kt$CrossChainSetupFragment$ </ID>
    <ID>MaximumLineLength:CrossChainSetupViewModel.kt$CrossChainSetupViewModel$ </ID>
    <ID>MaximumLineLength:CrossChainTransfer.kt$CrossChainTransfer$ </ID>
    <ID>MaximumLineLength:CrowdloanAdapter.kt$CrowdloanChildHolder$ </ID>
    <ID>MaximumLineLength:CrowdloanAdapter.kt$CrowdloanDiffCallback$private</ID>
    <ID>MaximumLineLength:CrowdloanContributeInteractor.kt$CrowdloanContributeInteractor$ </ID>
    <ID>MaximumLineLength:CrowdloanContributeViewModel.kt$CrowdloanContributeViewModel$ </ID>
    <ID>MaximumLineLength:CrowdloanRepository.kt$CrowdloanRepository$ </ID>
    <ID>MaximumLineLength:CrowdloanViewModel.kt$CrowdloanViewModel$ </ID>
    <ID>MaximumLineLength:CurrentAccountAddressUseCase.kt$CurrentAccountAddressUseCase$class</ID>
    <ID>MaximumLineLength:CurrentValidatorsAdapter.kt$CurrentValidatorsDiffCallback$ </ID>
    <ID>MaximumLineLength:CurrentValidatorsFragment.kt$CurrentValidatorsFragment$class</ID>
    <ID>MaximumLineLength:CurrentValidatorsInteractor.kt$CurrentValidatorsInteractor$ </ID>
    <ID>MaximumLineLength:CurrentValidatorsViewModel.kt$CurrentValidatorsViewModel$ </ID>
    <ID>MaximumLineLength:CustomBlockProducersAdapter.kt$BlockProducerDiffCallback$ </ID>
    <ID>MaximumLineLength:CustomBlockProducersAdapter.kt$BlockProducerViewHolder$class</ID>
    <ID>MaximumLineLength:CustomBlockProducersAdapter.kt$CustomBlockProducersAdapter$ </ID>
    <ID>MaximumLineLength:CustomContributeManager.kt$CustomContributeManager$ </ID>
    <ID>MaximumLineLength:CustomContributeViewModel.kt$CustomContributeViewModel$ </ID>
    <ID>MaximumLineLength:CustomValidatorsSettingsViewModel.kt$CustomValidatorsSettingsViewModel$ </ID>
    <ID>MaximumLineLength:Data.kt$ </ID>
    <ID>MaximumLineLength:Declarations.kt$typealias</ID>
    <ID>MaximumLineLength:Definitions.kt$typealias</ID>
    <ID>MaximumLineLength:DelegationRecyclerViewAdapter.kt$DelegationDiffCallback$ </ID>
    <ID>MaximumLineLength:DelegationRecyclerViewAdapter.kt$DelegationViewHolder$ </ID>
    <ID>MaximumLineLength:DelegatorStateUpdater.kt$DelegatorStateUpdater$)</ID>
    <ID>MaximumLineLength:DragAndDropTouchHelperCallback.kt$DragAndDropTouchHelperCallback$ </ID>
    <ID>MaximumLineLength:DragAndDropTouchHelperCallback.kt$DragAndDropTouchHelperCallback$class</ID>
    <ID>MaximumLineLength:EditPoolConfirmViewModel.kt$EditPoolConfirmViewModel$ </ID>
    <ID>MaximumLineLength:EditPoolScreen.kt$ </ID>
    <ID>MaximumLineLength:EditPoolViewModel.kt$EditPoolViewModel$ </ID>
    <ID>MaximumLineLength:EmailValidator.kt$EmailValidator.Companion$ </ID>
    <ID>MaximumLineLength:EncryptionTypeChooserBottomSheetDialog.kt$EncryptionTypeViewHolder$ </ID>
    <ID>MaximumLineLength:EncryptionUtil.kt$EncryptionUtil$ </ID>
    <ID>MaximumLineLength:Error.kt$fun</ID>
    <ID>MaximumLineLength:EthereumDerivationPathMigration.kt$EthereumDerivationPathMigration$ </ID>
    <ID>MaximumLineLength:Exceptions.kt$MinPoolCreationThresholdException$class</ID>
    <ID>MaximumLineLength:ExistentialDepositUseCaseImpl.kt$ExistentialDepositUseCaseImpl$ </ID>
    <ID>MaximumLineLength:ExpandableLazyListNestedScrollConnection.kt$ExpandableLazyListNestedScrollConnection$ </ID>
    <ID>MaximumLineLength:ExperimentalViewModel.kt$ExperimentalViewModel$ </ID>
    <ID>MaximumLineLength:ExportExt.kt$inline</ID>
    <ID>MaximumLineLength:ExportJsonPasswordViewModel.kt$ExportJsonPasswordViewModel$ </ID>
    <ID>MaximumLineLength:ExportMnemonicFragment.kt$ExportMnemonicFragment$ </ID>
    <ID>MaximumLineLength:ExportMnemonicViewModel.kt$ExportMnemonicViewModel$ </ID>
    <ID>MaximumLineLength:ExportSeedFragment.kt$ExportSeedFragment$ </ID>
    <ID>MaximumLineLength:ExportSeedViewModel.kt$ExportSeedViewModel$ </ID>
    <ID>MaximumLineLength:ExportSource.kt$ExportSource$ </ID>
    <ID>MaximumLineLength:ExportSource.kt$ExportSource$sealed</ID>
    <ID>MaximumLineLength:Ext.kt$ </ID>
    <ID>MaximumLineLength:Ext.kt$fun</ID>
    <ID>MaximumLineLength:Extensions.kt$fun</ID>
    <ID>MaximumLineLength:ExternalActionsUi.kt$fun</ID>
    <ID>MaximumLineLength:Extrinsic.kt$ </ID>
    <ID>MaximumLineLength:ExtrinsicBuilderExt.kt$@</ID>
    <ID>MaximumLineLength:ExtrinsicBuilderExt.kt$fun</ID>
    <ID>MaximumLineLength:ExtrinsicDetailFragment.kt$ExtrinsicDetailFragment$ </ID>
    <ID>MaximumLineLength:FearlessException.kt$FearlessException.Companion$ </ID>
    <ID>MaximumLineLength:FearlessLibExt.kt$fun</ID>
    <ID>MaximumLineLength:FiatCurrenciesChooserBottomSheetDialog.kt$FiatCurrencyHolder$private</ID>
    <ID>MaximumLineLength:FixedListBottomSheet.kt$ </ID>
    <ID>MaximumLineLength:GetAvailableFiatCurrencies.kt$GetAvailableFiatCurrencies$ </ID>
    <ID>MaximumLineLength:GetSoraCardFragment.kt$GetSoraCardFragment$ </ID>
    <ID>MaximumLineLength:GetSoraCardScreen.kt$ </ID>
    <ID>MaximumLineLength:GetSoraCardViewModel.kt$GetSoraCardViewModel$ </ID>
    <ID>MaximumLineLength:HistoryRepository.kt$HistoryRepository$ </ID>
    <ID>MaximumLineLength:HistorySourceProvider.kt$HistorySourceProvider$ </ID>
    <ID>MaximumLineLength:HttpExceptionHandler.kt$HttpExceptionHandler$ </ID>
    <ID>MaximumLineLength:IdentityRepositoryImpl.kt$IdentityRepositoryImpl$ </ID>
    <ID>MaximumLineLength:ImportAccountFragment.kt$ImportAccountFragment$ </ID>
    <ID>MaximumLineLength:ImportAccountViewModel.kt$ImportAccountViewModel$ </ID>
    <ID>MaximumLineLength:ImportSourceModel.kt$ImportSource$sealed</ID>
    <ID>MaximumLineLength:ImportSourceModel.kt$MnemonicImportSource$class</ID>
    <ID>MaximumLineLength:ImportSourceModel.kt$RawSeedImportSource$class</ID>
    <ID>MaximumLineLength:InfoDialog.kt$ </ID>
    <ID>MaximumLineLength:InfoTable.kt$ </ID>
    <ID>MaximumLineLength:InfoTableItem.kt$ </ID>
    <ID>MaximumLineLength:InputWithHint.kt$ </ID>
    <ID>MaximumLineLength:InterlayContributeFactory.kt$InterlayContributeFactory$ </ID>
    <ID>MaximumLineLength:InterlayContributeViewState.kt$InterlayContributeViewState$ </ID>
    <ID>MaximumLineLength:JsonImportView.kt$JsonImportView$ </ID>
    <ID>MaximumLineLength:KaruraContributeFactory.kt$KaruraContributeFactory$ </ID>
    <ID>MaximumLineLength:KaruraContributeViewState.kt$KaruraContributeViewState$ </ID>
    <ID>MaximumLineLength:KoltinExt.kt$inline</ID>
    <ID>MaximumLineLength:LanguagesAdapter.kt$LanguagesAdapter$ </ID>
    <ID>MaximumLineLength:LeaseIndexFromBlock.kt$fun</ID>
    <ID>MaximumLineLength:LockBottomSheetBehavior.kt$LockBottomSheetBehavior$ </ID>
    <ID>MaximumLineLength:ManagePoolStakeScreen.kt$ </ID>
    <ID>MaximumLineLength:ManagePoolStakeViewModel.kt$ManagePoolStakeViewModel$ </ID>
    <ID>MaximumLineLength:ManageStakingBottomSheet.kt$ManageStakingBottomSheet$ </ID>
    <ID>MaximumLineLength:ManualRewardCalculator.kt$ManualRewardCalculator$ </ID>
    <ID>MaximumLineLength:MapFundInfoToCrowdloan.kt$ </ID>
    <ID>MaximumLineLength:MapRewardDestinationModelToRewardDestination.kt$ </ID>
    <ID>MaximumLineLength:Mappers.kt$private</ID>
    <ID>MaximumLineLength:Migrations.kt$&lt;no name provided&gt;$ </ID>
    <ID>MaximumLineLength:MinContributionValidation.kt$MinContributionValidation$ </ID>
    <ID>MaximumLineLength:MinimumAmountValidation.kt$MinimumAmountValidation$ </ID>
    <ID>MaximumLineLength:MnemonicAgreementsViewModel.kt$MnemonicAgreementsViewModel$ </ID>
    <ID>MaximumLineLength:MnemonicContainerView.kt$MnemonicContainerView$ </ID>
    <ID>MaximumLineLength:MoonbeamContributeInteractor.kt$MoonbeamContributeInteractor$ </ID>
    <ID>MaximumLineLength:MoonbeamContributeViewState.kt$MoonbeamContributeViewState$ </ID>
    <ID>MaximumLineLength:MoonbeamStep2Registration.kt$MoonbeamStep2Registration$ </ID>
    <ID>MaximumLineLength:MultiAddress.kt$fun</ID>
    <ID>MaximumLineLength:Navigator.kt$Navigator$ </ID>
    <ID>MaximumLineLength:NodeDetailsFragment.kt$NodeDetailsFragment$ </ID>
    <ID>MaximumLineLength:NodeDetailsRootViewModel.kt$NodeDetailsRootViewModel$ </ID>
    <ID>MaximumLineLength:NominatedValidator.kt$NominatedValidator.Status.Group$ </ID>
    <ID>MaximumLineLength:NotZeroBalanceValidation.kt$NotZeroBalanceValidation$ </ID>
    <ID>MaximumLineLength:NumberFormatters.kt$fun</ID>
    <ID>MaximumLineLength:ObserveBrowserEvents.kt$fun</ID>
    <ID>MaximumLineLength:ObserveRewardDestinationChooser.kt$ </ID>
    <ID>MaximumLineLength:OperationDao.kt$private</ID>
    <ID>MaximumLineLength:OperationMappers.kt$ </ID>
    <ID>MaximumLineLength:OperationMappers.kt$fun</ID>
    <ID>MaximumLineLength:ParachainNetworkInfoView.kt$ParachainNetworkInfoView$ </ID>
    <ID>MaximumLineLength:PaymentUpdater.kt$ </ID>
    <ID>MaximumLineLength:PaymentUpdater.kt$PaymentUpdater$ </ID>
    <ID>MaximumLineLength:PayoutDetailsViewModel.kt$PayoutDetailsViewModel$ </ID>
    <ID>MaximumLineLength:PayoutRepository.kt$PayoutRepository$ </ID>
    <ID>MaximumLineLength:PayoutsListFragment.kt$PayoutsListFragment$class</ID>
    <ID>MaximumLineLength:PayoutsListViewModel.kt$PayoutsListViewModel$ </ID>
    <ID>MaximumLineLength:PendingPayoutModel.kt$PendingPayoutModel$ </ID>
    <ID>MaximumLineLength:PinCodeViewModel.kt$PinCodeViewModel$ </ID>
    <ID>MaximumLineLength:PolkaswapDisclaimerViewModel.kt$PolkaswapDisclaimerViewModel$ </ID>
    <ID>MaximumLineLength:PolkaswapFeatureBindModule.kt$PolkaswapFeatureModule$ </ID>
    <ID>MaximumLineLength:PolkaswapInteractorImpl.kt$PolkaswapInteractorImpl$ </ID>
    <ID>MaximumLineLength:PolkaswapRepository.kt$PolkaswapRepository$ </ID>
    <ID>MaximumLineLength:PolkaswapRepositoryImpl.kt$PolkaswapRepositoryImpl$ </ID>
    <ID>MaximumLineLength:PoolBondMoreViewModel.kt$PoolBondMoreViewModel$ </ID>
    <ID>MaximumLineLength:PoolFullUnstakeDepositorAlertFragment.kt$PoolFullUnstakeDepositorAlertFragment$ </ID>
    <ID>MaximumLineLength:PoolInfoScreen.kt$ </ID>
    <ID>MaximumLineLength:PoolInfoViewModel.kt$PoolInfoViewModel$ </ID>
    <ID>MaximumLineLength:PoolRedeemViewModel.kt$PoolRedeemViewModel$ </ID>
    <ID>MaximumLineLength:PoolUnstakeViewModel.kt$PoolUnstakeViewModel$ </ID>
    <ID>MaximumLineLength:ProfileModule.kt$ProfileModule$ </ID>
    <ID>MaximumLineLength:QrCodeGenerator.kt$QrCodeGenerator$ </ID>
    <ID>MaximumLineLength:RampProvider.kt$ </ID>
    <ID>MaximumLineLength:RebondValidationsModule.kt$RebondValidationsModule$ </ID>
    <ID>MaximumLineLength:ReceiveFragment.kt$ReceiveFragment$ </ID>
    <ID>MaximumLineLength:RecommendationSettingsProvider.kt$RecommendationSettingsProvider.RelayChain$ </ID>
    <ID>MaximumLineLength:RecommendedValidatorsFragment.kt$RecommendedValidatorsFragment$class</ID>
    <ID>MaximumLineLength:RedeemViewModel.kt$RedeemViewModel$ </ID>
    <ID>MaximumLineLength:ReferralContributeViewState.kt$ReferralContributeViewState$ </ID>
    <ID>MaximumLineLength:Reused.kt$typealias</ID>
    <ID>MaximumLineLength:ReviewCustomValidatorsViewModel.kt$ReviewCustomValidatorsViewModel$ </ID>
    <ID>MaximumLineLength:Reward.kt$ </ID>
    <ID>MaximumLineLength:RewardCalculatorFactory.kt$RewardCalculatorFactory$ </ID>
    <ID>MaximumLineLength:RewardDestinationProvider.kt$RewardDestinationProvider$ </ID>
    <ID>MaximumLineLength:RewardDestinationViewer.kt$RewardDestinationViewer$ </ID>
    <ID>MaximumLineLength:RewardDetailFragment.kt$RewardDetailFragment$ </ID>
    <ID>MaximumLineLength:RewardDetailViewModel.kt$RewardDetailViewModel$ </ID>
    <ID>MaximumLineLength:RootActivity.kt$RootActivity$ </ID>
    <ID>MaximumLineLength:RuntimeProvider.kt$RuntimeProvider$ </ID>
    <ID>MaximumLineLength:RuntimeSyncService.kt$RuntimeSyncService$ </ID>
    <ID>MaximumLineLength:RuntimeVersionSubscription.kt$RuntimeVersionSubscription$ </ID>
    <ID>MaximumLineLength:SearchAssetsFragment.kt$SearchAssetsFragment$ </ID>
    <ID>MaximumLineLength:SearchAssetsScreen.kt$&lt;no name provided&gt;$ </ID>
    <ID>MaximumLineLength:SearchAssetsViewModel.kt$SearchAssetsViewModel$ </ID>
    <ID>MaximumLineLength:SearchBlockProducerModel.kt$SearchBlockProducerModel$data</ID>
    <ID>MaximumLineLength:SearchCustomBlockProducerInteractor.kt$BlockedValidatorException$object</ID>
    <ID>MaximumLineLength:SearchCustomBlockProducerInteractor.kt$SearchCustomBlockProducerInteractor$ </ID>
    <ID>MaximumLineLength:SearchCustomValidatorsFragment.kt$SearchCustomValidatorsFragment$ </ID>
    <ID>MaximumLineLength:SearchCustomValidatorsViewModel.kt$SearchBlockProducersState$ </ID>
    <ID>MaximumLineLength:SearchCustomValidatorsViewModel.kt$SearchCustomValidatorsViewModel$ </ID>
    <ID>MaximumLineLength:SecretStoreV1.kt$SecretStoreV1Impl$ </ID>
    <ID>MaximumLineLength:SecretStoreV2.kt$ </ID>
    <ID>MaximumLineLength:SecretStoreV2.kt$SecretStoreV2$ </ID>
    <ID>MaximumLineLength:SeedImportView.kt$SeedImportView$ </ID>
    <ID>MaximumLineLength:SegmentedButtonView.kt$SegmentedButtonView.ExtendedState$ </ID>
    <ID>MaximumLineLength:SelectBondMoreViewModel.kt$SelectBondMoreViewModel$ </ID>
    <ID>MaximumLineLength:SelectCustomCollatorsFragment.kt$SelectCustomCollatorsFragment$class</ID>
    <ID>MaximumLineLength:SelectCustomCollatorsViewModel.kt$SelectCustomCollatorsViewModel$ </ID>
    <ID>MaximumLineLength:SelectCustomValidatorsViewModel.kt$SelectCustomValidatorsViewModel$ </ID>
    <ID>MaximumLineLength:SelectPoolScreen.kt$ </ID>
    <ID>MaximumLineLength:SelectRewardDestinationFragment.kt$SelectRewardDestinationFragment$class</ID>
    <ID>MaximumLineLength:SelectRewardDestinationViewModel.kt$SelectRewardDestinationViewModel$ </ID>
    <ID>MaximumLineLength:SelectUnbondViewModel.kt$SelectUnbondViewModel$ </ID>
    <ID>MaximumLineLength:SelectValidatorsVariantPanel.kt$ </ID>
    <ID>MaximumLineLength:SelectValidatorsViewModel.kt$ </ID>
    <ID>MaximumLineLength:SelectValidatorsViewModel.kt$SelectValidatorsViewModel$ </ID>
    <ID>MaximumLineLength:SelectWalletContent.kt$ </ID>
    <ID>MaximumLineLength:SelectableListItem.kt$SelectableListItemState.SelectableListItemAdditionalStatus$ </ID>
    <ID>MaximumLineLength:SelectedValidatorsViewModel.kt$SelectedValidatorsViewModel$ </ID>
    <ID>MaximumLineLength:SendSetupFragment.kt$SendSetupFragment$ </ID>
    <ID>MaximumLineLength:SendSetupViewModel.kt$SendSetupViewModel$ </ID>
    <ID>MaximumLineLength:SetControllerViewModel.kt$SetControllerViewModel$ </ID>
    <ID>MaximumLineLength:SettingsFiltersAdapter.kt$SettingsFilterViewHolder$ </ID>
    <ID>MaximumLineLength:SettingsFiltersAdapter.kt$SettingsFilterViewHolder$class</ID>
    <ID>MaximumLineLength:SettingsSortingAdapter.kt$SettingsSortingViewHolder$ </ID>
    <ID>MaximumLineLength:SettingsSortingAdapter.kt$SettingsSortingViewHolder$class</ID>
    <ID>MaximumLineLength:SetupStakingInteractor.kt$SetupStakingInteractor$ </ID>
    <ID>MaximumLineLength:SetupStakingPoolViewModel.kt$SetupStakingPoolViewModel$ </ID>
    <ID>MaximumLineLength:SetupStakingScreen.kt$ </ID>
    <ID>MaximumLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit$ </ID>
    <ID>MaximumLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Parachain$ </ID>
    <ID>MaximumLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Payload.ExistingStash$ </ID>
    <ID>MaximumLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Payload.Full$ </ID>
    <ID>MaximumLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Payload.Parachain$ </ID>
    <ID>MaximumLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Payload.RelayChain$ </ID>
    <ID>MaximumLineLength:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit.Stash$ </ID>
    <ID>MaximumLineLength:SetupStakingSharedState.kt$SetupStakingProcess.SelectBlockProducersStep.Collators$ </ID>
    <ID>MaximumLineLength:SetupStakingSharedState.kt$SetupStakingProcess.SelectBlockProducersStep.Validators$ </ID>
    <ID>MaximumLineLength:SetupStakingSharedState.kt$SetupStakingProcess.SetupStep.Parachain$ </ID>
    <ID>MaximumLineLength:SetupStakingViewModel.kt$SetupStakingViewModel$ </ID>
    <ID>MaximumLineLength:SignBeaconTransactionFragment.kt$SignBeaconTransactionFragment$class</ID>
    <ID>MaximumLineLength:SignBeaconTransactionViewModel.kt$SignBeaconTransactionViewModel$ </ID>
    <ID>MaximumLineLength:SoraCardInteractorImpl.kt$SoraCardInteractorImpl$ </ID>
    <ID>MaximumLineLength:SoraHistorySource.kt$SoraHistorySource$ </ID>
    <ID>MaximumLineLength:SoraRewardCalculator.kt$SoraRewardCalculator$ </ID>
    <ID>MaximumLineLength:SoraStakingRewardsScenario.kt$SoraStakingRewardsScenario$class</ID>
    <ID>MaximumLineLength:StakeInfoViewState.kt$fun</ID>
    <ID>MaximumLineLength:StakeSummaryView.kt$StakeSummaryView$ </ID>
    <ID>MaximumLineLength:StakeSummaryView.kt$StakeSummaryView.Status$ </ID>
    <ID>MaximumLineLength:StakingAssetInfoViewState.kt$ </ID>
    <ID>MaximumLineLength:StakingAssetInfoViewState.kt$fun</ID>
    <ID>MaximumLineLength:StakingAssetSelector.kt$StakingAssetSelector$ </ID>
    <ID>MaximumLineLength:StakingConstantsRepository.kt$StakingConstantsRepository$ </ID>
    <ID>MaximumLineLength:StakingFeatureModule.kt$StakingFeatureModule$ </ID>
    <ID>MaximumLineLength:StakingFragment.kt$StakingFragment$ </ID>
    <ID>MaximumLineLength:StakingFragment.kt$StakingFragment$class</ID>
    <ID>MaximumLineLength:StakingInfoItem.kt$ </ID>
    <ID>MaximumLineLength:StakingInteractor.kt$StakingInteractor$ </ID>
    <ID>MaximumLineLength:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$ </ID>
    <ID>MaximumLineLength:StakingParachainScenarioRepository.kt$StakingParachainScenarioRepository$ </ID>
    <ID>MaximumLineLength:StakingParachainScenarioViewModel.kt$StakingParachainScenarioViewModel$ </ID>
    <ID>MaximumLineLength:StakingPoolApi.kt$StakingPoolApi$ </ID>
    <ID>MaximumLineLength:StakingPoolInteractor.kt$StakingPoolInteractor$ </ID>
    <ID>MaximumLineLength:StakingPoolViewModel.kt$StakingPoolViewModel$ </ID>
    <ID>MaximumLineLength:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$ </ID>
    <ID>MaximumLineLength:StakingRelayChainScenarioRepository.kt$StakingRelayChainScenarioRepository$ </ID>
    <ID>MaximumLineLength:StakingRelaychainScenarioViewModel.kt$StakingRelaychainScenarioViewModel$ </ID>
    <ID>MaximumLineLength:StakingScenarioInteractor.kt$StakingScenarioInteractor$ </ID>
    <ID>MaximumLineLength:StakingScenarioViewModel.kt$StakingScenarioViewModel$ </ID>
    <ID>MaximumLineLength:StakingSharedState.kt$StakingSharedState$ </ID>
    <ID>MaximumLineLength:StakingValidationFailure.kt$ </ID>
    <ID>MaximumLineLength:StakingViewModel.kt$StakingViewModel$ </ID>
    <ID>MaximumLineLength:StakingViewStateFactory.kt$StakingViewStateFactory$ </ID>
    <ID>MaximumLineLength:StakingViewStateOld.kt$ </ID>
    <ID>MaximumLineLength:StakingViewStateOld.kt$DelegatorViewState$ </ID>
    <ID>MaximumLineLength:StakingViewStateOld.kt$RelaychainWelcomeViewState$ </ID>
    <ID>MaximumLineLength:StakingViewStateOld.kt$SoraNominatorViewState$ </ID>
    <ID>MaximumLineLength:StakingViewStateOld.kt$SoraNominatorViewState$)</ID>
    <ID>MaximumLineLength:StakingViewStateOld.kt$StakeViewState$ </ID>
    <ID>MaximumLineLength:StakingViewStateOld.kt$StakingPoolWelcomeViewState$ </ID>
    <ID>MaximumLineLength:StakingViewStateOld.kt$StashNoneViewState$ </ID>
    <ID>MaximumLineLength:StakingViewStateOld.kt$ValidatorViewState$ </ID>
    <ID>MaximumLineLength:StakingViewStateOld.kt$WelcomeViewState$ </ID>
    <ID>MaximumLineLength:StartChangeCollatorsFragment.kt$StartChangeCollatorsFragment$ </ID>
    <ID>MaximumLineLength:StartChangeCollatorsFragment.kt$StartChangeCollatorsFragment$class</ID>
    <ID>MaximumLineLength:StartChangeCollatorsViewModel.kt$StartChangeCollatorsViewModel$ </ID>
    <ID>MaximumLineLength:StartChangeValidatorsFragment.kt$StartChangeValidatorsFragment$ </ID>
    <ID>MaximumLineLength:StartChangeValidatorsFragment.kt$StartChangeValidatorsFragment$class</ID>
    <ID>MaximumLineLength:StartSelectValidatorsScreen.kt$ </ID>
    <ID>MaximumLineLength:StartSelectValidatorsViewModel.kt$StartSelectValidatorsViewModel$ </ID>
    <ID>MaximumLineLength:StartStakingPoolScreen.kt$ </ID>
    <ID>MaximumLineLength:StartStakingPoolViewModel.kt$StartStakingPoolViewModel$ </ID>
    <ID>MaximumLineLength:StorageDao.kt$private</ID>
    <ID>MaximumLineLength:SubQueryDelegationHistoryFetcher.kt$SubQueryDelegationHistoryFetcher$ </ID>
    <ID>MaximumLineLength:SubqueryRewardCalculator.kt$SubqueryRewardCalculator$ </ID>
    <ID>MaximumLineLength:SubqueryStakingRewardsDataSource.kt$SubqueryStakingRewardsDataSource$ </ID>
    <ID>MaximumLineLength:SuccessViewModel.kt$SuccessViewModel$ </ID>
    <ID>MaximumLineLength:SwapDetailContent.kt$ </ID>
    <ID>MaximumLineLength:SwapDetailViewModel.kt$SwapDetailViewModel$ </ID>
    <ID>MaximumLineLength:SwapDetailsViewState.kt$ </ID>
    <ID>MaximumLineLength:SwapPreviewFragment.kt$SwapPreviewFragment.Companion$ </ID>
    <ID>MaximumLineLength:SwapPreviewViewModel.kt$SwapPreviewViewModel$ </ID>
    <ID>MaximumLineLength:SwapTokensContent.kt$ </ID>
    <ID>MaximumLineLength:SwapTokensContent.kt$SwapTokensContentViewState.Companion$ </ID>
    <ID>MaximumLineLength:SwapTokensViewModel.kt$SwapTokensViewModel$ </ID>
    <ID>MaximumLineLength:SwipeBox.kt$ </ID>
    <ID>MaximumLineLength:SwipeableAssetListItem.kt$ </ID>
    <ID>MaximumLineLength:TernoaRewardCalculator.kt$TernoaRewardCalculator$ </ID>
    <ID>MaximumLineLength:TextFieldHint.kt$ </ID>
    <ID>MaximumLineLength:TitleValue.kt$ </ID>
    <ID>MaximumLineLength:TitleValue.kt$private</ID>
    <ID>MaximumLineLength:TokenRepositoryImpl.kt$TokenRepositoryImpl$ </ID>
    <ID>MaximumLineLength:Toolbar.kt$Toolbar$ </ID>
    <ID>MaximumLineLength:TotalBalanceUseCaseImpl.kt$TotalBalanceUseCaseImpl$ </ID>
    <ID>MaximumLineLength:TransactionDetailViewModel.kt$TransactionDetailViewModel$ </ID>
    <ID>MaximumLineLength:TransactionHistoryFilterFragment.kt$TransactionHistoryFilterFragment$class</ID>
    <ID>MaximumLineLength:TransactionHistoryProvider.kt$TransactionHistoryProvider$ </ID>
    <ID>MaximumLineLength:TransactionItem.kt$ </ID>
    <ID>MaximumLineLength:TransactionSettingsViewModel.kt$TransactionSettingsViewModel$ </ID>
    <ID>MaximumLineLength:Transfer.kt$Transfer$ </ID>
    <ID>MaximumLineLength:TransferCursorStorage.kt$TransferCursorStorage$ </ID>
    <ID>MaximumLineLength:TransferValidityChecks.kt$ </ID>
    <ID>MaximumLineLength:UnbondingModel.kt$UnbondingModel$ </ID>
    <ID>MaximumLineLength:UnbondingsAdapter.kt$UnbondingsHolder$ </ID>
    <ID>MaximumLineLength:V2Migration.kt$V2Migration$ </ID>
    <ID>MaximumLineLength:V2MigrationTest.kt$V2MigrationTest$ </ID>
    <ID>MaximumLineLength:V2MigrationTest.kt$private</ID>
    <ID>MaximumLineLength:ValidateTransferUseCase.kt$fun</ID>
    <ID>MaximumLineLength:ValidateTransferUseCaseImpl.kt$ValidateTransferUseCaseImpl$ </ID>
    <ID>MaximumLineLength:ValidationSystems.kt$typealias</ID>
    <ID>MaximumLineLength:Validator.kt$)</ID>
    <ID>MaximumLineLength:ValidatorDetailsFragment.kt$ValidatorDetailsFragment$ </ID>
    <ID>MaximumLineLength:ValidatorDetailsFragment.kt$ValidatorDetailsFragment$class</ID>
    <ID>MaximumLineLength:ValidatorDetailsViewModel.kt$ValidatorDetailsViewModel$ </ID>
    <ID>MaximumLineLength:ValidatorInfoView.kt$Error$ </ID>
    <ID>MaximumLineLength:ValidatorInfoView.kt$ValidatorInfoView$ </ID>
    <ID>MaximumLineLength:ValidatorProvider.kt$ValidatorProvider$ </ID>
    <ID>MaximumLineLength:ValidatorRecommendator.kt$ValidatorRecommendator$ </ID>
    <ID>MaximumLineLength:ValidatorRecommendatorFactory.kt$ValidatorRecommendatorFactory$ </ID>
    <ID>MaximumLineLength:ValidatorsAdapter.kt$ValidatorDiffCallback$ </ID>
    <ID>MaximumLineLength:ValidatorsSettingsViewModel.kt$ValidatorsSettingsViewModel$ </ID>
    <ID>MaximumLineLength:ViewExt.kt$ </ID>
    <ID>MaximumLineLength:WalletExportViewModel.kt$WalletExportViewModel$ </ID>
    <ID>MaximumLineLength:WalletFeatureModule.kt$WalletFeatureModule$ </ID>
    <ID>MaximumLineLength:WalletInteractorImpl.kt$WalletInteractorImpl$ </ID>
    <ID>MaximumLineLength:WalletRepository.kt$WalletRepository$ </ID>
    <ID>MaximumLineLength:WalletRepositoryImpl.kt$WalletRepositoryImpl$ </ID>
    <ID>MaximumLineLength:WalletScreen.kt$ </ID>
    <ID>MaximumLineLength:WalletScreen.kt$&lt;no name provided&gt;$ </ID>
    <ID>MaximumLineLength:WalletSelectorModal.kt$ </ID>
    <ID>MaximumLineLength:WalletSelectorViewModel.kt$WalletSelectorViewModel$ </ID>
    <ID>MaximumLineLength:WalletState.kt$WalletState.Companion$ </ID>
    <ID>MaximumLineLength:WarningInfo.kt$ </ID>
    <ID>MaximumLineLength:WelcomeStakingValidationFailure.kt$ </ID>
    <ID>MaximumLineLength:WssSubstrateSource.kt$WssSubstrateSource$ </ID>
    <ID>MaximumLineLength:kotlin-runtimepermissions-coroutines.kt$suspend</ID>
    <ID>MaximumLineLength:kotlin-runtimepermissions.kt$fun</ID>
    <ID>MissingPackageDeclaration:BeaconComponent.kt$.BeaconComponent.kt</ID>
    <ID>MissingPackageDeclaration:BeaconModule.kt$.BeaconModule.kt</ID>
    <ID>MissingPackageDeclaration:ChainSyncIntegrationTest.kt$.ChainSyncIntegrationTest.kt</ID>
    <ID>MissingPackageDeclaration:ExperimentalComponent.kt$.ExperimentalComponent.kt</ID>
    <ID>MissingPackageDeclaration:ExperimentalModule.kt$.ExperimentalModule.kt</ID>
    <ID>MissingPackageDeclaration:ValidatorDetailsModule.kt$.ValidatorDetailsModule.kt</ID>
    <ID>NestedBlockDepth:AccountRepositoryImpl.kt$AccountRepositoryImpl$override suspend fun getChainAccountSecrets(metaId: Long?, chainId: ChainId): EncodableStruct&lt;ChainAccountSecrets&gt;?</ID>
    <ID>NestedBlockDepth:ChainAccountsAdapter.kt$ChainAccountHolder$fun bind( item: AccountInChainUi, handler: ChainAccountsAdapter.Handler, imageLoader: ImageLoader )</ID>
    <ID>NestedBlockDepth:CustomContributeFragment.kt$CustomContributeFragment$override fun initViews()</ID>
    <ID>NestedBlockDepth:EthereumDerivationPathTransformer.kt$EthereumDerivationPathTransformer$override fun afterTextChanged(s: Editable?)</ID>
    <ID>NestedBlockDepth:ExportExt.kt$fun &lt;T : Schema&lt;T&gt;&gt; EncodableStruct&lt;T&gt;?.buildMainAccountOptions( isEthereumBased: Boolean ): MutableSet&lt;ExportSource&gt;</ID>
    <ID>NestedBlockDepth:MnemonicContainerView.kt$MnemonicContainerView$override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int)</ID>
    <ID>NestedBlockDepth:OperationMappers.kt$suspend fun mapOperationToOperationModel( operation: Operation, nameIdentifier: AddressDisplayUseCase.Identifier, resourceManager: ResourceManager, iconGenerator: AddressIconGenerator ): OperationModel</ID>
    <ID>NestedBlockDepth:PolkaswapDisclaimerScreen.kt$@Composable fun TextWithLinks(state: TextWithHighlights, onLinkClick: (String) -&gt; Unit)</ID>
    <ID>NestedBlockDepth:SearchCustomBlockProducerInteractor.kt$SearchCustomBlockProducerInteractor$suspend fun getBlockProducerByAddress(query: String): BlockProducer?</ID>
    <ID>NestedBlockDepth:StakingAssetSelectorBottomSheet.kt$StakingAssetSelectorHolder$override fun bind( item: StakingAssetSelector.StakingAssetSelectorModel, isSelected: Boolean, handler: DynamicListSheetAdapter.Handler&lt;StakingAssetSelector.StakingAssetSelectorModel&gt; )</ID>
    <ID>NestedBlockDepth:StoryFragment.kt$StoryFragment$private fun handleStoryTouchEvent(view: View, event: MotionEvent): Boolean</ID>
    <ID>NestedBlockDepth:Toolbar.kt$Toolbar$fun addCustomAction(@DrawableRes icon: Int, onClick: OnClickListener)</ID>
    <ID>NestedBlockDepth:UnbondingsAdapter.kt$UnbondingsHolder$fun bind(unbonding: UnbondingModel)</ID>
    <ID>NestedBlockDepth:Validator.kt$fun mapValidatorDetailsToErrors( validator: ValidatorDetailsParcelModel ): List&lt;Error&gt;?</ID>
    <ID>NestedBlockDepth:Validator.kt$private fun mapValidatorToValidatorDetailsParcelModel( validator: Validator, nominationStatus: NominatedValidator.Status? ): ValidatorDetailsParcelModel</ID>
    <ID>NoBlankLineInList:AlertSheet.kt$ </ID>
    <ID>NoBlankLineInList:AssetListItem.kt$ </ID>
    <ID>NoBlankLineInList:AssetWithToken.kt$AssetWithToken$ </ID>
    <ID>NoBlankLineInList:AssetsOrderMigration.kt$AssetsOrderMigration.SortingModel$ </ID>
    <ID>NoBlankLineInList:ChainLocal.kt$ChainLocal.ExternalApi$ </ID>
    <ID>NoBlankLineInList:ErrorDialog.kt$ErrorDialog$ </ID>
    <ID>NoBlankLineInList:GetMoreXorContent.kt$ </ID>
    <ID>NoBlankLineInList:JoinedChainInfo.kt$JoinedChainInfo$ </ID>
    <ID>NoBlankLineInList:MetaAccountLocal.kt$RelationJoinedMetaAccountInfo$ </ID>
    <ID>NoBlankLineInList:NetworkIssueItem.kt$NetworkIssueItemState$ </ID>
    <ID>NoBlankLineInList:SelectWalletViewModel.kt$SelectWalletViewModel$ </ID>
    <ID>NoBlankLineInList:StakingUpdatersModule.kt$StakingUpdatersModule$ </ID>
    <ID>NoConsecutiveBlankLines:ChainSyncServiceTest.kt$ChainSyncServiceTest$ </ID>
    <ID>NoConsecutiveBlankLines:PredifinedRuntimeUpdater.kt$GetCurrentRuntime$ </ID>
    <ID>NoConsecutiveBlankLines:RuntimeSyncServiceTest.kt$RuntimeSyncServiceTest$ </ID>
    <ID>NoEmptyFirstLineInMethodBlock:SecretStoreV2Test.kt$SecretStoreV2Test$ </ID>
    <ID>NoMultipleSpaces:DaoTest.kt$DaoTest$ </ID>
    <ID>NoMultipleSpaces:FlowExtKtTest.kt$FlowExtKtTest$ </ID>
    <ID>NoMultipleSpaces:RuntimeProviderTest.kt$RuntimeProviderTest$ </ID>
    <ID>NoMultipleSpaces:StakingInteractorExtKtTest.kt$StakingInteractorExtKtTest$ </ID>
    <ID>NoSingleLineBlockComment:ImportRemoteWalletViewModel.kt$ImportRemoteWalletViewModel$/* ignore */</ID>
    <ID>NoWildcardImports:ExampleInstrumentedTest.kt$import org.junit.Assert.*</ID>
    <ID>NoWildcardImports:ExampleUnitTest.kt$import org.junit.Assert.*</ID>
    <ID>NotImplementedDeclaration:LocalStorageSource.kt$LocalStorageSource$throw NotImplementedError("Child state queries are not yet supported in local storage")</ID>
    <ID>OptionalUnit:BaseComposeBottomSheetDialogFragment.kt$BaseComposeBottomSheetDialogFragment$Unit</ID>
    <ID>OptionalUnit:BaseComposeFragment.kt$BaseComposeFragment$Unit</ID>
    <ID>OptionalUnit:ChainDaoTest.kt$ChainDaoTest$val chainsInitial = listOf( createTestChain("0x00"), createTestChain("0x01"), createTestChain("0x02"), ) dao.update(newOrUpdated = chainsInitial, removed = emptyList()) val newOrUpdated = listOf( createTestChain("0x00", "new name"), createTestChain("0x03") ) val removed = listOf( chainOf("0x01"), chainOf("0x02") ) dao.update(newOrUpdated = newOrUpdated, removed = removed) val chainsFromDb = dao.getJoinChainInfo() assertEquals(chainsFromDb.size, newOrUpdated.size) newOrUpdated.zip(chainsFromDb) { expected, actual -&gt; assertEquals(expected.chain.id, actual.chain.id) assertEquals(expected.chain.name, actual.chain.name) } Unit</ID>
    <ID>PackageNaming:AcalaContributeFactory.kt$package jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.acala</ID>
    <ID>PackageNaming:AcalaContributionModule.kt$package jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.acala</ID>
    <ID>PackageNaming:AccountSource.kt$package jp.co.soramitsu.account.api.presentation.accountSource</ID>
    <ID>PackageNaming:AlertBottomSheet.kt$package jp.co.soramitsu.common.view.bottomSheet</ID>
    <ID>PackageNaming:AssetSelectorFactory.kt$package jp.co.soramitsu.wallet.api.presentation.mixin.assetSelector</ID>
    <ID>PackageNaming:AssetSelectorMixin.kt$package jp.co.soramitsu.wallet.api.presentation.mixin.assetSelector</ID>
    <ID>PackageNaming:AssetSelectorUi.kt$package jp.co.soramitsu.wallet.api.presentation.mixin.assetSelector</ID>
    <ID>PackageNaming:AstarContributeFactory.kt$package jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.astar</ID>
    <ID>PackageNaming:AstarContributionModule.kt$package jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.astar</ID>
    <ID>PackageNaming:BifrostContributeFactory.kt$package jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.bifrost</ID>
    <ID>PackageNaming:BifrostContributionModule.kt$package jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.bifrost</ID>
    <ID>PackageNaming:BuyMixin.kt$package jp.co.soramitsu.wallet.impl.presentation.balance.assetActions.buy</ID>
    <ID>PackageNaming:BuyMixinProvider.kt$package jp.co.soramitsu.wallet.impl.presentation.balance.assetActions.buy</ID>
    <ID>PackageNaming:BuyProviderChooserBottomSheet.kt$package jp.co.soramitsu.wallet.impl.presentation.balance.assetActions.buy</ID>
    <ID>PackageNaming:Chain.kt$package jp.co.soramitsu.runtime.multiNetwork.chain.model</ID>
    <ID>PackageNaming:ChainAssetRemote.kt$package jp.co.soramitsu.runtime.multiNetwork.chain.remote.model</ID>
    <ID>PackageNaming:ChainEcosystem.kt$package jp.co.soramitsu.runtime.multiNetwork.chain</ID>
    <ID>PackageNaming:ChainExternalApiRemote.kt$package jp.co.soramitsu.runtime.multiNetwork.chain.remote.model</ID>
    <ID>PackageNaming:ChainFetcher.kt$package jp.co.soramitsu.runtime.multiNetwork.chain.remote</ID>
    <ID>PackageNaming:ChainInfoNotInCacheException.kt$package jp.co.soramitsu.runtime.multiNetwork.runtime</ID>
    <ID>PackageNaming:ChainNodeRemote.kt$package jp.co.soramitsu.runtime.multiNetwork.chain.remote.model</ID>
    <ID>PackageNaming:ChainRegistry.kt$package jp.co.soramitsu.runtime.multiNetwork</ID>
    <ID>PackageNaming:ChainRemote.kt$package jp.co.soramitsu.runtime.multiNetwork.chain.remote.model</ID>
    <ID>PackageNaming:ChainSyncService.kt$package jp.co.soramitsu.runtime.multiNetwork.chain</ID>
    <ID>PackageNaming:ChainSyncServiceTest.kt$package jp.co.soramitsu.runtime.multiNetwork.chain</ID>
    <ID>PackageNaming:ChainTypesInfo.kt$package jp.co.soramitsu.runtime.multiNetwork.chain.model</ID>
    <ID>PackageNaming:ChangeRewardDestinationInteractor.kt$package jp.co.soramitsu.staking.impl.domain.staking.rewardDestination</ID>
    <ID>PackageNaming:ConfirmRewardDestinationFragment.kt$package jp.co.soramitsu.staking.impl.presentation.staking.rewardDestination.confirm</ID>
    <ID>PackageNaming:ConfirmRewardDestinationPayload.kt$package jp.co.soramitsu.staking.impl.presentation.staking.rewardDestination.confirm.parcel</ID>
    <ID>PackageNaming:ConfirmRewardDestinationViewModel.kt$package jp.co.soramitsu.staking.impl.presentation.staking.rewardDestination.confirm</ID>
    <ID>PackageNaming:ConnectionPool.kt$package jp.co.soramitsu.runtime.multiNetwork.connection</ID>
    <ID>PackageNaming:CustomContributeFactory.kt$package jp.co.soramitsu.crowdloan.impl.di.customCrowdloan</ID>
    <ID>PackageNaming:CustomContributeManager.kt$package jp.co.soramitsu.crowdloan.impl.di.customCrowdloan</ID>
    <ID>PackageNaming:CustomContributeModule.kt$package jp.co.soramitsu.crowdloan.impl.di.customCrowdloan</ID>
    <ID>PackageNaming:Declarations.kt$package jp.co.soramitsu.staking.impl.domain.validations.rewardDestination</ID>
    <ID>PackageNaming:DynamicListBottomSheet.kt$package jp.co.soramitsu.common.view.bottomSheet.list.dynamic</ID>
    <ID>PackageNaming:DynamicListSheetAdapter.kt$package jp.co.soramitsu.common.view.bottomSheet.list.dynamic</ID>
    <ID>PackageNaming:ExternalProvider.kt$package jp.co.soramitsu.wallet.impl.data.buyToken</ID>
    <ID>PackageNaming:FileHash.kt$package jp.co.soramitsu.runtime.multiNetwork.runtime</ID>
    <ID>PackageNaming:FixedListBottomSheet.kt$package jp.co.soramitsu.common.view.bottomSheet.list.fixed</ID>
    <ID>PackageNaming:GiantsquidHistorySource.kt$package jp.co.soramitsu.wallet.impl.data.historySource</ID>
    <ID>PackageNaming:HistorySource.kt$package jp.co.soramitsu.wallet.impl.data.historySource</ID>
    <ID>PackageNaming:HistorySourceProvider.kt$package jp.co.soramitsu.wallet.impl.data.historySource</ID>
    <ID>PackageNaming:InterlayContributeFactory.kt$package jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.interlay</ID>
    <ID>PackageNaming:InterlayContributionModule.kt$package jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.interlay</ID>
    <ID>PackageNaming:KaruraContributeFactory.kt$package jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.karura</ID>
    <ID>PackageNaming:KaruraContributionModule.kt$package jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.karura</ID>
    <ID>PackageNaming:LockBottomSheetBehavior.kt$package jp.co.soramitsu.common.view.bottomSheet</ID>
    <ID>PackageNaming:Mappers.kt$package jp.co.soramitsu.runtime.multiNetwork.chain</ID>
    <ID>PackageNaming:Mocks.kt$package jp.co.soramitsu.runtime.multiNetwork.runtime</ID>
    <ID>PackageNaming:MoonPayProvider.kt$package jp.co.soramitsu.wallet.impl.data.buyToken</ID>
    <ID>PackageNaming:MoonbeamContributeFactory.kt$package jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.moonbeam</ID>
    <ID>PackageNaming:MoonbeamContributionModule.kt$package jp.co.soramitsu.crowdloan.impl.di.customCrowdloan.moonbeam</ID>
    <ID>PackageNaming:NodeId.kt$package jp.co.soramitsu.runtime.multiNetwork.chain.model</ID>
    <ID>PackageNaming:ObserveRewardDestinationChooser.kt$package jp.co.soramitsu.staking.impl.presentation.common.rewardDestination</ID>
    <ID>PackageNaming:QrScannerActivity.kt$package jp.co.soramitsu.common.qrScanner</ID>
    <ID>PackageNaming:RampProvider.kt$package jp.co.soramitsu.wallet.impl.data.buyToken</ID>
    <ID>PackageNaming:RewardDestinationEstimations.kt$package jp.co.soramitsu.staking.impl.presentation.common.rewardDestination</ID>
    <ID>PackageNaming:RewardDestinationMixin.kt$package jp.co.soramitsu.staking.impl.presentation.common.rewardDestination</ID>
    <ID>PackageNaming:RewardDestinationModel.kt$package jp.co.soramitsu.staking.impl.presentation.common.rewardDestination</ID>
    <ID>PackageNaming:RewardDestinationParcelModel.kt$package jp.co.soramitsu.staking.impl.presentation.staking.rewardDestination.confirm.parcel</ID>
    <ID>PackageNaming:RewardDestinationProvider.kt$package jp.co.soramitsu.staking.impl.presentation.common.rewardDestination</ID>
    <ID>PackageNaming:RewardDestinationValidationFailure.kt$package jp.co.soramitsu.staking.impl.domain.validations.rewardDestination</ID>
    <ID>PackageNaming:RewardDestinationValidationFailure.kt$package jp.co.soramitsu.staking.impl.presentation.staking.rewardDestination.select</ID>
    <ID>PackageNaming:RewardDestinationValidationPayload.kt$package jp.co.soramitsu.staking.impl.domain.validations.rewardDestination</ID>
    <ID>PackageNaming:RuntimeFilesCache.kt$package jp.co.soramitsu.runtime.multiNetwork.runtime</ID>
    <ID>PackageNaming:RuntimeProvider.kt$package jp.co.soramitsu.runtime.multiNetwork.runtime</ID>
    <ID>PackageNaming:RuntimeProviderPool.kt$package jp.co.soramitsu.runtime.multiNetwork.runtime</ID>
    <ID>PackageNaming:RuntimeProviderTest.kt$package jp.co.soramitsu.runtime.multiNetwork.runtime</ID>
    <ID>PackageNaming:RuntimeSubscriptionPool.kt$package jp.co.soramitsu.runtime.multiNetwork.runtime</ID>
    <ID>PackageNaming:RuntimeSyncService.kt$package jp.co.soramitsu.runtime.multiNetwork.runtime</ID>
    <ID>PackageNaming:RuntimeSyncServiceTest.kt$package jp.co.soramitsu.runtime.multiNetwork.runtime</ID>
    <ID>PackageNaming:RuntimeVersionSubscription.kt$package jp.co.soramitsu.runtime.multiNetwork.runtime</ID>
    <ID>PackageNaming:SearchAssetState.kt$package jp.co.soramitsu.wallet.impl.presentation.balance.searchAssets</ID>
    <ID>PackageNaming:SearchAssetsFragment.kt$package jp.co.soramitsu.wallet.impl.presentation.balance.searchAssets</ID>
    <ID>PackageNaming:SearchAssetsScreen.kt$package jp.co.soramitsu.wallet.impl.presentation.balance.searchAssets</ID>
    <ID>PackageNaming:SearchAssetsViewModel.kt$package jp.co.soramitsu.wallet.impl.presentation.balance.searchAssets</ID>
    <ID>PackageNaming:SelectRewardDestinationFragment.kt$package jp.co.soramitsu.staking.impl.presentation.staking.rewardDestination.select</ID>
    <ID>PackageNaming:SelectRewardDestinationViewModel.kt$package jp.co.soramitsu.staking.impl.presentation.staking.rewardDestination.select</ID>
    <ID>PackageNaming:SoraHistorySource.kt$package jp.co.soramitsu.wallet.impl.data.historySource</ID>
    <ID>PackageNaming:SourceTypeChooserBottomSheetDialog.kt$package jp.co.soramitsu.account.api.presentation.accountSource</ID>
    <ID>PackageNaming:SubqueryHistorySource.kt$package jp.co.soramitsu.wallet.impl.data.historySource</ID>
    <ID>PackageNaming:SubscribeRuntimeVersionRequest.kt$package jp.co.soramitsu.runtime.multiNetwork.runtime</ID>
    <ID>PackageNaming:SubsquidHistorySource.kt$package jp.co.soramitsu.wallet.impl.data.historySource</ID>
    <ID>PackageNaming:TypesFetcher.kt$package jp.co.soramitsu.runtime.multiNetwork.runtime.types</ID>
    <ID>ParameterListWrapping:AcalaContributeInteractor.kt$AcalaContributeInteractor$(payload: AcalaBonusPayload, amount: BigDecimal, apiUrl: String, apiKey: String)</ID>
    <ID>ParameterListWrapping:AcalaContributeSubmitter.kt$AcalaContributeSubmitter$(payload: BonusPayload, amount: BigDecimal, metadata: ParachainMetadataParcelModel?)</ID>
    <ID>ParameterListWrapping:AddressIconGenerator.kt$(accountAddress: String, sizeInDp: Int, accountName: String? = null)</ID>
    <ID>ParameterListWrapping:AmountInput.kt$AmountInputViewState.Companion$(resourceManager: ResourceManager, @StringRes totalBalanceFormat: Int = R.string.common_balance_format)</ID>
    <ID>ParameterListWrapping:AssetsList.kt$AssetsListInterface$(actionType: ActionItemType, chainId: ChainId, chainAssetId: String, swipeableState: SwipeableState&lt;SwipeState&gt;)</ID>
    <ID>ParameterListWrapping:BalanceDetailsScreen.kt$(ActionItemType, String, String)</ID>
    <ID>ParameterListWrapping:BalanceDetailsScreen.kt$(actionBarLoadingState: LoadingState&lt;ActionBarViewState&gt;, actionItemClicked: (ActionItemType, String, String) -&gt; Unit)</ID>
    <ID>ParameterListWrapping:BalanceListViewModel.kt$BalanceListViewModel$(actionType: ActionItemType, chainId: ChainId, chainAssetId: String, swipeableState: SwipeableState&lt;SwipeState&gt;)</ID>
    <ID>ParameterListWrapping:BottomSheetScreen.kt$(modifier: Modifier = Modifier, verticalArrangement: Arrangement.Vertical = Arrangement.Top, Content: @Composable ColumnScope.() -&gt; Unit)</ID>
    <ID>ParameterListWrapping:ConfirmCreatePoolViewModel.kt$(poolSharedStateProvider: StakingPoolSharedStateProvider, address: String)</ID>
    <ID>ParameterListWrapping:CurrentAccountAddressUseCase.kt$CurrentAccountAddressUseCase$(private val accountRepository: AccountRepository, private val chainRegistry: ChainRegistry)</ID>
    <ID>ParameterListWrapping:CustomBlockProducersAdapter.kt$BlockProducerViewHolder$(Int)</ID>
    <ID>ParameterListWrapping:CustomBlockProducersAdapter.kt$BlockProducerViewHolder$(private val binding: ItemBlockProducerSearchBinding, infoClicked: (Int) -&gt; Unit, selected: (Int) -&gt; Unit)</ID>
    <ID>ParameterListWrapping:DelegationRecyclerViewAdapter.kt$DelegationDiffCallback$(oldItem: DelegatorViewState.CollatorDelegationModel, newItem: DelegatorViewState.CollatorDelegationModel)</ID>
    <ID>ParameterListWrapping:DelegationRecyclerViewAdapter.kt$DelegationViewHolder$(item: DelegatorViewState.CollatorDelegationModel, itemHandler: DelegationRecyclerViewAdapter.DelegationHandler)</ID>
    <ID>ParameterListWrapping:DragAndDropTouchHelperCallback.kt$DragAndDropTouchHelperCallback$(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder)</ID>
    <ID>ParameterListWrapping:EncryptionTypeChooserBottomSheetDialog.kt$EncryptionTypeViewHolder$(item: CryptoTypeModel, isSelected: Boolean, handler: DynamicListSheetAdapter.Handler&lt;CryptoTypeModel&gt;)</ID>
    <ID>ParameterListWrapping:Extensions.kt$(key: K, map: Map&lt;out K, MutableStateFlow&lt;Boolean&gt;&gt;, lifecycleScope: LifecycleCoroutineScope)</ID>
    <ID>ParameterListWrapping:ExtrinsicBuilderExt.kt$(amount: BigInteger, root: MultiAddress, nominator: MultiAddress, stateToggler: MultiAddress)</ID>
    <ID>ParameterListWrapping:ExtrinsicBuilderExt.kt$(memberAccountId: AccountId, numSlashingSpans: BigInteger = BigInteger.ZERO)</ID>
    <ID>ParameterListWrapping:ExtrinsicBuilderExt.kt$(memberAccountId: MultiAddress, numSlashingSpans: BigInteger = BigInteger.ZERO)</ID>
    <ID>ParameterListWrapping:MoonbeamContributeInteractor.kt$MoonbeamContributeInteractor$(apiUrl: String, apiKey: String, contribution: BigInteger, paraId: ParaId, chainId: ChainId)</ID>
    <ID>ParameterListWrapping:ProfileModule.kt$ProfileModule$(accountRepository: AccountRepository, chainRegistry: ChainRegistry, assetDao: AssetDao)</ID>
    <ID>ParameterListWrapping:RuntimeProviderTest.kt$RuntimeProviderTest$(exception: Exception = ChainInfoNotInCacheException, block: suspend () -&gt; Unit)</ID>
    <ID>ParameterListWrapping:SearchAssetsScreen.kt$&lt;no name provided&gt;$(actionType: ActionItemType, chainId: ChainId, chainAssetId: String, swipeableState: SwipeableState&lt;SwipeState&gt;)</ID>
    <ID>ParameterListWrapping:SearchAssetsViewModel.kt$SearchAssetsViewModel$(actionType: ActionItemType, chainId: ChainId, chainAssetId: String, swipeableState: SwipeableState&lt;SwipeState&gt;)</ID>
    <ID>ParameterListWrapping:SearchBlockProducerModel.kt$SearchBlockProducerModel$(val name: String, val address: String, val selected: Boolean, val rewardsPercent: String, val image: PictureDrawable)</ID>
    <ID>ParameterListWrapping:SearchCustomBlockProducerInteractor.kt$SearchCustomBlockProducerInteractor$(address: String, setupStakingProcess: SetupStakingSharedState, lifecycle: Lifecycle)</ID>
    <ID>ParameterListWrapping:SearchCustomBlockProducerInteractor.kt$SearchCustomBlockProducerInteractor.BlockProducer$(val name: String, val address: String, val rewardsPercent: String, val selected: Boolean = false)</ID>
    <ID>ParameterListWrapping:SecretStoreV2.kt$SecretStoreV2$(metaId: Long, accountId: ByteArray, secrets: EncodableStruct&lt;ChainAccountSecrets&gt;)</ID>
    <ID>ParameterListWrapping:SoraCardInteractorImpl.kt$SoraCardInteractorImpl$(accessToken: String, refreshToken: String, accessTokenExpirationTime: Long, kycStatus: String)</ID>
    <ID>ParameterListWrapping:SoraStakingRewardsScenario.kt$SoraStakingRewardsScenario$(private val rpcCalls: RpcCalls, private val chainRegistry: ChainRegistry, private val tokenDao: TokenPriceDao)</ID>
    <ID>ParameterListWrapping:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$(currentRound: Round, currentBlock: BlockNumber, roundNumber: BigInteger, hoursInRound: Int)</ID>
    <ID>ParameterListWrapping:StakingPoolInteractor.kt$StakingPoolInteractor$(chain: Chain, poolMember: PoolMember, bondedPool: BondedPool, rewardPool: PoolRewards?)</ID>
    <ID>ParameterListWrapping:StakingPoolInteractor.kt$StakingPoolInteractor$(poolMember: PoolMember, redeemable: BigInteger, unbonding: BigInteger, pendingRewards: BigInteger)</ID>
    <ID>ParameterListWrapping:StakingViewModel.kt$StakingViewModel$(type: StakingType)</ID>
    <ID>ParameterListWrapping:SwipeableAssetListItem.kt$(actionType: ActionItemType, chainId: ChainId, chainAssetId: String, swipeableState: SwipeableState&lt;SwipeState&gt;)</ID>
    <ID>ParameterListWrapping:ValidateTransferUseCase.kt$(result: TransferValidationResult, resourceManager: ResourceManager)</ID>
    <ID>ParameterListWrapping:WalletRepositoryImpl.kt$WalletRepositoryImpl$(metaId: Long, accountId: AccountId, chainAsset: CoreAsset, minSupportedVersion: String?)</ID>
    <ID>ParameterListWrapping:WalletScreen.kt$&lt;no name provided&gt;$(actionType: ActionItemType, chainId: ChainId, chainAssetId: String, swipeableState: SwipeableState&lt;SwipeState&gt;)</ID>
    <ID>ParameterWrapping:SwipeableAssetListItem.kt$actionItemClicked: (actionType: ActionItemType, chainId: ChainId, chainAssetId: String, swipeableState: SwipeableState&lt;SwipeState&gt;) -&gt; Unit</ID>
    <ID>PrintStackTrace:EncryptionUtil.kt$EncryptionUtil$e</ID>
    <ID>ProtectedMemberInFinalClass:BalanceListFragment.kt$BalanceListFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:ConfirmBondMoreFragment.kt$ConfirmBondMoreFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:ConfirmContributeFragment.kt$ConfirmContributeFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:ConfirmRebondFragment.kt$ConfirmRebondFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:ConfirmStakingFragment.kt$ConfirmStakingFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:ConfirmUnbondFragment.kt$ConfirmUnbondFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:CrowdloanContributeFragment.kt$CrowdloanContributeFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:CrowdloanFragment.kt$CrowdloanFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:CustomContributeFragment.kt$CustomContributeFragment$@Inject protected lateinit var contributionManager: CustomContributeManager</ID>
    <ID>ProtectedMemberInFinalClass:CustomContributeFragment.kt$CustomContributeFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:CustomRebondFragment.kt$CustomRebondFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:ExportJsonPasswordFragment.kt$ExportJsonPasswordFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:ProfileFragment.kt$ProfileFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:RedeemFragment.kt$RedeemFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:SelectBondMoreFragment.kt$SelectBondMoreFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:SelectUnbondFragment.kt$SelectUnbondFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:SetupStakingFragment.kt$SetupStakingFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ProtectedMemberInFinalClass:StakingFragment.kt$StakingFragment$@Inject protected lateinit var imageLoader: ImageLoader</ID>
    <ID>ReturnCount:CrossChainSetupViewModel.kt$CrossChainSetupViewModel$private suspend fun buildTransferDraft(): CrossChainTransferDraft?</ID>
    <ID>ReturnCount:ExistentialDepositUseCaseImpl.kt$ExistentialDepositUseCaseImpl$private fun getExistentialDepositRpcArgument(asset: Asset): Pair&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:Exposure.kt$@UseCaseBinding fun bindExposure(scale: String, runtime: RuntimeSnapshot, type: Type&lt;*&gt;): Exposure?</ID>
    <ID>ReturnCount:NumberInput.kt$private fun processNewInputState( state: TextFieldValue, previousState: TextFieldValue, bigDecimalRegexPattern: Regex ): TextFieldValue</ID>
    <ID>ReturnCount:PolkaswapInteractorImpl.kt$PolkaswapInteractorImpl$override suspend fun calcDetails( availableDexPaths: List&lt;Int&gt;, tokenFrom: Asset, tokenTo: Asset, amount: BigDecimal, desired: WithDesired, slippageTolerance: Double, market: Market ): Result&lt;SwapDetails?&gt;</ID>
    <ID>ReturnCount:StakingInteractor.kt$StakingInteractor$suspend fun checkControllerDeprecations(metaAccount: MetaAccount, chain: Chain): ControllerDeprecationWarning?</ID>
    <ID>ReturnCount:SwapTokensViewModel.kt$SwapTokensViewModel$@Suppress("UNUSED_PARAMETER") private suspend fun getSwapDetails( amount: BigDecimal, selectedMarket: Market, slippageTolerance: Double, availableDexPaths: List&lt;Int&gt;?, reserves: Any ): Result&lt;SwapDetails?&gt;</ID>
    <ID>SpacingAroundColon:Common.kt$NoOpLogger$:</ID>
    <ID>SpacingAroundColon:Mocks.kt$Mocks$:</ID>
    <ID>SpacingAroundColon:V2MigrationTest.kt$V2MigrationTest$:</ID>
    <ID>SpacingAroundCurly:ChainDaoTest.kt$ChainDaoTest${</ID>
    <ID>SpacingAroundKeyword:V2MigrationTest.kt$V2MigrationTest$when</ID>
    <ID>SpacingAroundOperators:SecretStoreV2Test.kt$SecretStoreV2Test$=</ID>
    <ID>SpacingAroundOperators:V2MigrationTest.kt$V2MigrationTest$=</ID>
    <ID>SpacingAroundParens:SecretStoreV2Test.kt$SecretStoreV2Test$(</ID>
    <ID>SpacingBetweenDeclarationsWithAnnotations:PredifinedRuntimeUpdater.kt$GetCurrentRuntime$@Test fun getRococoWestedRuntime()</ID>
    <ID>SpreadOperator:ConfirmSelectValidatorsViewModel.kt$ConfirmSelectValidatorsViewModel$(poolId, *validators)</ID>
    <ID>SpreadOperator:ConfirmSelectValidatorsViewModel.kt$ConfirmSelectValidatorsViewModel$(poolId, address, *validators)</ID>
    <ID>SpreadOperator:PolkaswapInteractorImpl.kt$PolkaswapInteractorImpl$(Market.SMART, *it.value.toTypedArray())</ID>
    <ID>SpreadOperator:SubqueryExpressions.kt$SubqueryExpressions$(*innerExpressions.toTypedArray())</ID>
    <ID>SpreadOperator:WalletRepositoryImpl.kt$WalletRepositoryImpl$(*priceIds.toTypedArray(), currencyId = currencyId)</ID>
    <ID>StringTemplate:Helpers.kt$${it}</ID>
    <ID>SwallowedException:AccountDetailsFragment.kt$AccountDetailsFragment$e: ActivityNotFoundException</ID>
    <ID>SwallowedException:AccountRepositoryImpl.kt$AccountRepositoryImpl$e: SQLiteConstraintException</ID>
    <ID>SwallowedException:AddNodeViewModel.kt$AddNodeViewModel$timeout: TimeoutCancellationException</ID>
    <ID>SwallowedException:BalanceListFragment.kt$BalanceListFragment$e: ActivityNotFoundException</ID>
    <ID>SwallowedException:BeaconInteractor.kt$BeaconInteractor$e: Exception</ID>
    <ID>SwallowedException:CrowdloanStorage.kt$CrowdloanStorage$e: Exception</ID>
    <ID>SwallowedException:GetSoraCardViewModel.kt$GetSoraCardViewModel$e: Exception</ID>
    <ID>SwallowedException:GiantsquidHistorySource.kt$GiantsquidHistorySource$e: Exception</ID>
    <ID>SwallowedException:NodesSettingsScenarioImpl.kt$NodesSettingsScenarioImpl$e: SQLiteConstraintException</ID>
    <ID>SwallowedException:RootActivity.kt$RootActivity$e: ActivityNotFoundException</ID>
    <ID>SwallowedException:SearchAssetsFragment.kt$SearchAssetsFragment$e: ActivityNotFoundException</ID>
    <ID>SwallowedException:SignBeaconTransactionViewModel.kt$SignBeaconTransactionViewModel$e: Exception</ID>
    <ID>SwallowedException:SingleAssetSharedState.kt$SingleAssetSharedState$e: NoSuchElementException</ID>
    <ID>SwallowedException:StakingPoolApi.kt$StakingPoolApi$e: Exception</ID>
    <ID>SwallowedException:StakingRelayChainScenarioRepository.kt$StakingRelayChainScenarioRepository$e: Exception</ID>
    <ID>SwallowedException:Unbonding.kt$e: Exception</ID>
    <ID>SwallowedException:WalletRepositoryImpl.kt$WalletRepositoryImpl$e: Exception</ID>
    <ID>SwallowedException:WebSocket.kt$WebSocket$e: Exception</ID>
    <ID>ThrowingExceptionsWithoutMessageOrCause:AccountControllerBalanceUpdater.kt$AccountControllerBalanceUpdater$IllegalArgumentException()</ID>
    <ID>ThrowingExceptionsWithoutMessageOrCause:AlertFragment.kt$AlertFragment$Exception()</ID>
    <ID>ThrowingExceptionsWithoutMessageOrCause:PoolFullUnstakeDepositorAlertFragment.kt$PoolFullUnstakeDepositorAlertFragment$Exception()</ID>
    <ID>ThrowsCount:RuntimeProvider.kt$RuntimeProvider$private fun constructNewRuntime()</ID>
    <ID>TooGenericExceptionCaught:AddNodeViewModel.kt$AddNodeViewModel$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BeaconInteractor.kt$BeaconInteractor$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CrowdloanContributeInteractor.kt$CrowdloanContributeInteractor$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:CrowdloanRepositoryImpl.kt$CrowdloanRepositoryImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CrowdloanStorage.kt$CrowdloanStorage$e: Exception</ID>
    <ID>TooGenericExceptionCaught:EncryptionUtil.kt$EncryptionUtil$e: Exception</ID>
    <ID>TooGenericExceptionCaught:GetSoraCardViewModel.kt$GetSoraCardViewModel$e: Exception</ID>
    <ID>TooGenericExceptionCaught:GiantsquidHistorySource.kt$GiantsquidHistorySource$e: Exception</ID>
    <ID>TooGenericExceptionCaught:HttpExceptionHandler.kt$HttpExceptionHandler$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:SignBeaconTransactionViewModel.kt$SignBeaconTransactionViewModel$e: Exception</ID>
    <ID>TooGenericExceptionCaught:SocketSingleRequestExecutor.kt$SocketSingleRequestExecutor$e: Exception</ID>
    <ID>TooGenericExceptionCaught:StakingPoolApi.kt$StakingPoolApi$e: Exception</ID>
    <ID>TooGenericExceptionCaught:StakingRelayChainScenarioRepository.kt$StakingRelayChainScenarioRepository$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Unbonding.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ViewModelProviderFactory.kt$ViewModelProviderFactory$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WalletRepositoryImpl.kt$WalletRepositoryImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WebSocket.kt$WebSocket$e: Exception</ID>
    <ID>TooGenericExceptionThrown:AcalaContributeInteractor.kt$AcalaContributeInteractor$throw Exception("Asset not specified")</ID>
    <ID>TooGenericExceptionThrown:SubQueryDelegationHistoryFetcher.kt$SubQueryDelegationHistoryFetcher$throw Exception("Staking for this network is not supported yet")</ID>
    <ID>TooGenericExceptionThrown:SubqueryRewardCalculator.kt$SubqueryRewardCalculator$throw Exception("Staking for this network is not supported yet")</ID>
    <ID>TooGenericExceptionThrown:ViewModelProviderFactory.kt$ViewModelProviderFactory$throw RuntimeException(e)</ID>
    <ID>TopLevelPropertyNaming:AccountDataMigration.kt$private const val PREFS_DERIVATION_MASK = "derivation_%s"</ID>
    <ID>TopLevelPropertyNaming:AccountDataMigration.kt$private const val PREFS_ENTROPY_MASK = "entropy_%s"</ID>
    <ID>TopLevelPropertyNaming:AccountDataMigration.kt$private const val PREFS_MIGRATED_FROM_0_4_1_TO_1_0_0 = "migrated_from_0_4_1_to_1_0_0"</ID>
    <ID>TopLevelPropertyNaming:AccountDataMigration.kt$private const val PREFS_PRIVATE_KEY = "private_%s"</ID>
    <ID>TopLevelPropertyNaming:AccountDataMigration.kt$private const val PREFS_SEED_MASK = "seed_%s"</ID>
    <ID>TopLevelPropertyNaming:AccountDataSourceImpl.kt$private const val PREFS_AUTH_TYPE = "auth_type"</ID>
    <ID>TopLevelPropertyNaming:AccountDataSourceImpl.kt$private const val PREFS_PIN_CODE = "pin_code"</ID>
    <ID>TopLevelPropertyNaming:AccountDataSourceImpl.kt$private const val PREFS_SELECTED_ACCOUNT = "selected_address"</ID>
    <ID>TopLevelPropertyNaming:AccountDetailsFragment.kt$const val ACCOUNT_ID_KEY = "ACCOUNT_ADDRESS_KEY"</ID>
    <ID>TopLevelPropertyNaming:AccountDetailsViewModel.kt$private const val UPDATE_NAME_INTERVAL_SECONDS = 1L</ID>
    <ID>TopLevelPropertyNaming:AccountStakingDao.kt$private const val SELECT_QUERY = """ SELECT * FROM account_staking_accesses WHERE accountId = :accountId AND chainId = :chainId AND chainAssetId = :chainAssetId """</ID>
    <ID>TopLevelPropertyNaming:AccountsForExportFragment.kt$const val PAYLOAD_KEY = "PAYLOAD_KEY"</ID>
    <ID>TopLevelPropertyNaming:AlertFragment.kt$const val emptyResultKey = ""</ID>
    <ID>TopLevelPropertyNaming:AlertsInteractor.kt$private const val NOMINATIONS_ACTIVE_MEMO = "NOMINATIONS_ACTIVE_MEMO"</ID>
    <ID>TopLevelPropertyNaming:AssetChainsBadge.kt$private const val MAX_VISIBLE_ICONS = 5</ID>
    <ID>TopLevelPropertyNaming:AssetDao.kt$private const val RETRIEVE_ACCOUNT_ASSETS_QUERY = """ SELECT a.*, tp.* FROM assets AS a LEFT JOIN token_price AS tp ON a.tokenPriceId = tp.priceId LEFT JOIN chain_accounts AS ca ON ca.metaId = a.metaId AND ca.chainId = a.chainId WHERE a.metaId = :metaId AND (ca.accountId = a.accountId OR ca.accountId IS NULL) ORDER BY a.sortIndex """</ID>
    <ID>TopLevelPropertyNaming:AssetDao.kt$private const val RETRIEVE_ASSETS_SQL_SYMBOL = """ SELECT a.*, tp.* FROM assets AS a LEFT JOIN token_price AS tp ON a.tokenPriceId = tp.priceId LEFT JOIN chain_assets ca ON ca.id = a.id AND ca.chainId = a.chainId WHERE a.accountId IN (:accountId, :emptyAccountId) AND a.chainId = :chainId AND ca.symbol = :symbol AND a.metaId = :metaId ORDER BY a.sortIndex """</ID>
    <ID>TopLevelPropertyNaming:AssetDao.kt$private const val RETRIEVE_ASSET_SQL_ACCOUNT_ID = """ SELECT * FROM assets AS a LEFT JOIN token_price AS tp ON a.tokenPriceId = tp.priceId WHERE a.accountId IN (:accountId, :emptyAccountId) AND a.chainId = :chainId AND a.id = :assetId AND a.metaId = :metaId ORDER BY a.sortIndex """</ID>
    <ID>TopLevelPropertyNaming:BalanceDetailFragment.kt$const val KEY_ASSET_PAYLOAD = "KEY_ASSET_PAYLOAD"</ID>
    <ID>TopLevelPropertyNaming:BalanceListViewModel.kt$private const val CURRENT_ICON_SIZE = 40</ID>
    <ID>TopLevelPropertyNaming:BeaconFragment.kt$const val QR_CONTENT_KEY = "QR_CONTENT_KEY"</ID>
    <ID>TopLevelPropertyNaming:BeaconSharedState.kt$private const val BEACON_SHARED_STATE = "BEACON_SHARED_STATE"</ID>
    <ID>TopLevelPropertyNaming:BifrostBonusPayload.kt$val BIFROST_BONUS_MULTIPLIER = 0.05.toBigDecimal() // 5%</ID>
    <ID>TopLevelPropertyNaming:BindRewardDestination.kt$private const val TYPE_ACCOUNT = "Account"</ID>
    <ID>TopLevelPropertyNaming:BindRewardDestination.kt$private const val TYPE_STAKED = "Staked"</ID>
    <ID>TopLevelPropertyNaming:BulkRetriever.kt$private const val DEFAULT_PAGE_SIZE = 1000</ID>
    <ID>TopLevelPropertyNaming:Button.kt$private const val DISABLE_CLICK_TIME = 1000L</ID>
    <ID>TopLevelPropertyNaming:Chain.kt$const val genshiroChainId = "9b8cefc0eb5c568b527998bdd76c184e2b76ae561be76e4667072230217ea243"</ID>
    <ID>TopLevelPropertyNaming:Chain.kt$const val kusamaChainId = "b0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe"</ID>
    <ID>TopLevelPropertyNaming:Chain.kt$const val moonriverChainId = "401a1f9dca3da46f5c4091016c8a2f26dcea05865116b286f60f668207d1474b"</ID>
    <ID>TopLevelPropertyNaming:Chain.kt$const val polkadotChainId = "91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3"</ID>
    <ID>TopLevelPropertyNaming:Chain.kt$const val rococoChainId = "aaf2cd1b74b5f726895921259421b534124726263982522174147046b8827897"</ID>
    <ID>TopLevelPropertyNaming:Chain.kt$const val soraKusamaChainId = "6d8d9f145c2177fa83512492cdd80a71e29f22473f4a8943a6292149ac319fb9"</ID>
    <ID>TopLevelPropertyNaming:Chain.kt$const val soraMainChainId = "7e4e32d0feafd4f9c9414b0be86373f9a1efa904809b683453a9af6856d38ad5"</ID>
    <ID>TopLevelPropertyNaming:Chain.kt$const val soraTestChainId = "3266816be9fa51b32cfea58d3e33ca77246bc9618595a4300e44c8856a8d8a17"</ID>
    <ID>TopLevelPropertyNaming:Chain.kt$const val ternoaChainId = "6859c81ca95ef624c9dfe4dc6e3381c33e5d6509e35e147092bfbc780f777c4e"</ID>
    <ID>TopLevelPropertyNaming:Chain.kt$const val westendChainId = "e143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e"</ID>
    <ID>TopLevelPropertyNaming:ChildStateKey.kt$private const val CHILD_KEY_DEFAULT = ":child_storage:default:"</ID>
    <ID>TopLevelPropertyNaming:CollatorRecommendatorFactory.kt$private const val ELECTED_COLLATORS_CACHE = "ELECTED_COLLATORS_CACHE"</ID>
    <ID>TopLevelPropertyNaming:CommonModule.kt$const val SHARED_PREFERENCES_FILE = "fearless_prefs"</ID>
    <ID>TopLevelPropertyNaming:ConfirmBondMoreFragment.kt$const val PAYLOAD_KEY = "PAYLOAD_KEY"</ID>
    <ID>TopLevelPropertyNaming:ConfirmContributeFragment.kt$const val KEY_PAYLOAD = "KEY_PAYLOAD"</ID>
    <ID>TopLevelPropertyNaming:ConfirmRewardDestinationFragment.kt$const val KEY_PAYLOAD = "KEY_PAYLOAD"</ID>
    <ID>TopLevelPropertyNaming:ConfirmSendViewModel.kt$private const val ICON_IN_DP = 24</ID>
    <ID>TopLevelPropertyNaming:ConfirmSetControllerFragment.kt$const val PAYLOAD_KEY = "PAYLOAD_KEY"</ID>
    <ID>TopLevelPropertyNaming:ConfirmUnbondFragment.kt$const val PAYLOAD_KEY = "PAYLOAD_KEY"</ID>
    <ID>TopLevelPropertyNaming:CrossChainConfirmViewModel.kt$private const val ICON_IN_DP = 24</ID>
    <ID>TopLevelPropertyNaming:CrossChainSetupViewModel.kt$private const val CURRENT_ICON_SIZE = 16</ID>
    <ID>TopLevelPropertyNaming:CrossChainSetupViewModel.kt$private const val SLIPPAGE_TOLERANCE = 1.35</ID>
    <ID>TopLevelPropertyNaming:CrowdloanContributeFragment.kt$const val KEY_PAYLOAD = "KEY_PAYLOAD"</ID>
    <ID>TopLevelPropertyNaming:CrowdloanContributeViewModel.kt$private const val DEBOUNCE_DURATION_MILLIS = 500</ID>
    <ID>TopLevelPropertyNaming:CrowdloanRepositoryImpl.kt$private const val CONTRIBUTIONS_CHILD_SUFFIX = "crowdloan"</ID>
    <ID>TopLevelPropertyNaming:CrowdloanSharedState.kt$private const val CROWDLOAN_SHARED_STATE = "CROWDLOAN_SHARED_STATE"</ID>
    <ID>TopLevelPropertyNaming:CrowdloanStorage.kt$private const val MOONBEAM_ETHERNET_ADDRESS = "MOONBEAM_ETHERNET_ADDRESS"</ID>
    <ID>TopLevelPropertyNaming:CrowdloanViewModel.kt$private const val ICON_SIZE_DP = 40</ID>
    <ID>TopLevelPropertyNaming:CustomContributeFragment.kt$const val KEY_PAYLOAD = "KEY_PAYLOAD"</ID>
    <ID>TopLevelPropertyNaming:CustomRebondViewModel.kt$private const val DEBOUNCE_DURATION_MILLIS = 500</ID>
    <ID>TopLevelPropertyNaming:CustomRebondViewModel.kt$private const val DEFAULT_AMOUNT = 1</ID>
    <ID>TopLevelPropertyNaming:ExtrinsicDetailViewModel.kt$private const val ICON_SIZE_DP = 32</ID>
    <ID>TopLevelPropertyNaming:FearlessLibExt.kt$private const val HEX_SYMBOLS_PER_BYTE = 2</ID>
    <ID>TopLevelPropertyNaming:FearlessLibExt.kt$private const val UINT_32_BYTES = 4</ID>
    <ID>TopLevelPropertyNaming:FearlessLibExt.kt$private const val UINT_64_BYTES = 8</ID>
    <ID>TopLevelPropertyNaming:FearlessLibExt.kt$val BIP32JunctionDecoder.DEFAULT_DERIVATION_PATH: String get() = "//44//60//0/0/0"</ID>
    <ID>TopLevelPropertyNaming:FrozenTokensFragment.kt$const val FROZEN_ASSET_PAYLOAD = "FROZEN_ASSET_PAYLOAD"</ID>
    <ID>TopLevelPropertyNaming:GroupedListAdapter.kt$private const val TYPE_CHILD = 2</ID>
    <ID>TopLevelPropertyNaming:GroupedListAdapter.kt$private const val TYPE_GROUP = 1</ID>
    <ID>TopLevelPropertyNaming:ImportSourceModel.kt$private const val PICK_FILE_RESULT_CODE = 101</ID>
    <ID>TopLevelPropertyNaming:InputFilter.kt$private const val NAME_BYTE_LIMIT = 32</ID>
    <ID>TopLevelPropertyNaming:KaruraBonusPayload.kt$val KARURA_BONUS_MULTIPLIER = 0.05.toBigDecimal() // 5%</ID>
    <ID>TopLevelPropertyNaming:ManualRewardCalculator.kt$const val DAYS_IN_YEAR = 365</ID>
    <ID>TopLevelPropertyNaming:ManualRewardCalculator.kt$private const val DECAY_RATE = 0.05</ID>
    <ID>TopLevelPropertyNaming:ManualRewardCalculator.kt$private const val MINIMUM_INFLATION = 0.025</ID>
    <ID>TopLevelPropertyNaming:ManualRewardCalculator.kt$private const val PARACHAINS_ENABLED = false</ID>
    <ID>TopLevelPropertyNaming:Mappers.kt$private const val CROWDLOAN_OPTION = "crowdloans"</ID>
    <ID>TopLevelPropertyNaming:Mappers.kt$private const val DEFAULT_PRECISION = 10</ID>
    <ID>TopLevelPropertyNaming:Mappers.kt$private const val ETHEREUM_OPTION = "ethereumBased"</ID>
    <ID>TopLevelPropertyNaming:Mappers.kt$private const val NOMINATION_POOL_OPTION = "poolStaking"</ID>
    <ID>TopLevelPropertyNaming:Mappers.kt$private const val TESTNET_OPTION = "testnet"</ID>
    <ID>TopLevelPropertyNaming:MetaAccountDao.kt$/** * Fetch meta account where * accountId = meta.substrateAccountId * or hex(accountId) = meta.ethereumAddress * or there is a child chain account which have child.accountId = accountId */ private const val FIND_BY_ADDRESS_QUERY = """ SELECT * FROM meta_accounts WHERE substrateAccountId = :accountId OR ethereumAddress = :accountId OR id = ( SELECT id FROM meta_accounts AS m INNER JOIN chain_accounts as c ON m.id = c.metaId WHERE c.accountId = :accountId ) """</ID>
    <ID>TopLevelPropertyNaming:MetaAccountDaoTest.kt$private const val CHAIN_ID = "1"</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val AddAccountStakingTable_14_15 = object : Migration(14, 15) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL( """ CREATE TABLE IF NOT EXISTS `account_staking_accesses` ( `address` TEXT NOT NULL, `stashId` BLOB, `controllerId` BLOB, PRIMARY KEY(`address`), FOREIGN KEY(`address`) REFERENCES `users`(`address`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val AddChainExplorersTable_33_34 = object : Migration(33, 34) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_explorers` ( `chainId` TEXT NOT NULL, `type` TEXT NOT NULL, `types` TEXT NOT NULL, `url` TEXT NOT NULL, PRIMARY KEY(`chainId`, `type`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_explorers_chainId` ON `chain_explorers` (`chainId`)") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val AddChainRegistryTables_27_28 = object : Migration(27, 28) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("DROP TABLE IF EXISTS chains") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chains` ( `id` TEXT NOT NULL, `parentId` TEXT, `name` TEXT NOT NULL, `icon` TEXT NOT NULL, `prefix` INTEGER NOT NULL, `isEthereumBased` INTEGER NOT NULL, `isTestNet` INTEGER NOT NULL, `hasCrowdloans` INTEGER NOT NULL, `url` TEXT, `overridesCommon` INTEGER, `staking_url` TEXT, `staking_type` TEXT, `history_url` TEXT, `history_type` TEXT, `crowdloans_url` TEXT, `crowdloans_type` TEXT, PRIMARY KEY(`id`)) """.trimIndent() ) database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_nodes` ( `chainId` TEXT NOT NULL, `url` TEXT NOT NULL, `name` TEXT NOT NULL, PRIMARY KEY(`chainId`, `url`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL("""CREATE INDEX IF NOT EXISTS `index_chain_nodes_chainId` ON `chain_nodes` (`chainId`)""") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_assets` ( `id` INTEGER NOT NULL, `chainId` TEXT NOT NULL, `name` TEXT NOT NULL, `symbol` TEXT NOT NULL, `precision` INTEGER NOT NULL, `priceId` TEXT, `staking` TEXT NOT NULL, PRIMARY KEY(`chainId`, `id`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_assets_chainId` ON `chain_assets` (`chainId`)") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_runtimes` ( `chainId` TEXT NOT NULL, `syncedVersion` INTEGER NOT NULL, `remoteVersion` INTEGER NOT NULL, PRIMARY KEY(`chainId`) ) """.trimIndent() ) database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_runtimes_chainId` ON `chain_runtimes` (`chainId`)") database.execSQL("DROP TABLE IF EXISTS `runtimeCache`") database.execSQL( """ CREATE TABLE IF NOT EXISTS `meta_accounts` ( `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `substratePublicKey` BLOB NOT NULL, `substrateCryptoType` TEXT NOT NULL, `substrateAccountId` BLOB NOT NULL, `ethereumPublicKey` BLOB, `ethereumAddress` BLOB, `name` TEXT NOT NULL, `isSelected` INTEGER NOT NULL, `position` INTEGER NOT NULL ) """.trimIndent() ) database.execSQL("CREATE INDEX IF NOT EXISTS `index_meta_accounts_substrateAccountId` ON `meta_accounts` (`substrateAccountId`)") database.execSQL("CREATE INDEX IF NOT EXISTS `index_meta_accounts_ethereumAddress` ON `meta_accounts` (`ethereumAddress`)") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_accounts` ( `metaId` INTEGER NOT NULL, `chainId` TEXT NOT NULL, `publicKey` BLOB NOT NULL, `accountId` BLOB NOT NULL, `cryptoType` TEXT NOT NULL, PRIMARY KEY(`metaId`, `chainId`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED, FOREIGN KEY(`metaId`) REFERENCES `meta_accounts`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_accounts_chainId` ON `chain_accounts` (`chainId`)") database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_accounts_metaId` ON `chain_accounts` (`metaId`)") database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_accounts_accountId` ON `chain_accounts` (`accountId`)") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val AddNetworkTypeToStorageCache_13_14 = object : Migration(13, 14) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("DROP TABLE storage") database.execSQL( """ CREATE TABLE `storage` ( `storageKey` TEXT NOT NULL, `networkType` INTEGER NOT NULL, `content` TEXT, `runtimeVersion` INTEGER NOT NULL, PRIMARY KEY(`storageKey`, `networkType`) ) """ ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val AddOperationsTablesToDb_23_24 = object : Migration(23, 24) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL( """ DROP TABLE IF EXISTS `transactions` """.trimIndent() ) database.execSQL( """ CREATE TABLE IF NOT EXISTS `operations` ( `id` TEXT NOT NULL, `address` TEXT NOT NULL, `time` INTEGER NOT NULL, `tokenType` INTEGER NOT NULL, `status` INTEGER NOT NULL, `source` INTEGER NOT NULL, `operationType` INTEGER NOT NULL, `module` TEXT, `call` TEXT, `amount` TEXT, `sender` TEXT, `receiver` TEXT, `hash` TEXT, `fee` TEXT, `isReward` INTEGER, `era` INTEGER, `validator` TEXT, PRIMARY KEY(`id`, `address`) ) """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val AddPhishingAddressesTable_10_11 = object : Migration(10, 11) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL( """ CREATE TABLE `phishing_addresses` ( `publicKey` TEXT NOT NULL, PRIMARY KEY(`publicKey`) ); """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val AddRuntimeCacheTable_11_12 = object : Migration(11, 12) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL( """ CREATE TABLE `runtimeCache` ( `networkName` TEXT NOT NULL PRIMARY KEY, `latestKnownVersion` INTEGER NOT NULL, `latestAppliedVersion` INTEGER NOT NULL, `typesVersion` INTEGER NOT NULL ) """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val AddStakingRewardsTable_15_16 = object : Migration(15, 16) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL( """ CREATE TABLE IF NOT EXISTS `staking_rewards` ( `accountAddress` TEXT NOT NULL, `eventId` TEXT NOT NULL, `blockNumber` INTEGER NOT NULL, `extrinsicIndex` INTEGER NOT NULL, `extrinsicHash` TEXT NOT NULL, `moduleId` TEXT NOT NULL, `params` TEXT NOT NULL, `eventIndex` TEXT NOT NULL, `amountInPlanks` TEXT NOT NULL, `blockTimestamp` INTEGER NOT NULL, `slashKton` TEXT NOT NULL, PRIMARY KEY(`accountAddress`, `blockNumber`, `extrinsicIndex`) ) """.trimIndent() ) database.execSQL( """ CREATE INDEX IF NOT EXISTS `index_staking_rewards_accountAddress` ON `staking_rewards` (`accountAddress`) """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val AddStorageCacheTable_12_13 = object : Migration(12, 13) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL( """ CREATE TABLE `storage` ( `storageKey` TEXT NOT NULL, `content` TEXT, `runtimeVersion` INTEGER NOT NULL, PRIMARY KEY(`storageKey`) ) """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val AddTokenTable_9_10 = object : Migration(9, 10) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL( """ CREATE TABLE `tokens` ( `type` INTEGER NOT NULL, `dollarRate` TEXT, `recentRateChange` TEXT, PRIMARY KEY(`type`) ); """.trimIndent() ) database.execSQL("DROP TABLE assets") database.execSQL( """ CREATE TABLE `assets` ( `token` INTEGER NOT NULL, `accountAddress` TEXT NOT NULL, `freeInPlanks` TEXT NOT NULL, `reservedInPlanks` TEXT NOT NULL, `miscFrozenInPlanks` TEXT NOT NULL, `feeFrozenInPlanks` TEXT NOT NULL, `bondedInPlanks` TEXT NOT NULL, `redeemableInPlanks` TEXT NOT NULL, `unbondingInPlanks` TEXT NOT NULL, PRIMARY KEY(`token`, `accountAddress`), FOREIGN KEY(`accountAddress`) REFERENCES `users`(`address`) ON UPDATE NO ACTION ON DELETE CASCADE, FOREIGN KEY(`token`) REFERENCES `tokens`(`type`) ON UPDATE NO ACTION ON DELETE NO ACTION );""" .trimIndent() ) database.execSQL("CREATE INDEX index_assets_accountAddress ON assets(accountAddress);") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val AddTotalRewardsTableToDb_21_22 = object : Migration(21, 22) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL( """ CREATE TABLE IF NOT EXISTS `total_reward` ( `accountAddress` TEXT NOT NULL, `totalReward` TEXT, PRIMARY KEY(`accountAddress`)) """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val AssetsMigration_38_39 = object : Migration(38, 39) { override fun migrate(database: SupportSQLiteDatabase) { database.beginTransaction() database.execSQL("ALTER TABLE assets RENAME TO _assets") database.execSQL( """ CREATE TABLE IF NOT EXISTS `assets` ( `tokenSymbol` TEXT NOT NULL, `chainId` TEXT NOT NULL, `accountId` BLOB NOT NULL, `metaId` INTEGER NOT NULL, `freeInPlanks` TEXT, `reservedInPlanks` TEXT, `miscFrozenInPlanks` TEXT, `feeFrozenInPlanks` TEXT, `bondedInPlanks` TEXT, `redeemableInPlanks` TEXT, `unbondingInPlanks` TEXT, `sortIndex` INTEGER NOT NULL DEFAULT 0, `enabled` INTEGER NOT NULL DEFAULT 1, `chainAccountName` TEXT, PRIMARY KEY(`tokenSymbol`, `chainId`, `accountId`, `metaId`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL( """ INSERT INTO assets SELECT a.tokenSymbol, a.chainId, a.accountId, a.metaId, a.freeInPlanks, a.reservedInPlanks, a.miscFrozenInPlanks, a.feeFrozenInPlanks, a.bondedInPlanks, a.redeemableInPlanks, a.unbondingInPlanks, 0 as `sortIndex`, 1 as `enabled`, null as `chainAccountName` FROM _assets a """.trimIndent() ) database.execSQL("DROP TABLE _assets") database.execSQL("CREATE INDEX IF NOT EXISTS `index_assets_metaId` ON `assets` (`metaId`)") database.setTransactionSuccessful() database.endTransaction() } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val AssetsMigration_40_41 = object : Migration(40, 41) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("ALTER TABLE assets RENAME TO _assets") database.execSQL( """ CREATE TABLE IF NOT EXISTS `assets` ( `tokenSymbol` TEXT NOT NULL, `chainId` TEXT NOT NULL, `accountId` BLOB NOT NULL, `metaId` INTEGER NOT NULL, `freeInPlanks` TEXT, `reservedInPlanks` TEXT, `miscFrozenInPlanks` TEXT, `feeFrozenInPlanks` TEXT, `bondedInPlanks` TEXT, `redeemableInPlanks` TEXT, `unbondingInPlanks` TEXT, `sortIndex` INTEGER NOT NULL DEFAULT 0, `enabled` INTEGER NOT NULL DEFAULT 1, `markedNotNeed` INTEGER NOT NULL DEFAULT 0, `chainAccountName` TEXT, PRIMARY KEY(`tokenSymbol`, `chainId`, `accountId`, `metaId`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL( """ INSERT INTO assets SELECT a.tokenSymbol, a.chainId, a.accountId, a.metaId, a.freeInPlanks, a.reservedInPlanks, a.miscFrozenInPlanks, a.feeFrozenInPlanks, a.bondedInPlanks, a.redeemableInPlanks, a.unbondingInPlanks, 0 as `sortIndex`, 1 as `enabled`, 0 as `markedNotNeed`, null as `chainAccountName` FROM _assets a """.trimIndent() ) database.execSQL("DROP TABLE _assets") database.execSQL("CREATE INDEX IF NOT EXISTS `index_assets_metaId` ON `assets` (`metaId`)") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val ChainAssetsMigration_39_40 = object : Migration(39, 40) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("DELETE FROM chain_explorers") database.execSQL("DELETE FROM chain_assets") database.execSQL("DELETE FROM chain_nodes") database.execSQL("DROP TABLE IF EXISTS chains") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chains` ( `id` TEXT NOT NULL, `parentId` TEXT, `name` TEXT NOT NULL, `minSupportedVersion` TEXT, `icon` TEXT NOT NULL, `prefix` INTEGER NOT NULL, `isEthereumBased` INTEGER NOT NULL, `isTestNet` INTEGER NOT NULL, `hasCrowdloans` INTEGER NOT NULL, `url` TEXT, `overridesCommon` INTEGER, `staking_url` TEXT, `staking_type` TEXT, `history_url` TEXT, `history_type` TEXT, `crowdloans_url` TEXT, `crowdloans_type` TEXT, PRIMARY KEY(`id`)) """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val ChangePrimaryKeyForRewards_16_17 = object : Migration(16, 17) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("DROP TABLE staking_rewards") database.execSQL( """ CREATE TABLE IF NOT EXISTS `staking_rewards` ( `accountAddress` TEXT NOT NULL, `eventId` TEXT NOT NULL, `blockNumber` INTEGER NOT NULL, `extrinsicIndex` INTEGER NOT NULL, `extrinsicHash` TEXT NOT NULL, `moduleId` TEXT NOT NULL, `params` TEXT NOT NULL, `eventIdx` INTEGER NOT NULL, `eventIndex` TEXT NOT NULL, `amountInPlanks` TEXT NOT NULL, `blockTimestamp` INTEGER NOT NULL, `slashKton` TEXT NOT NULL, PRIMARY KEY(`accountAddress`, `blockNumber`, `eventIdx`)) """.trimIndent() ) database.execSQL( """ CREATE INDEX IF NOT EXISTS `index_staking_rewards_accountAddress` ON `staking_rewards` (`accountAddress`) """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val DifferentCurrenciesMigrations_37_38 = object : Migration(37, 38) { override fun migrate(database: SupportSQLiteDatabase) { database.beginTransaction() database.execSQL("DROP TABLE tokens") database.execSQL( """ CREATE TABLE IF NOT EXISTS `tokens` ( `symbol` TEXT NOT NULL, `fiatRate` TEXT, `fiatSymbol` TEXT, `recentRateChange` TEXT, PRIMARY KEY(`symbol`) ) """.trimIndent() ) database.setTransactionSuccessful() database.endTransaction() } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val FixAssetsMigration_36_37 = object : Migration(36, 37) { override fun migrate(database: SupportSQLiteDatabase) { database.beginTransaction() database.execSQL("ALTER TABLE assets RENAME TO _assets") database.execSQL( """ CREATE TABLE IF NOT EXISTS `assets` ( `tokenSymbol` TEXT NOT NULL, `chainId` TEXT NOT NULL, `accountId` BLOB NOT NULL, `metaId` INTEGER NOT NULL, `freeInPlanks` TEXT NOT NULL, `reservedInPlanks` TEXT NOT NULL, `miscFrozenInPlanks` TEXT NOT NULL, `feeFrozenInPlanks` TEXT NOT NULL, `bondedInPlanks` TEXT NOT NULL, `redeemableInPlanks` TEXT NOT NULL, `unbondingInPlanks` TEXT NOT NULL, `sortIndex` INTEGER NOT NULL DEFAULT 0, `enabled` INTEGER NOT NULL DEFAULT 1, `chainAccountName` TEXT, PRIMARY KEY(`tokenSymbol`, `chainId`, `accountId`, `metaId`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL( """ INSERT INTO assets SELECT a.tokenSymbol, a.chainId, a.accountId, a.metaId, a.freeInPlanks, a.reservedInPlanks, a.miscFrozenInPlanks, a.feeFrozenInPlanks, a.bondedInPlanks, a.redeemableInPlanks, a.unbondingInPlanks, 0 as `sortIndex`, 1 as `enabled`, null as `chainAccountName` FROM _assets a """.trimIndent() ) database.execSQL("DROP TABLE _assets") database.execSQL("CREATE INDEX IF NOT EXISTS `index_assets_metaId` ON `assets` (`metaId`)") database.setTransactionSuccessful() database.endTransaction() } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val MigrateTablesToV2_29_30 = object : Migration(29, 30) { override fun migrate(database: SupportSQLiteDatabase) { // assets database.execSQL("DROP TABLE assets") database.execSQL( """ CREATE TABLE IF NOT EXISTS `assets` ( `tokenSymbol` TEXT NOT NULL, `chainId` TEXT NOT NULL, `accountId` BLOB NOT NULL, `metaId` INTEGER NOT NULL, `freeInPlanks` TEXT NOT NULL, `reservedInPlanks` TEXT NOT NULL, `miscFrozenInPlanks` TEXT NOT NULL, `feeFrozenInPlanks` TEXT NOT NULL, `bondedInPlanks` TEXT NOT NULL, `redeemableInPlanks` TEXT NOT NULL, `unbondingInPlanks` TEXT NOT NULL, PRIMARY KEY(`tokenSymbol`, `chainId`, `accountId`) ) """.trimIndent() ) database.execSQL("CREATE INDEX IF NOT EXISTS `index_assets_metaId` ON `assets` (`metaId`)") // storage database.execSQL("DROP TABLE storage") database.execSQL( """ CREATE TABLE IF NOT EXISTS `storage` ( `storageKey` TEXT NOT NULL, `content` TEXT, `chainId` TEXT NOT NULL, PRIMARY KEY(`chainId`, `storageKey`) ) """.trimIndent() ) // tokens database.execSQL("DROP TABLE tokens") database.execSQL( """ CREATE TABLE IF NOT EXISTS `tokens` ( `symbol` TEXT NOT NULL, `dollarRate` TEXT, `recentRateChange` TEXT, PRIMARY KEY(`symbol`) ) """.trimIndent() ) // staking state database.execSQL("DROP TABLE account_staking_accesses") database.execSQL( """ CREATE TABLE IF NOT EXISTS `account_staking_accesses` ( `chainId` TEXT NOT NULL, `chainAssetId` TEXT NOT NULL, `accountId` BLOB NOT NULL, `stashId` BLOB, `controllerId` BLOB, PRIMARY KEY(`chainId`, `chainAssetId`, `accountId`) ) """.trimIndent() ) // operationsMi database.execSQL("DROP TABLE operations") database.execSQL( """ CREATE TABLE IF NOT EXISTS `operations` (`id` TEXT NOT NULL, `address` TEXT NOT NULL, `chainId` TEXT NOT NULL, `chainAssetId` TEXT NOT NULL, `time` INTEGER NOT NULL, `status` INTEGER NOT NULL, `source` INTEGER NOT NULL, `operationType` INTEGER NOT NULL, `module` TEXT, `call` TEXT, `amount` TEXT, `sender` TEXT, `receiver` TEXT, `hash` TEXT, `fee` TEXT, `isReward` INTEGER, `era` INTEGER, `validator` TEXT, PRIMARY KEY(`id`, `address`, `chainId`, `chainAssetId`) ) """.trimIndent() ) database.execSQL("DROP TABLE IF EXISTS chain_assets") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_assets` ( `id` TEXT NOT NULL, `chainId` TEXT NOT NULL, `name` TEXT NOT NULL, `icon` TEXT NOT NULL, `precision` INTEGER NOT NULL, `priceId` TEXT, `staking` TEXT NOT NULL, `priceProviders` TEXT, `nativeChainId` TEXT, PRIMARY KEY(`chainId`, `id`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_assets_chainId` ON `chain_assets` (`chainId`)") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val MigrateTablesToV2_30_31 = object : Migration(30, 31) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("ALTER TABLE chain_nodes ADD COLUMN `isActive` INTEGER NOT NULL DEFAULT 0") database.execSQL("ALTER TABLE chain_nodes ADD COLUMN `isDefault` INTEGER NOT NULL DEFAULT 1") database.execSQL("DROP TABLE nodes") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val MigrateTablesToV2_32_33 = object : Migration(32, 33) { override fun migrate(database: SupportSQLiteDatabase) { // assets database.execSQL("DROP TABLE assets") database.execSQL( """ CREATE TABLE IF NOT EXISTS `assets` ( `tokenSymbol` TEXT NOT NULL, `chainId` TEXT NOT NULL, `accountId` BLOB NOT NULL, `metaId` INTEGER NOT NULL, `freeInPlanks` TEXT NOT NULL, `reservedInPlanks` TEXT NOT NULL, `miscFrozenInPlanks` TEXT NOT NULL, `feeFrozenInPlanks` TEXT NOT NULL, `bondedInPlanks` TEXT NOT NULL, `redeemableInPlanks` TEXT NOT NULL, `unbondingInPlanks` TEXT NOT NULL, PRIMARY KEY(`tokenSymbol`, `chainId`, `accountId`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL("CREATE INDEX IF NOT EXISTS `index_assets_metaId` ON `assets` (`metaId`)") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val Migration_41_42 = object : Migration(41, 42) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("ALTER TABLE chains RENAME TO _chains") database.execSQL("DROP TABLE IF EXISTS chains") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chains` ( `id` TEXT NOT NULL, `parentId` TEXT, `name` TEXT NOT NULL, `minSupportedVersion` TEXT, `icon` TEXT NOT NULL, `prefix` INTEGER NOT NULL, `isEthereumBased` INTEGER NOT NULL, `isTestNet` INTEGER NOT NULL, `hasCrowdloans` INTEGER NOT NULL, `supportStakingPool` INTEGER NOT NULL, `url` TEXT, `overridesCommon` INTEGER, `staking_url` TEXT, `staking_type` TEXT, `history_url` TEXT, `history_type` TEXT, `crowdloans_url` TEXT, `crowdloans_type` TEXT, PRIMARY KEY(`id`)) """.trimIndent() ) database.execSQL( """ INSERT INTO chains SELECT c.id, c.parentId, c.name, c.minSupportedVersion, c.icon, c.prefix, c.isEthereumBased, c.isTestNet, c.hasCrowdloans, 0 as `supportStakingPool`, c.url, c.overridesCommon, c.staking_url, c.staking_type, c.history_url, c.history_type, c.crowdloans_url, c.crowdloans_type FROM _chains c """.trimIndent() ) database.execSQL("DROP TABLE IF EXISTS _chains") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val Migration_42_43 = object : Migration(42, 43) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("DROP TABLE IF EXISTS chain_assets") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_assets` ( `id` TEXT NOT NULL, `symbol` TEXT NOT NULL, `displayName` TEXT, `chainId` TEXT NOT NULL, `icon` TEXT NOT NULL, `precision` INTEGER NOT NULL, `priceId` TEXT, `staking` TEXT NOT NULL, `priceProviders` TEXT, `isUtility` INTEGER, `type` TEXT, `currencyId` TEXT, `existentialDeposit` TEXT, PRIMARY KEY(`chainId`, `id`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_assets_chainId` ON `chain_assets` (`chainId`)") database.execSQL("DROP TABLE IF EXISTS assets") database.execSQL( """ CREATE TABLE IF NOT EXISTS `assets` ( `id` TEXT NOT NULL, `chainId` TEXT NOT NULL, `accountId` BLOB NOT NULL, `metaId` INTEGER NOT NULL, `tokenPriceId` TEXT, `freeInPlanks` TEXT, `reservedInPlanks` TEXT, `miscFrozenInPlanks` TEXT, `feeFrozenInPlanks` TEXT, `bondedInPlanks` TEXT, `redeemableInPlanks` TEXT, `unbondingInPlanks` TEXT, `sortIndex` INTEGER NOT NULL DEFAULT 0, `enabled` INTEGER NOT NULL DEFAULT 1, `markedNotNeed` INTEGER NOT NULL DEFAULT 0, `chainAccountName` TEXT, PRIMARY KEY(`id`, `chainId`, `accountId`, `metaId`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL("CREATE INDEX IF NOT EXISTS `index_assets_metaId` ON `assets` (`metaId`)") database.execSQL("CREATE INDEX IF NOT EXISTS `index_assets_chainId` ON `assets` (`chainId`)") database.execSQL("DROP TABLE IF EXISTS tokens") database.execSQL( """ CREATE TABLE IF NOT EXISTS `token_price` ( `priceId` TEXT NOT NULL, `fiatRate` TEXT, `fiatSymbol` TEXT, `recentRateChange` TEXT, PRIMARY KEY(`priceId`) ) """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val Migration_43_44 = object : Migration(43, 44) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("DROP TABLE IF EXISTS phishing_addresses") database.execSQL( """ CREATE TABLE IF NOT EXISTS `phishing` ( `address` TEXT NOT NULL, `name` TEXT, `type` TEXT NOT NULL, `subtype` TEXT, PRIMARY KEY(`address`, `type`) ) """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val Migration_44_45 = object : Migration(44, 45) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL( """ CREATE TABLE IF NOT EXISTS `address_book` ( `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `address` TEXT NOT NULL, `name` TEXT, `chainId` TEXT NOT NULL, `created` INTEGER NOT NULL ) """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val Migration_45_46 = object : Migration(45, 46) { override fun migrate(database: SupportSQLiteDatabase) { // on some devices FOREIGN KEY(`chainId`) REFERENCES to `_chains` table. // So we need to recreate all the tables with new FK which were created after the renaming chains to _chains (Migration_41_42) // assets - done in Migration_42_43 // chain_assets - done in Migration_42_43 // chain_explorers - done here // chain_nodes - done here // chain_accounts - done here // delete all data related to chains and assets - emulating cold start with existing accounts database.execSQL("DELETE FROM chains") database.execSQL("DELETE FROM chain_assets") database.execSQL("DELETE FROM assets") database.execSQL("DROP TABLE IF EXISTS chain_nodes") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_nodes` ( `chainId` TEXT NOT NULL, `url` TEXT NOT NULL, `name` TEXT NOT NULL, `isActive` INTEGER NOT NULL, `isDefault` INTEGER NOT NULL, PRIMARY KEY(`chainId`, `url`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_nodes_chainId` ON `chain_nodes` (`chainId`)") database.execSQL("DROP TABLE IF EXISTS chain_explorers") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_explorers` ( `chainId` TEXT NOT NULL, `type` TEXT NOT NULL, `types` TEXT NOT NULL, `url` TEXT NOT NULL, PRIMARY KEY(`chainId`, `type`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_explorers_chainId` ON `chain_explorers` (`chainId`)") database.execSQL("DROP TABLE chain_accounts") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_accounts` ( `metaId` INTEGER NOT NULL, `chainId` TEXT NOT NULL, `publicKey` BLOB NOT NULL, `accountId` BLOB NOT NULL, `cryptoType` TEXT NOT NULL, `name` TEXT NOT NULL, PRIMARY KEY(`metaId`, `chainId`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED, FOREIGN KEY(`metaId`) REFERENCES `meta_accounts`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_accounts_chainId` ON `chain_accounts` (`chainId`)") database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_accounts_metaId` ON `chain_accounts` (`metaId`)") database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_accounts_accountId` ON `chain_accounts` (`accountId`)") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val Migration_46_47 = object : Migration(46, 47) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("ALTER TABLE operations ADD COLUMN `liquidityFee` TEXT DEFAULT NULL") database.execSQL("ALTER TABLE operations ADD COLUMN `market` TEXT DEFAULT NULL") database.execSQL("ALTER TABLE operations ADD COLUMN `targetAssetId` TEXT DEFAULT NULL") database.execSQL("ALTER TABLE operations ADD COLUMN `targetAmount` TEXT DEFAULT NULL") database.execSQL("DELETE FROM operations") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val Migration_47_48 = object : Migration(47, 48) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("ALTER TABLE chain_assets ADD COLUMN `color` TEXT DEFAULT NULL") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val Migration_48_49 = object : Migration(48, 49) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("ALTER TABLE chain_assets ADD COLUMN `isNative` INTEGER DEFAULT NULL") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val Migration_49_50 = object : Migration(49, 50) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("ALTER TABLE chain_assets ADD COLUMN `name` TEXT DEFAULT NULL") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val Migration_50_51 = object : Migration(50, 51) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL( """ CREATE TABLE IF NOT EXISTS `sora_card` ( `id` TEXT NOT NULL, `accessToken` TEXT NOT NULL, `refreshToken` TEXT NOT NULL, `accessTokenExpirationTime` INTEGER NOT NULL, `kycStatus` TEXT NOT NULL, PRIMARY KEY(`id`) ) """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val Migration_51_52 = object : Migration(51, 52) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("ALTER TABLE assets RENAME TO _assets") database.execSQL("DROP TABLE IF EXISTS assets") // new table with nullable enabled field database.execSQL( """ CREATE TABLE IF NOT EXISTS `assets` ( `id` TEXT NOT NULL, `chainId` TEXT NOT NULL, `accountId` BLOB NOT NULL, `metaId` INTEGER NOT NULL, `tokenPriceId` TEXT, `freeInPlanks` TEXT, `reservedInPlanks` TEXT, `miscFrozenInPlanks` TEXT, `feeFrozenInPlanks` TEXT, `bondedInPlanks` TEXT, `redeemableInPlanks` TEXT, `unbondingInPlanks` TEXT, `sortIndex` INTEGER NOT NULL DEFAULT 0, `enabled` INTEGER DEFAULT NULL, `markedNotNeed` INTEGER NOT NULL DEFAULT 0, `chainAccountName` TEXT, PRIMARY KEY(`id`, `chainId`, `accountId`, `metaId`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL( """ INSERT INTO assets SELECT a.id, a.chainId, a.accountId, a.metaId, a.tokenPriceId, a.freeInPlanks, a.reservedInPlanks, a.miscFrozenInPlanks, a.feeFrozenInPlanks, a.bondedInPlanks, a.redeemableInPlanks, a.unbondingInPlanks, a.sortIndex, a.enabled, a.markedNotNeed, a.chainAccountName FROM _assets a """.trimIndent() ) database.execSQL( """ UPDATE assets SET enabled = NULL WHERE enabled = 1 """.trimIndent() ) database.execSQL("DROP TABLE IF EXISTS _assets") database.execSQL("CREATE INDEX IF NOT EXISTS `index_assets_metaId` ON `assets` (`metaId`)") database.execSQL("CREATE INDEX IF NOT EXISTS `index_assets_chainId` ON `assets` (`chainId`)") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val Migration_52_53 = object : Migration(52, 53) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_types` ( `chainId` TEXT NOT NULL, `typesConfig` TEXT NOT NULL, PRIMARY KEY(`chainId`) ) """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val Migration_53_54 = object : Migration(53, 54) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("DROP TABLE IF EXISTS _chains") database.execSQL( """ CREATE TABLE IF NOT EXISTS `_chains` ( `id` TEXT NOT NULL, `parentId` TEXT, `name` TEXT NOT NULL, `minSupportedVersion` TEXT, `icon` TEXT NOT NULL, `prefix` INTEGER NOT NULL, `isEthereumBased` INTEGER NOT NULL, `isTestNet` INTEGER NOT NULL, `hasCrowdloans` INTEGER NOT NULL, `supportStakingPool` INTEGER NOT NULL, `staking_url` TEXT, `staking_type` TEXT, `history_url` TEXT, `history_type` TEXT, `crowdloans_url` TEXT, `crowdloans_type` TEXT, PRIMARY KEY(`id`)) """.trimIndent() ) database.execSQL( """ INSERT INTO _chains SELECT c.id, c.parentId, c.name, c.minSupportedVersion, c.icon, c.prefix, c.isEthereumBased, c.isTestNet, c.hasCrowdloans, 0 as `supportStakingPool`, c.staking_url, c.staking_type, c.history_url, c.history_type, c.crowdloans_url, c.crowdloans_type FROM chains c """.trimIndent() ) database.execSQL("DROP TABLE IF EXISTS chains") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chains` ( `id` TEXT NOT NULL, `parentId` TEXT, `name` TEXT NOT NULL, `minSupportedVersion` TEXT, `icon` TEXT NOT NULL, `prefix` INTEGER NOT NULL, `isEthereumBased` INTEGER NOT NULL, `isTestNet` INTEGER NOT NULL, `hasCrowdloans` INTEGER NOT NULL, `supportStakingPool` INTEGER NOT NULL, `staking_url` TEXT, `staking_type` TEXT, `history_url` TEXT, `history_type` TEXT, `crowdloans_url` TEXT, `crowdloans_type` TEXT, PRIMARY KEY(`id`)) """.trimIndent() ) database.execSQL( """ INSERT INTO chains SELECT c.id, c.parentId, c.name, c.minSupportedVersion, c.icon, c.prefix, c.isEthereumBased, c.isTestNet, c.hasCrowdloans, 0 as `supportStakingPool`, c.staking_url, c.staking_type, c.history_url, c.history_type, c.crowdloans_url, c.crowdloans_type FROM _chains c """.trimIndent() ) database.execSQL("DROP TABLE IF EXISTS _chains") // to be sure that foreign keys to Chain table is correct we recreate them // chain_nodes database.execSQL("DROP TABLE IF EXISTS _chain_nodes") database.execSQL( """ CREATE TABLE IF NOT EXISTS `_chain_nodes` ( `chainId` TEXT NOT NULL, `url` TEXT NOT NULL, `name` TEXT NOT NULL, `isActive` INTEGER NOT NULL, `isDefault` INTEGER NOT NULL, PRIMARY KEY(`chainId`, `url`) ) """.trimIndent() ) database.execSQL( """ INSERT INTO _chain_nodes SELECT cn.chainId, cn.url, cn.name, cn.isActive, cn.isDefault FROM chain_nodes cn """.trimIndent() ) database.execSQL("DROP TABLE IF EXISTS chain_nodes") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_nodes` ( `chainId` TEXT NOT NULL, `url` TEXT NOT NULL, `name` TEXT NOT NULL, `isActive` INTEGER NOT NULL, `isDefault` INTEGER NOT NULL, PRIMARY KEY(`chainId`, `url`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL( """ INSERT INTO chain_nodes SELECT cn.chainId, cn.url, cn.name, cn.isActive, cn.isDefault FROM _chain_nodes cn """.trimIndent() ) database.execSQL("DROP TABLE IF EXISTS _chain_nodes") database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_nodes_chainId` ON `chain_nodes` (`chainId`)") // assets database.execSQL("DROP TABLE IF EXISTS _assets") database.execSQL( """ CREATE TABLE IF NOT EXISTS `_assets` ( `id` TEXT NOT NULL, `chainId` TEXT NOT NULL, `accountId` BLOB NOT NULL, `metaId` INTEGER NOT NULL, `tokenPriceId` TEXT, `freeInPlanks` TEXT, `reservedInPlanks` TEXT, `miscFrozenInPlanks` TEXT, `feeFrozenInPlanks` TEXT, `bondedInPlanks` TEXT, `redeemableInPlanks` TEXT, `unbondingInPlanks` TEXT, `sortIndex` INTEGER NOT NULL DEFAULT 0, `enabled` INTEGER DEFAULT NULL, `markedNotNeed` INTEGER NOT NULL DEFAULT 0, `chainAccountName` TEXT, PRIMARY KEY(`id`, `chainId`, `accountId`, `metaId`) ) """.trimIndent() ) database.execSQL( """ INSERT INTO _assets SELECT a.id, a.chainId, a.accountId, a.metaId, a.tokenPriceId, a.freeInPlanks, a.reservedInPlanks, a.miscFrozenInPlanks, a.feeFrozenInPlanks, a.bondedInPlanks, a.redeemableInPlanks, a.unbondingInPlanks, a.sortIndex, a.enabled, a.markedNotNeed, a.chainAccountName FROM assets a """.trimIndent() ) database.execSQL("DROP TABLE IF EXISTS assets") database.execSQL( """ CREATE TABLE IF NOT EXISTS `assets` ( `id` TEXT NOT NULL, `chainId` TEXT NOT NULL, `accountId` BLOB NOT NULL, `metaId` INTEGER NOT NULL, `tokenPriceId` TEXT, `freeInPlanks` TEXT, `reservedInPlanks` TEXT, `miscFrozenInPlanks` TEXT, `feeFrozenInPlanks` TEXT, `bondedInPlanks` TEXT, `redeemableInPlanks` TEXT, `unbondingInPlanks` TEXT, `sortIndex` INTEGER NOT NULL DEFAULT 0, `enabled` INTEGER DEFAULT NULL, `markedNotNeed` INTEGER NOT NULL DEFAULT 0, `chainAccountName` TEXT, PRIMARY KEY(`id`, `chainId`, `accountId`, `metaId`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL( """ INSERT INTO assets SELECT a.id, a.chainId, a.accountId, a.metaId, a.tokenPriceId, a.freeInPlanks, a.reservedInPlanks, a.miscFrozenInPlanks, a.feeFrozenInPlanks, a.bondedInPlanks, a.redeemableInPlanks, a.unbondingInPlanks, a.sortIndex, a.enabled, a.markedNotNeed, a.chainAccountName FROM _assets a """.trimIndent() ) database.execSQL("DROP TABLE IF EXISTS _assets") database.execSQL("CREATE INDEX IF NOT EXISTS `index_assets_metaId` ON `assets` (`metaId`)") database.execSQL("CREATE INDEX IF NOT EXISTS `index_assets_chainId` ON `assets` (`chainId`)") // chain_explorers database.execSQL("DROP TABLE IF EXISTS _chain_explorers") database.execSQL( """ CREATE TABLE IF NOT EXISTS `_chain_explorers` ( `chainId` TEXT NOT NULL, `type` TEXT NOT NULL, `types` TEXT NOT NULL, `url` TEXT NOT NULL, PRIMARY KEY(`chainId`, `type`) ) """.trimIndent() ) database.execSQL( """ INSERT INTO _chain_explorers SELECT ce.chainId, ce.type, ce.types, ce.url FROM chain_explorers ce """.trimIndent() ) database.execSQL("DROP TABLE IF EXISTS chain_explorers") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_explorers` ( `chainId` TEXT NOT NULL, `type` TEXT NOT NULL, `types` TEXT NOT NULL, `url` TEXT NOT NULL, PRIMARY KEY(`chainId`, `type`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL( """ INSERT INTO chain_explorers SELECT ce.chainId, ce.type, ce.types, ce.url FROM _chain_explorers ce """.trimIndent() ) database.execSQL("DROP TABLE IF EXISTS _chain_explorers") database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_explorers_chainId` ON `chain_explorers` (`chainId`)") // chain_accounts database.execSQL("DROP TABLE IF EXISTS _chain_accounts") database.execSQL( """ CREATE TABLE IF NOT EXISTS `_chain_accounts` ( `metaId` INTEGER NOT NULL, `chainId` TEXT NOT NULL, `publicKey` BLOB NOT NULL, `accountId` BLOB NOT NULL, `cryptoType` TEXT NOT NULL, `name` TEXT NOT NULL, PRIMARY KEY(`metaId`, `chainId`) ) """.trimIndent() ) database.execSQL( """ INSERT INTO _chain_accounts SELECT ca.metaId, ca.chainId, ca.publicKey, ca.accountId, ca.cryptoType, ca.name FROM chain_accounts ca """.trimIndent() ) database.execSQL("DROP TABLE IF EXISTS chain_accounts") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_accounts` ( `metaId` INTEGER NOT NULL, `chainId` TEXT NOT NULL, `publicKey` BLOB NOT NULL, `accountId` BLOB NOT NULL, `cryptoType` TEXT NOT NULL, `name` TEXT NOT NULL, PRIMARY KEY(`metaId`, `chainId`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED, FOREIGN KEY(`metaId`) REFERENCES `meta_accounts`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL( """ INSERT INTO chain_accounts SELECT ca.metaId, ca.chainId, ca.publicKey, ca.accountId, ca.cryptoType, ca.name FROM _chain_accounts ca """.trimIndent() ) database.execSQL("DROP TABLE IF EXISTS _chain_accounts") database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_accounts_chainId` ON `chain_accounts` (`chainId`)") database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_accounts_metaId` ON `chain_accounts` (`metaId`)") database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_accounts_accountId` ON `chain_accounts` (`accountId`)") // chain_assets database.execSQL("DROP TABLE IF EXISTS _chain_assets") database.execSQL( """ CREATE TABLE IF NOT EXISTS `_chain_assets` ( `id` TEXT NOT NULL, `name` TEXT, `symbol` TEXT NOT NULL, `displayName` TEXT, `chainId` TEXT NOT NULL, `icon` TEXT NOT NULL, `priceId` TEXT, `staking` TEXT NOT NULL, `precision` INTEGER NOT NULL, `priceProviders` TEXT, `isUtility` INTEGER, `type` TEXT, `currencyId` TEXT, `existentialDeposit` TEXT, `color` TEXT, `isNative` INTEGER, PRIMARY KEY(`chainId`, `id`) ) """.trimIndent() ) database.execSQL( """ INSERT INTO _chain_assets SELECT ca.id, ca.name, ca.symbol, ca.displayName, ca.chainId, ca.icon, ca.priceId, ca.staking, ca.precision, ca.priceProviders, ca.isUtility, ca.type, ca.currencyId, ca.existentialDeposit, ca.color, ca.isNative FROM chain_assets ca """.trimIndent() ) database.execSQL("DROP TABLE IF EXISTS chain_assets") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_assets` ( `id` TEXT NOT NULL, `name` TEXT, `symbol` TEXT NOT NULL, `displayName` TEXT, `chainId` TEXT NOT NULL, `icon` TEXT NOT NULL, `priceId` TEXT, `staking` TEXT NOT NULL, `precision` INTEGER NOT NULL, `priceProviders` TEXT, `isUtility` INTEGER, `type` TEXT, `currencyId` TEXT, `existentialDeposit` TEXT, `color` TEXT, `isNative` INTEGER, PRIMARY KEY(`chainId`, `id`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL( """ INSERT INTO chain_assets SELECT ca.id, ca.name, ca.symbol, ca.displayName, ca.chainId, ca.icon, ca.priceId, ca.staking, ca.precision, ca.priceProviders, ca.isUtility, ca.type, ca.currencyId, ca.existentialDeposit, ca.color, ca.isNative FROM _chain_assets ca """.trimIndent() ) database.execSQL("DROP TABLE IF EXISTS _chain_assets") database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_assets_chainId` ON `chain_assets` (`chainId`)") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val Migration_54_55 = object : Migration(54, 55) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("DROP TABLE IF EXISTS `_address_book`") database.execSQL("CREATE TABLE `_address_book` AS SELECT * FROM `address_book`") database.execSQL("DELETE FROM `address_book` where `id` NOT IN (SELECT `id` FROM `_address_book` GROUP BY `address`, `chainId`)") database.execSQL("DROP TABLE IF EXISTS `_address_book`") database.execSQL( """ CREATE UNIQUE INDEX IF NOT EXISTS `index_address_book_address_chainId` ON `address_book` (`address`, `chainId`) """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val Migration_55_56 = object : Migration(55, 56) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("DROP TABLE IF EXISTS chain_assets") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_assets` ( `id` TEXT NOT NULL, `name` TEXT, `symbol` TEXT NOT NULL, `chainId` TEXT NOT NULL, `icon` TEXT NOT NULL, `priceId` TEXT, `staking` TEXT NOT NULL, `precision` INTEGER NOT NULL, `priceProviders` TEXT, `isUtility` INTEGER, `type` TEXT, `currencyId` TEXT, `existentialDeposit` TEXT, `color` TEXT, `isNative` INTEGER, PRIMARY KEY(`chainId`, `id`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_assets_chainId` ON `chain_assets` (`chainId`)") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val RemoveAccountForeignKeyFromAsset_17_18 = object : Migration(17, 18) { override fun migrate(database: SupportSQLiteDatabase) { database.beginTransaction() database.execSQL("DROP INDEX IF EXISTS index_assets_accountAddress") database.execSQL("ALTER TABLE assets RENAME TO _assets") database.execSQL( """ CREATE TABLE IF NOT EXISTS `assets` ( `token` INTEGER NOT NULL, `accountAddress` TEXT NOT NULL, `freeInPlanks` TEXT NOT NULL, `reservedInPlanks` TEXT NOT NULL, `miscFrozenInPlanks` TEXT NOT NULL, `feeFrozenInPlanks` TEXT NOT NULL, `bondedInPlanks` TEXT NOT NULL, `redeemableInPlanks` TEXT NOT NULL, `unbondingInPlanks` TEXT NOT NULL, PRIMARY KEY(`token`, `accountAddress`), FOREIGN KEY(`token`) REFERENCES `tokens`(`type`) ON UPDATE NO ACTION ON DELETE NO ACTION ) """.trimIndent() ) database.execSQL("CREATE INDEX `index_assets_accountAddress` ON `assets` (`accountAddress`)") database.execSQL("INSERT INTO assets SELECT * FROM _assets") database.execSQL("DROP TABLE _assets") database.setTransactionSuccessful() database.endTransaction() } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val RemoveLegacyData_35_36 = object : Migration(35, 36) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("DROP TABLE chain_accounts") database.execSQL( """ CREATE TABLE IF NOT EXISTS `chain_accounts` ( `metaId` INTEGER NOT NULL, `chainId` TEXT NOT NULL, `publicKey` BLOB NOT NULL, `accountId` BLOB NOT NULL, `cryptoType` TEXT NOT NULL, `name` TEXT NOT NULL, PRIMARY KEY(`metaId`, `chainId`), FOREIGN KEY(`chainId`) REFERENCES `chains`(`id`) ON UPDATE NO ACTION ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED, FOREIGN KEY(`metaId`) REFERENCES `meta_accounts`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE ) """.trimIndent() ) database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_accounts_chainId` ON `chain_accounts` (`chainId`)") database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_accounts_metaId` ON `chain_accounts` (`metaId`)") database.execSQL("CREATE INDEX IF NOT EXISTS `index_chain_accounts_accountId` ON `chain_accounts` (`accountId`)") // remove `networkType` INTEGER NOT NULL database.execSQL("ALTER TABLE users RENAME TO _users") database.execSQL( """ CREATE TABLE IF NOT EXISTS `users` ( `address` TEXT NOT NULL, `username` TEXT NOT NULL, `publicKey` TEXT NOT NULL, `cryptoType` INTEGER NOT NULL, `position` INTEGER NOT NULL, PRIMARY KEY(`address`) ) """.trimIndent() ) database.execSQL("INSERT INTO users SELECT address, username, publicKey, cryptoType, position FROM _users") database.execSQL("DROP TABLE _users") } }</ID>
    <ID>TopLevelPropertyNaming:Migrations.kt$val RemoveStakingRewardsTable_22_23 = object : Migration(22, 23) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL("DROP TABLE IF EXISTS `staking_rewards`") // totalReward nullable -&gt; not null database.execSQL("DROP TABLE IF EXISTS `total_reward`") database.execSQL( """ CREATE TABLE IF NOT EXISTS `total_reward` ( `accountAddress` TEXT NOT NULL, `totalReward` TEXT NOT NULL, PRIMARY KEY(`accountAddress`)) """.trimIndent() ) } }</ID>
    <ID>TopLevelPropertyNaming:NetworkModule.kt$private const val CACHE_SIZE = 50L * 1024L * 1024L // 50 MiB</ID>
    <ID>TopLevelPropertyNaming:NetworkModule.kt$private const val HTTP_CACHE = "http_cache"</ID>
    <ID>TopLevelPropertyNaming:NetworkModule.kt$private const val TIMEOUT_SECONDS = 60L</ID>
    <ID>TopLevelPropertyNaming:NewLimitedThreadPoolExecutor.kt$private const val CORE_POOL_SIZE = 1</ID>
    <ID>TopLevelPropertyNaming:NewLimitedThreadPoolExecutor.kt$private const val KEEP_ALIVE_TIME = 60L</ID>
    <ID>TopLevelPropertyNaming:NodesSettingsStorage.kt$private const val MANUAL_SELECT_NODES = "MANUAL_SELECT_NODES"</ID>
    <ID>TopLevelPropertyNaming:NumberFormatters.kt$const val DOLLAR_SIGN = "$"</ID>
    <ID>TopLevelPropertyNaming:NumberFormatters.kt$const val MAX_DECIMALS_8 = 8</ID>
    <ID>TopLevelPropertyNaming:NumberFormatters.kt$private const val DECIMAL_PATTERN_BASE = "#,##0"</ID>
    <ID>TopLevelPropertyNaming:NumberFormatters.kt$private const val MAX_DECIMALS_2 = 2</ID>
    <ID>TopLevelPropertyNaming:NumberFormatters.kt$private const val MAX_DECIMALS_3 = 3</ID>
    <ID>TopLevelPropertyNaming:NumberInput.kt$private const val decimalDelimiter = "."</ID>
    <ID>TopLevelPropertyNaming:OperationDao.kt$private const val ID_FILTER = "address = :address AND chainId = :chainId AND :chainAssetId IN (chainAssetId, targetAssetId)"</ID>
    <ID>TopLevelPropertyNaming:ParachainMetadataRemote.kt$const val FLOW_API_KEY = "apiKey"</ID>
    <ID>TopLevelPropertyNaming:ParachainMetadataRemote.kt$const val FLOW_API_URL = "apiUrl"</ID>
    <ID>TopLevelPropertyNaming:ParachainMetadataRemote.kt$const val FLOW_BONUS_RATE = "bonusRate"</ID>
    <ID>TopLevelPropertyNaming:ParachainMetadataRemote.kt$const val FLOW_BONUS_URL = "bonusUrl"</ID>
    <ID>TopLevelPropertyNaming:ParachainMetadataRemote.kt$const val FLOW_CROWDLOAN_INFO_URL = "crowdloanInfoUrl"</ID>
    <ID>TopLevelPropertyNaming:ParachainMetadataRemote.kt$const val FLOW_FEARLESS_REFERRAL = "fearlessReferral"</ID>
    <ID>TopLevelPropertyNaming:ParachainMetadataRemote.kt$const val FLOW_TERMS_URL = "termsUrl"</ID>
    <ID>TopLevelPropertyNaming:ParachainMetadataRemote.kt$const val FLOW_TOTAL_REWARD = "totalReward"</ID>
    <ID>TopLevelPropertyNaming:PlayMarketUris.kt$const val APP_PACKAGE = "jp.co.soramitsu.fearless"</ID>
    <ID>TopLevelPropertyNaming:PlayMarketUris.kt$const val PLAY_MARKET_APP_URI = "market://details?id=$APP_PACKAGE"</ID>
    <ID>TopLevelPropertyNaming:PlayMarketUris.kt$const val PLAY_MARKET_BROWSER_URI = "https://play.google.com/store/apps/details?id=$APP_PACKAGE"</ID>
    <ID>TopLevelPropertyNaming:ProfileViewModel.kt$private const val AVATAR_SIZE_DP = 32</ID>
    <ID>TopLevelPropertyNaming:RampProvider.kt$private const val RAMP_APP_LOGO = "https://raw.githubusercontent.com/soramitsu/fearless-Android/dff3ebbed4a125621732ee039f2bc74c74f5b58f/common/src/main/res/drawable-xxxhdpi/ic_wallet.png"</ID>
    <ID>TopLevelPropertyNaming:RampProvider.kt$private const val RAMP_APP_NAME = "Fearless Wallet"</ID>
    <ID>TopLevelPropertyNaming:ReceiveViewModel.kt$private const val QR_TEMP_IMAGE_NAME = "address.png"</ID>
    <ID>TopLevelPropertyNaming:RecommendationSettingsProviderFactory.kt$private const val SETTINGS_PROVIDER_KEY = "SETTINGS_PROVIDER_KEY"</ID>
    <ID>TopLevelPropertyNaming:RedeemFragment.kt$const val PAYLOAD_KEY = "PAYLOAD_KEY"</ID>
    <ID>TopLevelPropertyNaming:RemoveClusteringPostprocessor.kt$private const val MAX_PER_CLUSTER = 2</ID>
    <ID>TopLevelPropertyNaming:RewardDetailViewModel.kt$private const val ICON_SIZE_DP = 32</ID>
    <ID>TopLevelPropertyNaming:RuntimeFilesCache.kt$private const val METADATA_FILE_MASK = "metadata_%s"</ID>
    <ID>TopLevelPropertyNaming:RuntimeModule.kt$const val LOCAL_STORAGE_SOURCE = "LOCAL_STORAGE_SOURCE"</ID>
    <ID>TopLevelPropertyNaming:RuntimeModule.kt$const val REMOTE_STORAGE_SOURCE = "REMOTE_STORAGE_SOURCE"</ID>
    <ID>TopLevelPropertyNaming:RuntimeSyncService.kt$private const val LOG_TAG = "RuntimeSyncService"</ID>
    <ID>TopLevelPropertyNaming:RuntimeSyncServiceTest.kt$private const val TEST_TYPES = "Stub"</ID>
    <ID>TopLevelPropertyNaming:SearchCustomBlockProducerInteractor.kt$private const val ELECTED_COLLATORS_CACHE = "ELECTED_COLLATORS_CACHE"</ID>
    <ID>TopLevelPropertyNaming:SearchCustomBlockProducerInteractor.kt$private const val ELECTED_VALIDATORS_CACHE = "ELECTED_VALIDATORS_CACHE"</ID>
    <ID>TopLevelPropertyNaming:SecretStoreV1.kt$private const val PREFS_SECURITY_SOURCE_MASK = "security_source_%s"</ID>
    <ID>TopLevelPropertyNaming:SecretStoreV2.kt$private const val ACCESS_SECRETS = "ACCESS_SECRETS"</ID>
    <ID>TopLevelPropertyNaming:SecretStoreV2Test.kt$private const val META_ID = 1L</ID>
    <ID>TopLevelPropertyNaming:SelectBondMoreFragment.kt$const val PAYLOAD_KEY = "PAYLOAD_KEY"</ID>
    <ID>TopLevelPropertyNaming:SelectBondMoreViewModel.kt$private const val DEBOUNCE_DURATION_MILLIS = 500</ID>
    <ID>TopLevelPropertyNaming:SelectBondMoreViewModel.kt$private const val DEFAULT_AMOUNT = 1</ID>
    <ID>TopLevelPropertyNaming:SelectUnbondViewModel.kt$private const val DEBOUNCE_DURATION_MILLIS = 500</ID>
    <ID>TopLevelPropertyNaming:SelectUnbondViewModel.kt$private const val DEFAULT_AMOUNT = 1</ID>
    <ID>TopLevelPropertyNaming:SelectWalletViewModel.kt$private const val SUBSTRATE_BLOCKCHAIN_TYPE = 0</ID>
    <ID>TopLevelPropertyNaming:SelectedFiat.kt$private const val DEFAULT_SELECTED_FIAT = "usd"</ID>
    <ID>TopLevelPropertyNaming:SelectedFiat.kt$private const val SELECTED_FIAT_KEY = "selectedFiat"</ID>
    <ID>TopLevelPropertyNaming:SendSetupViewModel.kt$private const val RETRY_TIMES = 3L</ID>
    <ID>TopLevelPropertyNaming:SignBeaconTransactionFragment.kt$const val SIGN_PAYLOAD_KEY = "SIGN_PAYLOAD_KEY"</ID>
    <ID>TopLevelPropertyNaming:StakingRelayChainScenarioInteractor.kt$const val HOURS_IN_DAY = 24</ID>
    <ID>TopLevelPropertyNaming:StakingRelayChainScenarioInteractor.kt$val ERA_OFFSET = 1.toBigInteger()</ID>
    <ID>TopLevelPropertyNaming:StakingScenarioViewModel.kt$const val PERIOD_MONTH = 30</ID>
    <ID>TopLevelPropertyNaming:StakingScenarioViewModel.kt$const val PERIOD_YEAR = 365</ID>
    <ID>TopLevelPropertyNaming:StakingSharedState.kt$private const val STAKING_SHARED_STATE = "STAKING_CURRENT_ASSET_TYPE"</ID>
    <ID>TopLevelPropertyNaming:StakingViewModel.kt$private const val CURRENT_ICON_SIZE = 40</ID>
    <ID>TopLevelPropertyNaming:StorageDao.kt$private const val SELECT_FULL_KEY_QUERY = "SELECT * from storage WHERE chainId = :chainId AND storageKey = :fullKey"</ID>
    <ID>TopLevelPropertyNaming:StorageDao.kt$private const val SELECT_PREFIX_KEY_QUERY = "SELECT * from storage WHERE chainId = :chainId AND storageKey LIKE :keyPrefix || '%'"</ID>
    <ID>TopLevelPropertyNaming:TransactionDetailViewModel.kt$private const val ICON_SIZE_DP = 32</ID>
    <ID>TopLevelPropertyNaming:TransferCursorStorage.kt$// to distinguish between no cursor and null cursor introduce a separate value for `null` cursor. // Null value in preferences will correspond to `no cursor` state private const val NULL_CURSOR = "NULL_CURSOR"</ID>
    <ID>TopLevelPropertyNaming:TransferCursorStorage.kt$private const val TRANSACTIONS_CURSOR_KEY = "TRANSACTIONS_CURSOR_KEY"</ID>
    <ID>TopLevelPropertyNaming:TransferDetailFragment.kt$const val KEY_ASSET_PAYLOAD = "KEY_ASSET_PAYLOAD"</ID>
    <ID>TopLevelPropertyNaming:TransferDetailFragment.kt$const val KEY_TRANSACTION = "KEY_DRAFT"</ID>
    <ID>TopLevelPropertyNaming:UnbondingRequestsLimitValidation.kt$private const val UNLOCKING_LIMIT = 32</ID>
    <ID>TopLevelPropertyNaming:V2MigrationTest.kt$private const val DERIVATION_PATH = "//test"</ID>
    <ID>TopLevelPropertyNaming:V2MigrationTest.kt$private const val MNEMONIC_WORDS = "bottom drive obey lake curtain smoke basket hold race lonely fit walk"</ID>
    <ID>TopLevelPropertyNaming:ValidationSystems.kt$const val SYSTEM_MANAGE_STAKING_BOND_MORE = "ManageStakingBondMore"</ID>
    <ID>TopLevelPropertyNaming:ValidationSystems.kt$const val SYSTEM_MANAGE_STAKING_REBOND = "ManageStakingRebond"</ID>
    <ID>TopLevelPropertyNaming:ValidationSystems.kt$const val SYSTEM_MANAGE_STAKING_REDEEM = "ManageStakingRedeem"</ID>
    <ID>TopLevelPropertyNaming:ValidationSystems.kt$const val SYSTEM_MANAGE_STAKING_UNBOND = "ManageStakingUnbond"</ID>
    <ID>TopLevelPropertyNaming:Validator.kt$private const val ICON_DETAILS_SIZE_DP = 32</ID>
    <ID>TopLevelPropertyNaming:Validator.kt$private const val ICON_SIZE_DP = 24</ID>
    <ID>TopLevelPropertyNaming:Validator.kt$val PERCENT_MULTIPLIER = 100.toBigDecimal()</ID>
    <ID>TopLevelPropertyNaming:ValidatorPrefs.kt$private const val PERBILL_MANTISSA_SIZE = 9</ID>
    <ID>TopLevelPropertyNaming:ValidatorRecommendatorFactory.kt$private const val ELECTED_VALIDATORS_CACHE = "ELECTED_VALIDATORS_CACHE"</ID>
    <ID>TopLevelPropertyNaming:WalletExportFragment.kt$const val META_ID_KEY = "META_ID_KEY"</ID>
    <ID>TopLevelPropertyNaming:WalletInteractorImpl.kt$private const val HIDE_ZERO_BALANCES_PREFS_KEY = "hideZeroBalances"</ID>
    <ID>TopLevelPropertyNaming:WalletInteractorImpl.kt$private const val PREFS_SORA_CARD_HIDDEN_SESSIONS_COUNT = "prefs_sora_card_hidden_sessions_count"</ID>
    <ID>TopLevelPropertyNaming:WalletInteractorImpl.kt$private const val PREFS_WALLET_SELECTED_CHAIN_ID = "wallet_selected_chain_id"</ID>
    <ID>TopLevelPropertyNaming:WalletInteractorImpl.kt$private const val QR_PREFIX_SUBSTRATE = "substrate"</ID>
    <ID>TopLevelPropertyNaming:WalletInteractorImpl.kt$private const val SORA_CARD_HIDDEN_SESSIONS_LIMIT = 5</ID>
    <ID>TopLevelPropertyNaming:WelcomeViewModel.kt$private const val SUBSTRATE_BLOCKCHAIN_TYPE = 0</ID>
    <ID>UnderscoresInNumericLiterals:StakeInfoViewState.kt$10000L</ID>
    <ID>UnderscoresInNumericLiterals:StakingInfoItem.kt$123123L</ID>
    <ID>UnderscoresInNumericLiterals:SwapDetailContent.kt$1675834923575L</ID>
    <ID>UnnecessaryParentheses:AccountRepositoryImpl.kt$AccountRepositoryImpl$(chainId)</ID>
    <ID>UnnecessaryParentheses:AmountInput.kt$(state.tokenName.orEmpty())</ID>
    <ID>UnnecessaryParentheses:BalanceListViewModel.kt$BalanceListViewModel$(!assetManagedByUser &amp;&amp; isZeroBalance &amp;&amp; hideZeroBalancesEnabled)</ID>
    <ID>UnnecessaryParentheses:BeaconInteractor.kt$BeaconInteractor$(args["dest"].cast&lt;DictEnum.Entry&lt;ByteArray&gt;&gt;())</ID>
    <ID>UnnecessaryParentheses:BeaconInteractor.kt$BeaconInteractor$(if (chain?.isEthereumBased == true) account.ethereumPublicKey else account.substratePublicKey)</ID>
    <ID>UnnecessaryParentheses:BindDelegatorState.kt$(dynamicInstance.getList("delegations"))</ID>
    <ID>UnnecessaryParentheses:ChainSyncService.kt$ChainSyncService$(it.assets?.isNotEmpty() == true)</ID>
    <ID>UnnecessaryParentheses:ConfirmContributeFragment.kt$ConfirmContributeFragment$(argument&lt;ConfirmContributePayload&gt;(KEY_PAYLOAD).metadata)</ID>
    <ID>UnnecessaryParentheses:CreatePoolSetupViewModel.kt$CreatePoolSetupViewModel$(amountInPlanks + fee + existentialDeposit)</ID>
    <ID>UnnecessaryParentheses:CrossChainSetupViewModel.kt$CrossChainSetupViewModel$(allAmount * input.toBigDecimal())</ID>
    <ID>UnnecessaryParentheses:CrossChainTransfer.kt$CrossChainTransfer$(senderUtilityBalance - extraSpends &lt; utilityExistentialDeposit)</ID>
    <ID>UnnecessaryParentheses:CustomContributeViewModel.kt$CustomContributeViewModel$(payload.parachainMetadata.flow?.data)</ID>
    <ID>UnnecessaryParentheses:ExpandableLazyListNestedScrollConnection.kt$ExpandableLazyListNestedScrollConnection$(isListAtTheTop || isListScrolledToTheEnd)</ID>
    <ID>UnnecessaryParentheses:Extensions.kt$(totalSeconds % 3600)</ID>
    <ID>UnnecessaryParentheses:InfoTableItem.kt$(state.clickState as? TitleValueViewState.ClickState.Title)</ID>
    <ID>UnnecessaryParentheses:InfoTableItem.kt$(state.clickState as? TitleValueViewState.ClickState.Value)</ID>
    <ID>UnnecessaryParentheses:ManualRewardCalculator.kt$ManualRewardCalculator$((1 + dailyPercentage).toBigDecimal().pow(days))</ID>
    <ID>UnnecessaryParentheses:PoolUnstakeViewModel.kt$PoolUnstakeViewModel$(stakingPoolSharedStateProvider.requireManageState.stakedInPlanks - amount)</ID>
    <ID>UnnecessaryParentheses:RuntimeProvider.kt$RuntimeProvider$(runtimeSyncResult.metadataHash != null &amp;&amp; currentVersion.metadataHash != runtimeSyncResult.metadataHash)</ID>
    <ID>UnnecessaryParentheses:RuntimeProvider.kt$RuntimeProvider$(runtimeSyncResult.typesHash != null &amp;&amp; currentVersion.ownTypesHash != runtimeSyncResult.typesHash)</ID>
    <ID>UnnecessaryParentheses:SearchAssetsViewModel.kt$SearchAssetsViewModel$(!assetManagedByUser &amp;&amp; isZeroBalance &amp;&amp; hideZeroBalancesEnabled)</ID>
    <ID>UnnecessaryParentheses:SendSetupViewModel.kt$SendSetupViewModel$(allAmount * input.toBigDecimal())</ID>
    <ID>UnnecessaryParentheses:StakingParachainScenarioRepository.kt$(dynamicInstance.getList("delegations"))</ID>
    <ID>UnnecessaryParentheses:StakingParachainScenarioViewModel.kt$StakingParachainScenarioViewModel$(candidateInfo.lowestTopDelegationAmount - delegation.amount)</ID>
    <ID>UnnecessaryParentheses:StakingRelayChainScenarioRepository.kt$(currentEra - historyDepth)</ID>
    <ID>UnnecessaryParentheses:SubqueryHistorySource.kt$SubqueryHistorySource$(currencyIdType?.value as Alias)</ID>
    <ID>UnnecessaryParentheses:SwapTokensViewModel.kt$SwapTokensViewModel$(toTokenAmount - fee)</ID>
    <ID>UnnecessaryParentheses:SwapTokensViewModel.kt$SwapTokensViewModel$(tokenFromId to tokenToId)</ID>
    <ID>UnnecessaryParentheses:TernoaRewardCalculator.kt$TernoaRewardCalculator$((1 + dailyPercentage).toBigDecimal().pow(DAYS_IN_YEAR))</ID>
    <ID>UnnecessaryParentheses:TransactionHistoryProvider.kt$TransactionHistoryProvider$(PAGE_SIZE * currentPage)</ID>
    <ID>UnnecessaryParentheses:TransactionHistoryProvider.kt$TransactionHistoryProvider$(currentIndex / PAGE_SIZE)</ID>
    <ID>UnnecessaryParentheses:Transfer.kt$Transfer$(senderUtilityBalance - extraSpends &lt; utilityExistentialDeposit)</ID>
    <ID>UnnecessaryParenthesesBeforeTrailingLambda:CorneredInput.kt$()</ID>
    <ID>UnusedParameter:BaseException.kt$BaseException.Companion$errorCode: Int</ID>
    <ID>UnusedParameter:EnterBackupPasswordScreen.kt$activity: Activity</ID>
    <ID>UnusedParameter:Exposure.kt$runtime: RuntimeSnapshot</ID>
    <ID>UnusedParameter:FearlessException.kt$FearlessException.Companion$resourceManager: ResourceManager</ID>
    <ID>UnusedParameter:KaruraContributeInteractor.kt$KaruraContributeInteractor$amount: BigDecimal</ID>
    <ID>UnusedParameter:KaruraContributeInteractor.kt$KaruraContributeInteractor$referralCode: String</ID>
    <ID>UnusedParameter:MnemonicWords.kt$modifier: Modifier = Modifier</ID>
    <ID>UnusedParameter:OptionsWalletFragment.kt$OptionsWalletFragment$metaId: Long</ID>
    <ID>UnusedParameter:PayoutInteractor.kt$PayoutInteractor$accountAddress: String</ID>
    <ID>UnusedParameter:PullRefreshBox.kt$modifier: Modifier = Modifier</ID>
    <ID>UnusedParameter:RootViewModel.kt$RootViewModel$sideEffect: Updater.SideEffect</ID>
    <ID>UnusedParameter:SoraCard.kt$onClick: (() -&gt; Unit)</ID>
    <ID>UnusedParameter:StakingAssetInfo.kt$state: StakingAssetInfoViewState.Parachain</ID>
    <ID>UnusedParameter:StakingAssetInfo.kt$state: StakingAssetInfoViewState.RelayChain</ID>
    <ID>UnusedParameter:StakingFeatureModule.kt$StakingFeatureModule$validatorProvider: ValidatorProvider</ID>
    <ID>UnusedParameter:StakingUpdatersModule.kt$StakingUpdatersModule$historyDepthUpdater: HistoryDepthUpdater</ID>
    <ID>UnusedParameter:SubQueryValidatorSetFetcher.kt$SubQueryValidatorSetFetcher$historicalRange: List&lt;BigInteger&gt;</ID>
    <ID>UnusedParameter:SubQueryValidatorSetFetcher.kt$SubQueryValidatorSetFetcher$stakingUrl: String</ID>
    <ID>UnusedParameter:SubQueryValidatorSetFetcher.kt$SubQueryValidatorSetFetcher$stashAccountAddress: String</ID>
    <ID>UnusedParameter:SuccessFragment.kt$SuccessFragment.Companion$hasSuccessResult: Boolean = true</ID>
    <ID>UnusedParameter:Theme.kt$darkTheme: Boolean = isSystemInDarkTheme()</ID>
    <ID>UnusedParameter:Timer.kt$onFinish: (() -&gt; Unit)? = null</ID>
    <ID>UnusedParameter:WalletImportedScreen.kt$activity: Activity</ID>
    <ID>UnusedPrivateMember:BalanceListViewModel.kt$BalanceListViewModel$private fun mapKycStatus(kycStatus: String): String?</ID>
    <ID>UnusedPrivateMember:BeaconFragment.kt$BeaconFragment$private fun openExitDialog()</ID>
    <ID>UnusedPrivateMember:EstimateEarningView.kt$EstimateEarningView$private fun applyAttributes(attributeSet: AttributeSet)</ID>
    <ID>UnusedPrivateMember:ProfileViewModel.kt$ProfileViewModel$private fun mapKycStatus(kycStatus: String): String?</ID>
    <ID>UnusedPrivateMember:RecommendedCollatorsViewModel.kt$RecommendedCollatorsViewModel$private fun retractRecommended()</ID>
    <ID>UnusedPrivateMember:StakingPoolInteractor.kt$StakingPoolInteractor$@Deprecated("Manual calculating is deprecated", replaceWith = ReplaceWith("dataSource.getPendingRewards")) private suspend fun calculatePendingRewards(chain: Chain, poolMember: PoolMember, bondedPool: BondedPool, rewardPool: PoolRewards?): BigInteger</ID>
    <ID>UnusedPrivateMember:StakingRelayChainScenarioRepository.kt$StakingRelayChainScenarioRepository$private fun observeAccountNominations(chainId: ChainId, stashId: AccountId): Flow&lt;Nominations?&gt;</ID>
    <ID>UnusedPrivateMember:WalletRepositoryImpl.kt$WalletRepositoryImpl$private fun buildNetworkIssues(items: List&lt;AssetWithStatus&gt;): Set&lt;NetworkIssueItemState&gt;</ID>
    <ID>UnusedPrivateProperty:BaseBottomSheetDialogFragment.kt$BaseBottomSheetDialogFragment$@LayoutRes private val layoutRes: Int</ID>
    <ID>UnusedPrivateProperty:ConfirmSendViewModel.kt$ConfirmSendViewModel$private val walletConstants: WalletConstants</ID>
    <ID>UnusedPrivateProperty:CrossChainSetupViewModel.kt$CrossChainSetupViewModel$private val isInputAddressValidFlow = combine( addressInputFlow, chainAssetsManager.originChainIdFlow ) { addressInput, chainId -&gt; when (chainId) { null -&gt; false else -&gt; walletInteractor.validateSendAddress(chainId, addressInput) } }.stateIn(viewModelScope, SharingStarted.Eagerly, false)</ID>
    <ID>UnusedPrivateProperty:GiantsquidHistoryRequest.kt$GiantsquidHistoryRequest$limit: Int = 100</ID>
    <ID>UnusedPrivateProperty:GiantsquidHistoryRequest.kt$GiantsquidHistoryRequest$offset: Int = 0</ID>
    <ID>UnusedPrivateProperty:KaruraContributeInteractor.kt$KaruraContributeInteractor$private val accountRepository: AccountRepository</ID>
    <ID>UnusedPrivateProperty:MoonbeamContributeInteractor.kt$MoonbeamContributeInteractor$private val resourceManager: ResourceManager</ID>
    <ID>UnusedPrivateProperty:RecommendationSettingsProvider.kt$RecommendationSettingsProvider.Parachain$maxTopDelegationPerCandidate: Int</ID>
    <ID>UnusedPrivateProperty:RecommendedCollatorsViewModel.kt$RecommendedCollatorsViewModel$private val recommendedSettings by lazyAsync { recommendationSettingsProviderFactory.createParachain(router.currentStackEntryLifecycle).defaultSettings() }</ID>
    <ID>UnusedPrivateProperty:RootInteractor.kt$RootInteractor$private val preferences: Preferences</ID>
    <ID>UnusedPrivateProperty:SelectCustomCollatorsViewModel.kt$SelectCustomCollatorsViewModel$private val iconsCache: MutableMap&lt;String, AddressModel&gt; = mutableMapOf()</ID>
    <ID>UnusedPrivateProperty:SignBeaconTransactionViewModel.kt$SignBeaconTransactionViewModel$private val resourceManager: ResourceManager</ID>
    <ID>UnusedPrivateProperty:StakingPoolDataSource.kt$StakingPoolDataSource$private val chainRegistry: ChainRegistry</ID>
    <ID>UnusedPrivateProperty:StakingPoolDataSource.kt$StakingPoolDataSource$private val localStorage: StorageDataSource</ID>
    <ID>UnusedPrivateProperty:StakingPoolDataSource.kt$StakingPoolDataSource$private val walletConstants: WalletConstants</ID>
    <ID>UnusedPrivateProperty:SuccessViewModel.kt$SuccessViewModel$private val hasSuccessResult: Boolean = savedStateHandle[SuccessFragment.KEY_HAS_SUCCESS_RESULT] ?: true</ID>
    <ID>UnusedPrivateProperty:TransactionDetailViewModel.kt$TransactionDetailViewModel$private val interactor: WalletInteractor</ID>
    <ID>UnusedPrivateProperty:WalletInteractorImpl.kt$WalletInteractorImpl$private val xcmEntitiesFetcher: XcmEntitiesFetcher</ID>
    <ID>UseCheckOrError:BindingHelpers.kt$throw IllegalStateException("Binding is incompatible")</ID>
    <ID>UseCheckOrError:Error.kt$throw IllegalStateException("Sorting/Filtering not elected validator $accountIdHex")</ID>
    <ID>UseCheckOrError:Error.kt$throw IllegalStateException("Sorting/Filtering validator $accountIdHex with no prefs")</ID>
    <ID>UseCheckOrError:FileProviderImpl.kt$FileProviderImpl$throw IllegalStateException("Cache directory is unavailable")</ID>
    <ID>UseCheckOrError:Filters.kt$BlockProducerFilters.ValidatorFilter.NotOverSubscribedFilter$throw IllegalStateException("Filtering validator ${model.accountIdHex} with no prefs")</ID>
    <ID>UseCheckOrError:OperationMappers.kt$throw IllegalStateException("All of the known operation type fields were null")</ID>
    <ID>UseCheckOrError:PayoutRepository.kt$PayoutRepository$throw IllegalStateException("Cannot calculate payouts for ${stakingState::class.simpleName} state")</ID>
    <ID>UseCheckOrError:XcmInteractor.kt$XcmInteractor$throw IllegalStateException("No self address")</ID>
    <ID>UseIfInsteadOfWhen:AcalaBonusPayload.kt$AcalaBonusPayload$when { rewardRate == null || bonusRate == null -&gt; null else -&gt; amount * rewardRate * bonusRate }</ID>
    <ID>UseIfInsteadOfWhen:AcalaContributeInteractor.kt$AcalaContributeInteractor$when { payload.email.isNullOrEmpty() -&gt; null else -&gt; payload.email }</ID>
    <ID>UseIfInsteadOfWhen:AcalaContributeSubmitter.kt$AcalaContributeSubmitter$when { apiUrl == null || apiKey == null -&gt; Result.failure(Exception("Empty required parameters")) else -&gt; interactor.submitOffChain(payload, amount, apiUrl, apiKey) }</ID>
    <ID>UseIfInsteadOfWhen:AccountDataSourceImpl.kt$AccountDataSourceImpl$when (metaId) { null -&gt; getSelectedAccountSubstrateCryptoType() else -&gt; getMetaAccount(metaId).substrateCryptoType }</ID>
    <ID>UseIfInsteadOfWhen:AccountDetailsInteractor.kt$AccountDetailsInteractor$when { address == null || accountId == null -&gt; null else -&gt; AccountInChain.Projection(address, accountId) }</ID>
    <ID>UseIfInsteadOfWhen:AccountDetailsViewModel.kt$AccountDetailsViewModel$when { hasChainAccount -&gt; interactor.getChainAccountSecret(metaId, chainId).buildExportSourceTypes(isEthereumBased) else -&gt; interactor.getMetaAccountSecrets(metaId).buildExportSourceTypes(isEthereumBased) }</ID>
    <ID>UseIfInsteadOfWhen:AccountRepositoryImpl.kt$AccountRepositoryImpl$when { ethereumBased -&gt; BIP32JunctionDecoder.DEFAULT_DERIVATION_PATH else -&gt; substrateDerivationPath }</ID>
    <ID>UseIfInsteadOfWhen:AccountRepositoryImpl.kt$AccountRepositoryImpl$when { ethereumBased -&gt; CryptoType.ECDSA else -&gt; cryptoType }</ID>
    <ID>UseIfInsteadOfWhen:AccountRepositoryImpl.kt$AccountRepositoryImpl$when { ethereumBased -&gt; CryptoType.ECDSA else -&gt; mapEncryptionToCryptoType(importData.multiChainEncryption.encryptionType) }</ID>
    <ID>UseIfInsteadOfWhen:AccountRepositoryImpl.kt$AccountRepositoryImpl$when { ethereumBased -&gt; CryptoType.ECDSA else -&gt; selectedEncryptionType }</ID>
    <ID>UseIfInsteadOfWhen:AccountRepositoryImpl.kt$AccountRepositoryImpl$when { ethereumBased -&gt; EthereumKeypairFactory.createWithPrivateKey(importData.keypair.privateKey) else -&gt; importData.keypair }</ID>
    <ID>UseIfInsteadOfWhen:AccountRepositoryImpl.kt$AccountRepositoryImpl$when { ethereumBased -&gt; EthereumKeypairFactory.createWithPrivateKey(seedBytes) else -&gt; { val derivationPathOrNull = substrateDerivationPath.nullIfEmpty() val decodedDerivationPath = derivationPathOrNull?.let { SubstrateJunctionDecoder.decode(it) } SubstrateKeypairFactory.generate( mapCryptoTypeToEncryption(selectedEncryptionType), seedBytes, decodedDerivationPath?.junctions.orEmpty() ) } }</ID>
    <ID>UseIfInsteadOfWhen:AccountRepositoryImpl.kt$AccountRepositoryImpl$when { ethereumBased -&gt; ethereumDerivationPathOrDefault else -&gt; substrateDerivationPath }</ID>
    <ID>UseIfInsteadOfWhen:AccountRepositoryImpl.kt$AccountRepositoryImpl$when { ethereumBased -&gt; ethereumKeypair else -&gt; keys }</ID>
    <ID>UseIfInsteadOfWhen:AccountRepositoryImpl.kt$AccountRepositoryImpl$when { ethereumBased -&gt; ethereumSeed else -&gt; derivationResult.seed }</ID>
    <ID>UseIfInsteadOfWhen:AccountRepositoryImpl.kt$AccountRepositoryImpl$when { ethereumBased -&gt; publicKey.ethereumAddressFromPublicKey() else -&gt; publicKey.substrateAccountId() }</ID>
    <ID>UseIfInsteadOfWhen:ActionCell.kt$when { state.isEnabled -&gt; modifier.clickable(role = Role.Button, onClick = onClick) else -&gt; modifier }</ID>
    <ID>UseIfInsteadOfWhen:AddressExt.kt$when { length &lt;= symbolsCount * 2 + 1 -&gt; this else -&gt; "${take(symbolsCount)}...${takeLast(symbolsCount)}" }</ID>
    <ID>UseIfInsteadOfWhen:AddressIconGenerator.kt$when { isEthereumBased -&gt; createEthereumAddressIcon(accountAddress, sizeInDp) else -&gt; createAddressIcon(accountAddress, sizeInDp) }</ID>
    <ID>UseIfInsteadOfWhen:AddressInput.kt$when (isFocused.value) { true -&gt; colorAccentDark else -&gt; white24 }</ID>
    <ID>UseIfInsteadOfWhen:AmountInput.kt$when { state.isActive -&gt; { white } else -&gt; { black2 } }</ID>
    <ID>UseIfInsteadOfWhen:AppVersion.kt$AppVersion.Companion$when (versionText) { null -&gt; true else -&gt; { val appVersion = current() val checkVersion = fromString(versionText) !appVersion.before(checkVersion) } }</ID>
    <ID>UseIfInsteadOfWhen:AssetChainsBadge.kt$when { urls.size &gt; MAX_VISIBLE_ICONS -&gt; MAX_VISIBLE_ICONS - 1 else -&gt; urls.size }</ID>
    <ID>UseIfInsteadOfWhen:AssetModel.kt$AssetModel$when (minSupportedVersion) { null -&gt; true else -&gt; AppVersion.isSupported(minSupportedVersion) }</ID>
    <ID>UseIfInsteadOfWhen:AssetSelectViewModel.kt$AssetSelectViewModel$when { it.hasAccount -&gt; it.asset else -&gt; null }</ID>
    <ID>UseIfInsteadOfWhen:AstarBonusPayload.kt$AstarBonusPayload$when { rewardRate == null || bonusRate == null -&gt; null else -&gt; amount * rewardRate * bonusRate }</ID>
    <ID>UseIfInsteadOfWhen:AstarContributeViewState.kt$AstarContributeViewState$when { referral.isEmpty() -&gt; ApplyActionState.Unavailable(reason = resourceManager.getString(R.string.crowdloan_enter_referral_address)) else -&gt; ApplyActionState.Available }</ID>
    <ID>UseIfInsteadOfWhen:BackupMnemonicViewModel.kt$BackupMnemonicViewModel$when (payload.chainAccountData) { null -&gt; CreateExtras( payload.accountName, cryptoTypeModel.cryptoType, substrateDerivationPath, ethereumDerivationPath ) else -&gt; ConfirmMnemonicPayload.CreateChainExtras( payload.accountName, cryptoTypeModel.cryptoType, substrateDerivationPath, ethereumDerivationPath, payload.chainAccountData.chainId, payload.chainAccountData.metaId ) }</ID>
    <ID>UseIfInsteadOfWhen:BalanceDetailViewModel.kt$BalanceDetailViewModel$when { it.hasAccount -&gt; it.asset else -&gt; null }</ID>
    <ID>UseIfInsteadOfWhen:BalanceListViewModel.kt$BalanceListViewModel$when (hasFreeKycAttempt) { false -&gt; SoraCardCommonVerification.NoFreeAttempt else -&gt; SoraCardCommonVerification.Rejected }</ID>
    <ID>UseIfInsteadOfWhen:BalanceListViewModel.kt$BalanceListViewModel$when (kycStatus) { SoraCardCommonVerification.Rejected -&gt; { val hasFreeKycAttempt = kycRepository.hasFreeKycAttempt(soraCardInfo.accessToken).getOrNull() when (hasFreeKycAttempt) { false -&gt; SoraCardCommonVerification.NoFreeAttempt else -&gt; SoraCardCommonVerification.Rejected } } else -&gt; kycStatus }</ID>
    <ID>UseIfInsteadOfWhen:BalanceListViewModel.kt$BalanceListViewModel$when { BuildConfig.DEBUG -&gt; SoraCardEnvironmentType.TEST else -&gt; SoraCardEnvironmentType.PRODUCTION }</ID>
    <ID>UseIfInsteadOfWhen:BalanceListViewModel.kt$BalanceListViewModel$when { it.hasAccount -&gt; it.asset else -&gt; null }</ID>
    <ID>UseIfInsteadOfWhen:BeaconInteractor.kt$BeaconInteractor$when { call.isTransfer() -&gt; { SignableOperation.Transfer( module = moduleName, call = functionName, rawData = rawDataSerialized, amount = bindNumber(args["value"]), destination = address, args = args ) } else -&gt; SignableOperation.Other(moduleName, functionName, args, rawDataSerialized) }</ID>
    <ID>UseIfInsteadOfWhen:BeaconStateMachine.kt$BeaconStateMachine$when (state) { is State.AwaitingInitialize -&gt; { sideEffect(SideEffect.AskPermissionsApproval(event.request)) State.AwaitingPermissionsApproval(event.request, state.dAppMetadata) } else -&gt; state }</ID>
    <ID>UseIfInsteadOfWhen:BeaconStateMachine.kt$BeaconStateMachine$when (state) { is State.AwaitingPermissionsApproval -&gt; { sideEffect(SideEffect.RespondApprovedPermissions(state.request)) State.Connected(state.dAppMetadata) } else -&gt; state }</ID>
    <ID>UseIfInsteadOfWhen:BeaconStateMachine.kt$BeaconStateMachine$when (state) { is State.AwaitingPermissionsApproval -&gt; { sideEffect(SideEffect.RespondDeclinedPermissions(state.request)) State.Finished } else -&gt; state }</ID>
    <ID>UseIfInsteadOfWhen:BeaconStateMachine.kt$BeaconStateMachine$when (state) { is State.AwaitingSigningApproval -&gt; { sideEffect(SideEffect.RespondApprovedSign(state.awaitingRequest)) State.Connected(state.dAppMetadata) } else -&gt; state }</ID>
    <ID>UseIfInsteadOfWhen:BeaconStateMachine.kt$BeaconStateMachine$when (state) { is State.AwaitingSigningApproval -&gt; { sideEffect(SideEffect.RespondDeclinedSign(state.awaitingRequest)) State.Connected(state.dAppMetadata) } else -&gt; state }</ID>
    <ID>UseIfInsteadOfWhen:BeaconStateMachine.kt$BeaconStateMachine$when (state) { is State.Connected -&gt; { sideEffect(SideEffect.AskSignApproval(event.request, state.dAppMetadata)) State.AwaitingSigningApproval(event.request, state.dAppMetadata) } else -&gt; state }</ID>
    <ID>UseIfInsteadOfWhen:BlockExplorerUrlBuilder.kt$BlockExplorerUrlBuilder$when (nameLowercase) { in types -&gt; true else -&gt; null }</ID>
    <ID>UseIfInsteadOfWhen:BuyMixinProvider.kt$BuyMixinProvider$when (val asset = chainRegistry.getAsset(chainId, chainAssetId)) { null -&gt; false else -&gt; buyTokenRegistry.availableProviders(asset).isNotEmpty() }</ID>
    <ID>UseIfInsteadOfWhen:Chain.kt$when (filter) { null -&gt; true else -&gt; filter[chain.id]?.contains(asset.id) ?: false }</ID>
    <ID>UseIfInsteadOfWhen:Chain.kt$when (val activeNode = localVersion.nodes.firstOrNull { it.isActive }) { null -&gt; this else -&gt; copy(nodes = nodes.map { it.copy(isActive = it.url == activeNode.url &amp;&amp; it.name == activeNode.name) }) }</ID>
    <ID>UseIfInsteadOfWhen:ChainAccountsAdapter.kt$ChainAccountHolder$when { item.hasAccount -&gt; R.color.white else -&gt; R.color.black2 }</ID>
    <ID>UseIfInsteadOfWhen:ConfirmBondMoreViewModel.kt$ConfirmBondMoreViewModel$when { payload.overrideFinishAction != null -&gt; payload.overrideFinishAction.invoke(router) else -&gt; router.returnToStakingBalance() }</ID>
    <ID>UseIfInsteadOfWhen:ConfirmContributeFragment.kt$ConfirmContributeFragment$when { bonus == null || bonus &lt;= BigDecimal.ZERO -&gt; R.color.white else -&gt; R.color.colorAccent }</ID>
    <ID>UseIfInsteadOfWhen:ConfirmContributeViewModel.kt$ConfirmContributeViewModel$when (payload.metadata?.isAcala) { true -&gt; { val bonusUrl = payload.metadata.flow?.data?.getString(FLOW_BONUS_URL) ?: payload.metadata.website openBrowserEvent.postValue(Event(bonusUrl)) } else -&gt; Unit }</ID>
    <ID>UseIfInsteadOfWhen:ConfirmContributeViewModel.kt$ConfirmContributeViewModel$when { isAcalaLcDot -&gt; 1.toBigDecimal() else -&gt; null }</ID>
    <ID>UseIfInsteadOfWhen:ConfirmContributeViewModel.kt$ConfirmContributeViewModel$when { payload.metadata?.isMoonbeam != true || ethAddress == null -&gt; Unit else -&gt; contributionInteractor.saveEthAddress( paraId = payload.paraId, address = selectedAddressModelFlow.first().address, etheriumAddress = ethAddress.first ) }</ID>
    <ID>UseIfInsteadOfWhen:ConfirmSendViewModel.kt$ConfirmSendViewModel$when (phishingType) { PhishingType.EXCHANGE -&gt; resourceManager.getString(R.string.exchange_alert_message) else -&gt; resourceManager.getString(R.string.scam_alert_message_format, symbol) }</ID>
    <ID>UseIfInsteadOfWhen:ConnectionPool.kt$ConnectionPool$when { chain.nodes.size &gt; 1 -&gt; NetworkIssueType.Node else -&gt; NetworkIssueType.Network }</ID>
    <ID>UseIfInsteadOfWhen:CrossChainConfirmViewModel.kt$CrossChainConfirmViewModel$when (phishingType) { PhishingType.EXCHANGE -&gt; resourceManager.getString(R.string.exchange_alert_message) else -&gt; resourceManager.getString(R.string.scam_alert_message_format, symbol) }</ID>
    <ID>UseIfInsteadOfWhen:CrossChainSetupViewModel.kt$CrossChainSetupViewModel$when (chainId) { null -&gt; false else -&gt; walletInteractor.validateSendAddress(chainId, addressInput) }</ID>
    <ID>UseIfInsteadOfWhen:CrossChainSetupViewModel.kt$CrossChainSetupViewModel$when { asset.token.configuration.isUtility -&gt; tipAmount else -&gt; BigDecimal.ZERO }</ID>
    <ID>UseIfInsteadOfWhen:CrossChainSetupViewModel.kt$CrossChainSetupViewModel$when { asset.token.configuration.isUtility.not() -&gt; BigDecimal.ZERO else -&gt; walletInteractor.getTransferFee(transfer).feeAmount }</ID>
    <ID>UseIfInsteadOfWhen:CrowdloanContributeViewModel.kt$CrowdloanContributeViewModel$when { !isPrivacyAccepted -&gt; ApplyActionState.Unavailable(reason = resourceManager.getString(R.string.crowdloan_agreement_required)) else -&gt; ApplyActionState.Available }</ID>
    <ID>UseIfInsteadOfWhen:CrowdloanContributeViewModel.kt$CrowdloanContributeViewModel$when { isAcala -&gt; (router.latestCustomBonus as? AcalaBonusPayload)?.apply { this.contributionType = contributionType } else -&gt; router.latestCustomBonus }</ID>
    <ID>UseIfInsteadOfWhen:CrowdloanContributeViewModel.kt$CrowdloanContributeViewModel$when { isAcala -&gt; contributionTypeFlow.map { index -&gt; AcalaContributionType.values().find { it.ordinal == index } }.firstOrNull() ?: return@launch else -&gt; DirectDOT }</ID>
    <ID>UseIfInsteadOfWhen:CrowdloanContributeViewModel.kt$CrowdloanContributeViewModel$when { metadata.isAcala -&gt; null else -&gt; { val estimatedReward = rewardRate?.let { amount * it } estimatedReward?.formatCrypto(metadata.token) } }</ID>
    <ID>UseIfInsteadOfWhen:CrowdloanContributeViewModel.kt$CrowdloanContributeViewModel$when { parachainMetadata?.isAcala == true &amp;&amp; contributionTypeFlow.firstOrNull() == LcDOT.ordinal -&gt; { 1.toBigDecimal() } else -&gt; null }</ID>
    <ID>UseIfInsteadOfWhen:CrowdloanContributeViewModel.kt$CrowdloanContributeViewModel$when { payload.parachainMetadata?.isAcala == true -&gt; { crowdloanFlow.distinctUntilChanged().map { crowdloan -&gt; val totalDotContributed = assetFlow.firstOrNull()?.token?.amountFromPlanks(crowdloan.fundInfo.raised) val totalReward = payload.parachainMetadata.flow?.data?.getString(FLOW_TOTAL_REWARD)?.toBigDecimalOrNull() ?: 170_000_000.toBigDecimal() totalReward.divide(totalDotContributed, 10, RoundingMode.HALF_UP) } } else -&gt; flow { emit(payload.parachainMetadata?.rewardRate) } }</ID>
    <ID>UseIfInsteadOfWhen:CrowdloanViewModel.kt$CrowdloanViewModel$when (crowdloan.parachainMetadata?.isInterlay) { true -&gt; accountUseCase.selectedAccountFlow().firstOrNull()?.address?.toByteArray()?.blake2b256()?.toHexString(true) else -&gt; null }</ID>
    <ID>UseIfInsteadOfWhen:CrowdloanViewModel.kt$CrowdloanViewModel$when { apiUrl == null || apiKey == null -&gt; Result.success(false) else -&gt; interactor.checkRemark(apiUrl, apiKey) }</ID>
    <ID>UseIfInsteadOfWhen:CrowdloanViewModel.kt$CrowdloanViewModel$when { isSigned -&gt; CONTRIBUTE else -&gt; TERMS }</ID>
    <ID>UseIfInsteadOfWhen:DropDown.kt$when { state.clickableMode == DropDownViewState.ClickableMode.DisableOnInactive &amp;&amp; state.isActive.not() -&gt; Modifier else -&gt; Modifier.clickableWithNoIndication(onClick) }</ID>
    <ID>UseIfInsteadOfWhen:ExportExt.kt$when (isEthereumBased) { true -&gt; get(MetaAccountSecrets.EthereumKeypair)?.run { options += ExportSource.Seed } else -&gt; get(MetaAccountSecrets.Seed)?.run { options += ExportSource.Seed } }</ID>
    <ID>UseIfInsteadOfWhen:ExportJsonPasswordFragment.kt$ExportJsonPasswordFragment$when { viewModel.isExportWallet -&gt; R.string.export_wallet else -&gt; R.string.account_export }</ID>
    <ID>UseIfInsteadOfWhen:ExportJsonPasswordViewModel.kt$ExportJsonPasswordViewModel$when (chainForEthereumExport) { null -&gt; Result.failure(IllegalArgumentException("No chain specified")) else -&gt; interactor.generateRestoreJson(payload.metaId, chainForEthereumExport, password) }</ID>
    <ID>UseIfInsteadOfWhen:ExportJsonPasswordViewModel.kt$ExportJsonPasswordViewModel$when { payload.isExportWallet -&gt; polkadotChainId else -&gt; payload.chainId }</ID>
    <ID>UseIfInsteadOfWhen:ExportJsonPasswordViewModel.kt$ExportJsonPasswordViewModel$when { payload.isExportWallet -&gt; { val supportedEthChains = chainRegistry.currentChains.first().filter { chain -&gt; chain.isSupported &amp;&amp; chain.isEthereumBased &amp;&amp; accountInteractor.getMetaAccount(payload.metaId).hasChainAccount(chain.id).not() }.sortedWith(compareBy&lt;Chain&gt; { it.isTestNet }.thenBy { it.name }) supportedEthChains.getOrNull(0)?.id } else -&gt; payload.chainId }</ID>
    <ID>UseIfInsteadOfWhen:ExportMnemonicFragment.kt$ExportMnemonicFragment$when { viewModel.isExportFromWallet -&gt; R.string.export_wallet else -&gt; R.string.account_export }</ID>
    <ID>UseIfInsteadOfWhen:ExportMnemonicViewModel.kt$ExportMnemonicViewModel$when { isChainAccount -&gt; chainSecretLiveData.map { it?.get(ChainAccountSecrets.Entropy)?.let { MnemonicCreator.fromEntropy(it) } ?: throw IllegalArgumentException("Mnemonic not specified") } else -&gt; secretLiveData.map { it?.get(MetaAccountSecrets.Entropy)?.let { MnemonicCreator.fromEntropy(it) } ?: throw IllegalArgumentException("Mnemonic not specified") } }</ID>
    <ID>UseIfInsteadOfWhen:ExportMnemonicViewModel.kt$ExportMnemonicViewModel$when { isChainAccount == null || isEthereum == null -&gt; null else -&gt; isChainAccount to isEthereum }</ID>
    <ID>UseIfInsteadOfWhen:ExportSeedFragment.kt$ExportSeedFragment$when { viewModel.isExportFromWallet -&gt; R.string.export_wallet else -&gt; R.string.account_export }</ID>
    <ID>UseIfInsteadOfWhen:ExportSeedViewModel.kt$ExportSeedViewModel$when { isChainAccount -&gt; chainSecretLiveData.map { ComponentHolder( listOf( if (isEthereum.value == false) it?.get(ChainAccountSecrets.Seed) else null, if (isEthereum.value == true) it?.get(ChainAccountSecrets.Keypair)?.get(KeyPairSchema.PrivateKey) else null ).map { seed -&gt; seed?.toHexString(withPrefix = true) } ) } else -&gt; secretLiveData.map { ComponentHolder( listOf( it?.get(MetaAccountSecrets.Seed) ?: seedFromEntropy(it), it?.get(MetaAccountSecrets.EthereumKeypair)?.get(KeyPairSchema.PrivateKey) ).map { seed -&gt; seed?.toHexString(withPrefix = true) } ) } }</ID>
    <ID>UseIfInsteadOfWhen:ExportSeedViewModel.kt$ExportSeedViewModel$when { isChainAccount -&gt; chainSecretLiveData.map { it?.get(ChainAccountSecrets.DerivationPath) } else -&gt; secretLiveData.map { it?.get(MetaAccountSecrets.SubstrateDerivationPath) } }</ID>
    <ID>UseIfInsteadOfWhen:FundInfo.kt$when { dynamicInstance.get&lt;BigInteger&gt;("fundIndex") != null -&gt; bindNumber(dynamicInstance["fundIndex"]) else -&gt; bindNumber(dynamicInstance["trieIndex"]) }</ID>
    <ID>UseIfInsteadOfWhen:GetSoraCardViewModel.kt$GetSoraCardViewModel$when { BuildConfig.DEBUG -&gt; SoraCardEnvironmentType.TEST else -&gt; SoraCardEnvironmentType.PRODUCTION }</ID>
    <ID>UseIfInsteadOfWhen:HistoryRepository.kt$HistoryRepository$when { limit == null || limit &lt; 0 -&gt; nonNullList else -&gt; nonNullList.subList(0, Integer.min(limit, nonNullList.size)) }</ID>
    <ID>UseIfInsteadOfWhen:ImportAccountType.kt$when { isEthereumBased -&gt; ImportAccountType.Ethereum else -&gt; ImportAccountType.Substrate }</ID>
    <ID>UseIfInsteadOfWhen:ImportAccountViewModel.kt$ImportAccountViewModel$when (interactor.getChain(chainCreateAccountData.chainId).isEthereumBased) { true -&gt; ethJson else -&gt; substrateJson }</ID>
    <ID>UseIfInsteadOfWhen:ImportAccountViewModel.kt$ImportAccountViewModel$when (interactor.getChain(chainCreateAccountData.chainId).isEthereumBased) { true -&gt; ethSeed else -&gt; substrateSeed }</ID>
    <ID>UseIfInsteadOfWhen:ImportAccountViewModel.kt$ImportAccountViewModel$when (throwable) { is AccountAlreadyExistsException -&gt; ImportError( titleRes = R.string.account_add_already_exists_message, messageRes = R.string.account_error_try_another_one ) else -&gt; ImportError() }</ID>
    <ID>UseIfInsteadOfWhen:ImportAccountViewModel.kt$ImportAccountViewModel$when (val chainCreateAccountData = chainCreateAccountData.value) { null -&gt; import(sourceType, name, substrateDerivationPath, ethereumDerivationPath, cryptoType, withEth) else -&gt; importForChain( sourceType, name, substrateDerivationPath, ethereumDerivationPath, cryptoType, chainCreateAccountData ) }</ID>
    <ID>UseIfInsteadOfWhen:ImportSourceModel.kt$MnemonicImportSource$when (throwable) { is Bip39Exception -&gt; ImportError( titleRes = R.string.import_mnemonic_invalid_title, messageRes = R.string.mnemonic_error_try_another_one ) else -&gt; null }</ID>
    <ID>UseIfInsteadOfWhen:KoltinExt.kt$when (this) { null -&gt; BigDecimal.ZERO else -&gt; this }</ID>
    <ID>UseIfInsteadOfWhen:KoltinExt.kt$when (this) { null -&gt; BigInteger.ZERO else -&gt; this }</ID>
    <ID>UseIfInsteadOfWhen:ManualRewardCalculator.kt$ManualRewardCalculator$when { prices.isEmpty() -&gt; 0.0 else -&gt; prices.median() }</ID>
    <ID>UseIfInsteadOfWhen:MapFundInfoToCrowdloan.kt$when (minContribution) { BigInteger.ZERO -&gt; fundInfo.raised &lt; fundInfo.cap else -&gt; fundInfo.raised + minContribution &lt;= fundInfo.cap }</ID>
    <ID>UseIfInsteadOfWhen:MetaAccount.kt$when { hasChainAccount(chain.id) -&gt; chain.addressOf(chainAccounts.getValue(chain.id).accountId) else -&gt; null }</ID>
    <ID>UseIfInsteadOfWhen:MoonbeamBonusPayload.kt$MoonbeamBonusPayload$when { rewardRate == null || bonusRate == null -&gt; null else -&gt; amount * rewardRate * bonusRate }</ID>
    <ID>UseIfInsteadOfWhen:MoonbeamContributeViewState.kt$MoonbeamContributeViewState$when { privacyAccepted -&gt; ApplyActionState.Available else -&gt; ApplyActionState.Unavailable(reason = resourceManager.getString(R.string.common_continue)) }</ID>
    <ID>UseIfInsteadOfWhen:NetworkApiCreator.kt$NetworkApiCreator$when (customFieldNamingPolicy) { null -&gt; Gson() else -&gt; GsonBuilder() .setFieldNamingPolicy(customFieldNamingPolicy) .create() }</ID>
    <ID>UseIfInsteadOfWhen:NodesAdapter.kt$NodeHolder$when { isAuto || getEditMode() -&gt; Unit else -&gt; handler.checkClicked(nodeModel) }</ID>
    <ID>UseIfInsteadOfWhen:NodesSettingsStorage.kt$NodesSettingsStorage$when { isAuto -&gt; nodesWithManualSelect.remove(chainId) else -&gt; nodesWithManualSelect.add(chainId) }</ID>
    <ID>UseIfInsteadOfWhen:NumberFormatters.kt$when (symbol) { null -&gt; cryptoDetailAbbreviatedFormatter.format(this) else -&gt; cryptoDetailAbbreviatedFormatter.format(this).formatWithTokenSymbol(symbol) }</ID>
    <ID>UseIfInsteadOfWhen:NumberFormatters.kt$when (symbol) { null -&gt; cryptoShortAbbreviatedFormatter.format(this) else -&gt; cryptoShortAbbreviatedFormatter.format(this).formatWithTokenSymbol(symbol) }</ID>
    <ID>UseIfInsteadOfWhen:OperationMappers.kt$when (it) { call -&gt; when { module == Modules.BALANCES &amp;&amp; formatted(call) == "Transfer" -&gt; "Transfer fee" module == Modules.CROWDLOAN &amp;&amp; formatted(call) == "Contribute" -&gt; "Contribute fee" else -&gt; formatted(call) } else -&gt; formatted(it) }</ID>
    <ID>UseIfInsteadOfWhen:OperationMappers.kt$when (operationType.status) { Operation.Status.COMPLETED -&gt; resourceManager.getString(R.string.polkaswap_confirmation_swapped_stub) else -&gt; resourceManager.getString(statusAppearance.labelRes) }</ID>
    <ID>UseIfInsteadOfWhen:PayloadGenerator.kt$when (val payload = payloads.first()) { is List&lt;*&gt; -&gt; { val diffChecks = payload as List&lt;DiffCheck&lt;T, *&gt;&gt; diffChecks.forEach(onDiffCheck) } else -&gt; onUnknownPayload?.invoke(payload) }</ID>
    <ID>UseIfInsteadOfWhen:PhishingModel.kt$PhishingModel$when (type) { PhishingType.SCAM -&gt; errorRed else -&gt; warningOrange }</ID>
    <ID>UseIfInsteadOfWhen:PinCodeViewModel.kt$PinCodeViewModel$when (pinCodeAction.delayedNavigation) { null -&gt; router.back() else -&gt; router.openAfterPinCode(pinCodeAction.delayedNavigation) }</ID>
    <ID>UseIfInsteadOfWhen:PoolInfoOptionsViewModel.kt$PoolInfoOptionsViewModel$when (option) { PoolInfoOptionsViewState.Option.Edit -&gt; openEditPoolScreen() else -&gt; Unit // do nothing - only one option available now }</ID>
    <ID>UseIfInsteadOfWhen:PoolInfoViewModel.kt$PoolInfoViewModel$when { poolInfo.state == NominationPoolState.Open &amp;&amp; hasValidators.not() -&gt; NominationPoolState.HasNoValidators else -&gt; poolInfo.state }</ID>
    <ID>UseIfInsteadOfWhen:ProfileViewModel.kt$ProfileViewModel$when { BuildConfig.DEBUG -&gt; SoraCardEnvironmentType.TEST else -&gt; SoraCardEnvironmentType.PRODUCTION }</ID>
    <ID>UseIfInsteadOfWhen:ReferralContributeView.kt$ReferralContributeView$when { bonus == null || bonus &lt;= BigDecimal.ZERO -&gt; R.color.white else -&gt; R.color.colorAccent }</ID>
    <ID>UseIfInsteadOfWhen:ReferralContributeView.kt$ReferralContributeView$when { enabled -&gt; R.string.apply_fearless_wallet_bonus else -&gt; R.string.applied_fearless_wallet_bonus }</ID>
    <ID>UseIfInsteadOfWhen:ReferralContributeView.kt$ReferralContributeView$when { viewState.isAstar || viewState.isAcala -&gt; R.string.apply_fearless_referal_wallet else -&gt; when { enabled -&gt; R.string.apply_fearless_wallet_bonus else -&gt; R.string.applied_fearless_wallet_bonus } }</ID>
    <ID>UseIfInsteadOfWhen:ReferralContributeViewState.kt$ReferralContributeViewState$when { isAcala -&gt; enteredEmailFlow.combine(emailAgreedFlow) { input, agreed -&gt; when { !agreed -&gt; true EmailValidator.isValid(input) &amp;&amp; agreed -&gt; true else -&gt; false } } else -&gt; flow { emit(true) } }</ID>
    <ID>UseIfInsteadOfWhen:ReferralContributeViewState.kt$ReferralContributeViewState$when { it is InterlayBonusPayload -&gt; "5%" else -&gt; { val bonus = it.calculateBonus(customContributePayload.amount) val tokenName = customContributePayload.parachainMetadata.token bonus?.formatCryptoDetail(tokenName) } }</ID>
    <ID>UseIfInsteadOfWhen:ReferralContributeViewState.kt$ReferralContributeViewState$when { it is InterlayBonusPayload -&gt; customContributePayload.amount else -&gt; it.calculateBonus(customContributePayload.amount) }</ID>
    <ID>UseIfInsteadOfWhen:RewardDetailFragment.kt$RewardDetailFragment$when { operation.isReward -&gt; R.color.green else -&gt; R.color.white }</ID>
    <ID>UseIfInsteadOfWhen:RootActivity.kt$RootActivity$when { show -&gt; showBadConnectionView() else -&gt; hideBadConnectionView() }</ID>
    <ID>UseIfInsteadOfWhen:RuntimeProvider.kt$RuntimeProvider$when (it) { ChainInfoNotInCacheException -&gt; runtimeSyncService.cacheNotFound(chainId) else -&gt; it.printStackTrace() }</ID>
    <ID>UseIfInsteadOfWhen:SegmentedButtonView.kt$SegmentedButtonView$when (selectedIndex) { 0 -&gt; R.id.optionOne else -&gt; R.id.optionTwo }</ID>
    <ID>UseIfInsteadOfWhen:SelectBondMoreViewModel.kt$SelectBondMoreViewModel$when { payload.overrideFinishAction != null -&gt; payload.overrideFinishAction.invoke(router) else -&gt; router.returnToStakingBalance() }</ID>
    <ID>UseIfInsteadOfWhen:SelectValidatorsViewModel.kt$when (sortingCaption) { BlockProducersSorting.ValidatorSorting.ValidatorOwnStakeSorting -&gt; ownStake else -&gt; electedInfo?.apy.orZero().fractionToPercentage().formatAsPercentage() }</ID>
    <ID>UseIfInsteadOfWhen:SelectValidatorsViewModel.kt$when (sortingCaption) { BlockProducersSorting.ValidatorSorting.ValidatorOwnStakeSorting -&gt; resourceManager.getString(R.string.staking_filter_title_own_stake) else -&gt; resourceManager.getString(R.string.staking_rewards_apy) }</ID>
    <ID>UseIfInsteadOfWhen:SendSetupViewModel.kt$SendSetupViewModel$when (chain) { null -&gt; false else -&gt; walletInteractor.validateSendAddress(chain.id, address) }</ID>
    <ID>UseIfInsteadOfWhen:SendSetupViewModel.kt$SendSetupViewModel$when (chainId) { null -&gt; false else -&gt; walletInteractor.validateSendAddress(chainId, addressInput) }</ID>
    <ID>UseIfInsteadOfWhen:SendSetupViewModel.kt$SendSetupViewModel$when { addressChains.size == 1 -&gt; { val chain = addressChains[0] when { chain.assets.size == 1 -&gt; sharedState.update(chain.id, chain.assets[0].id) else -&gt; router.openSelectChainAsset(chain.id) } } else -&gt; router.openSelectChain( filterChainIds = addressChains.map { it.id }, chooserMode = false, currencyId = tokenCurrencyId, showAllChains = false ) }</ID>
    <ID>UseIfInsteadOfWhen:SendSetupViewModel.kt$SendSetupViewModel$when { asset.token.configuration.isUtility -&gt; tipAmount else -&gt; BigDecimal.ZERO }</ID>
    <ID>UseIfInsteadOfWhen:SendSetupViewModel.kt$SendSetupViewModel$when { asset.token.configuration.isUtility.not() -&gt; BigDecimal.ZERO else -&gt; walletInteractor.getTransferFee(transfer).feeAmount }</ID>
    <ID>UseIfInsteadOfWhen:SendSetupViewModel.kt$SendSetupViewModel$when { chain.assets.size == 1 -&gt; sharedState.update(chain.id, chain.assets[0].id) else -&gt; router.openSelectChainAsset(chain.id) }</ID>
    <ID>UseIfInsteadOfWhen:SendSetupViewModel.kt$SendSetupViewModel$when { chainId == null || assetId == null -&gt; null else -&gt; AssetPayload(chainId, assetId) }</ID>
    <ID>UseIfInsteadOfWhen:SendSetupViewModel.kt$SendSetupViewModel$when { isAddressValid -&gt; address else -&gt; currentAccountAddress(asset.token.configuration.chainId) ?: return@combine null }</ID>
    <ID>UseIfInsteadOfWhen:SendSetupViewModel.kt$SendSetupViewModel$when { isAddressValid.not() -&gt; R.drawable.ic_address_placeholder else -&gt; addressIconGenerator.createAddressIcon(chain?.isEthereumBased == true, address, AddressIconGenerator.SIZE_BIG) }</ID>
    <ID>UseIfInsteadOfWhen:SetupStakingSharedState.kt$SetupStakingProcess.ReadyToSubmit$when (payload) { // is Payload.Collators -&gt; SelectBlockProducersStep.Payload.Collators //todo is Payload.Parachain -&gt; SelectBlockProducersStep.Payload.Parachain(payload.amount, payload.currentAccountAddress) else -&gt; error("Wrong payload type") }</ID>
    <ID>UseIfInsteadOfWhen:SetupStakingSharedState.kt$SetupStakingProcess.SelectBlockProducersStep.Validators$when (payload) { is Payload.Full -&gt; SetupStep.Stash(payload.amount) else -&gt; Initial(StakingType.RELAYCHAIN) }</ID>
    <ID>UseIfInsteadOfWhen:SoraRewardCalculator.kt$SoraRewardCalculator$when { prices.isEmpty() -&gt; 0.0 else -&gt; prices.median() }</ID>
    <ID>UseIfInsteadOfWhen:StakingParachainScenarioRepository.kt$StakingParachainScenarioRepository$when (it) { null -&gt; StakingState.Parachain.None(chain, accountId) else -&gt; StakingState.Parachain.Delegator(chain, accountId, it.toDelegations(), it.total.toBigDecimal()) }</ID>
    <ID>UseIfInsteadOfWhen:StakingPoolInteractor.kt$StakingPoolInteractor$when (it) { null -&gt; StakingState.Pool.None(chain, accountId) else -&gt; StakingState.Pool.Member(chain, accountId, it) }</ID>
    <ID>UseIfInsteadOfWhen:StakingPoolInteractor.kt$StakingPoolInteractor$when { bondedPoolState == NominationPoolState.Open &amp;&amp; hasValidators.not() -&gt; NominationPoolState.HasNoValidators else -&gt; NominationPoolState.from(bondedPool.state.name) }</ID>
    <ID>UseIfInsteadOfWhen:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$when { isValidatorActive(validatorState.stashId, it.eraStakers) -&gt; ValidatorStatus.ACTIVE else -&gt; ValidatorStatus.INACTIVE }</ID>
    <ID>UseIfInsteadOfWhen:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$when { utilityAsset != null &amp;&amp; it.asset.bondedInPlanks.orZero() &lt; minimumStake( eraStakers, stakingRelayChainScenarioRepository.minimumNominatorBond(utilityAsset) ) -&gt; { NominatorStatus.Inactive.Reason.MIN_STAKE } else -&gt; NominatorStatus.Inactive.Reason.NO_ACTIVE_VALIDATOR }</ID>
    <ID>UseIfInsteadOfWhen:StakingViewStateOld.kt$StakeViewState$when (val state = stakeSummaryFlow.replayCache.firstOrNull()) { is LoadingState.Loaded&lt;StakeSummaryModel&lt;S&gt;&gt; -&gt; state.data else -&gt; null }</ID>
    <ID>UseIfInsteadOfWhen:SubsquidHistorySource.kt$SubsquidHistorySource$when { this in filters -&gt; true else -&gt; null }</ID>
    <ID>UseIfInsteadOfWhen:SwipeBox.kt$when { swipeableState.offset.value &gt; eliminationDistance -&gt; 0f else -&gt; (eliminationDistance - swipeableState.offset.value) / eliminationDistance }</ID>
    <ID>UseIfInsteadOfWhen:SwipeBox.kt$when { swipeableState.offset.value.absoluteValue &gt; eliminationDistance -&gt; 0f else -&gt; (eliminationDistance - swipeableState.offset.value.absoluteValue) / eliminationDistance }</ID>
    <ID>UseIfInsteadOfWhen:SwipeableAssetListItem.kt$when { asset.isHidden -&gt; ActionItemType.SHOW else -&gt; ActionItemType.HIDE }</ID>
    <ID>UseIfInsteadOfWhen:TernoaRewardCalculator.kt$TernoaRewardCalculator$when { prices.isEmpty() -&gt; 0.0 else -&gt; prices.average() }</ID>
    <ID>UseIfInsteadOfWhen:TokenRepositoryImpl.kt$TokenRepositoryImpl$when (val priceId = chainAsset.priceId) { null -&gt; flowOf { combineAssetWithPrices(chainAsset, null) } else -&gt; tokenPriceDao.observeTokenPrice(priceId).map { combineAssetWithPrices(chainAsset, it) } }</ID>
    <ID>UseIfInsteadOfWhen:TotalBalanceUseCaseImpl.kt$TotalBalanceUseCaseImpl$when (metaId) { null -&gt; accountRepository.getSelectedMetaAccount() else -&gt; accountRepository.getMetaAccount(metaId) }</ID>
    <ID>UseIfInsteadOfWhen:TotalBalanceUseCaseImpl.kt$TotalBalanceUseCaseImpl$when (metaId) { null -&gt; accountRepository.selectedMetaAccountFlow() else -&gt; flow { emit(accountRepository.getMetaAccount(metaId)) } }</ID>
    <ID>UseIfInsteadOfWhen:TotalBalanceUseCaseImpl.kt$TotalBalanceUseCaseImpl$when { balance.isZero() -&gt; BigDecimal.ZERO else -&gt; balanceChange.divide(balance, RoundingMode.HALF_UP).fractionToPercentage() }</ID>
    <ID>UseIfInsteadOfWhen:TransactionHistoryProvider.kt$TransactionHistoryProvider$when (throwable) { is HistoryNotSupportedException -&gt; resourceManager.getString(R.string.wallet_transaction_history_unsupported_message) else -&gt; resourceManager.getString(R.string.wallet_transaction_history_error_message) }</ID>
    <ID>UseIfInsteadOfWhen:TransactionItem.kt$when (item.assetIconUrl) { null -&gt; item.operationIcon else -&gt; getImageRequest(LocalContext.current, item.assetIconUrl) }</ID>
    <ID>UseIfInsteadOfWhen:ValidationFailure.kt$when (reason) { is UnbondValidationFailure.BondedWillCrossExistential -&gt; payload.copy( amount = reason.willBeUnbonded, shouldChillBeforeUnbond = payload.collatorAddress == null ) else -&gt; payload }</ID>
    <ID>UseIfInsteadOfWhen:WalletScreen.kt$when { data.soraCardState?.visible != true -&gt; null else -&gt; { { SoraCardItem( state = data.soraCardState, onClose = callback::soraCardClose, onClick = callback::soraCardClicked ) } } }</ID>
    <ID>UseIfInsteadOfWhen:WelcomeViewModel.kt$WelcomeViewModel$when (isImport) { true -&gt; router.openImportAccountSkipWelcome(this) else -&gt; router.openCreateAccountSkipWelcome(this) }</ID>
    <ID>UseIfInsteadOfWhen:WssSubstrateSource.kt$WssSubstrateSource$when (typeRegistry["Address"]) { // this logic was added to support Moonbeam/Moonriver chains; todo separate assets in json like orml is FixedByteArray -&gt; accountId else -&gt; DictEnum.Entry( name = "Id", value = accountId ) }</ID>
    <ID>UseIfInsteadOfWhen:kotlin-runtimepermissions-coroutines.kt$when (activity) { null -&gt; continuation.resumeWithException(NoActivityException()) else -&gt; RuntimePermission.askPermission(this) .request(permissions.toList()) .onResponse { result -&gt; if (!resumed) { resumed = true when { result.isAccepted -&gt; continuation.resume(result) else -&gt; continuation.resumeWithException(PermissionException(result)) } } } .ask() }</ID>
    <ID>UseIfInsteadOfWhen:kotlin-runtimepermissions-coroutines.kt$when { result.isAccepted -&gt; continuation.resume(result) else -&gt; continuation.resumeWithException(PermissionException(result)) }</ID>
    <ID>UseRequire:BlockExplorerUrlBuilder.kt$BlockExplorerUrlBuilder$throw IllegalArgumentException("Wrong baseUrl format")</ID>
    <ID>UseRequire:LockBottomSheetBehavior.kt$LockBottomSheetBehavior.Companion$throw IllegalArgumentException("The view is not a child of CoordinatorLayout")</ID>
    <ID>UseRequire:PrimaryButton.kt$PrimaryButton$throw IllegalArgumentException("You must call prepareForProgress() first!")</ID>
    <ID>UtilityClassWithPublicConstructor:EmailValidator.kt$EmailValidator</ID>
    <ID>VariableNaming:ChainSyncServiceTest.kt$ChainSyncServiceTest$private val LOCAL_CHAIN = mapChainToChainLocal(REMOTE_CHAIN.toChain())</ID>
    <ID>VariableNaming:ChainSyncServiceTest.kt$ChainSyncServiceTest$private val REMOTE_CHAIN = ChainRemote( chainId = "0x00", name = "Test", assets = listOf( ChainAssetRemote( id = "test", name = "test", precision = 10, priceId = "test", icon = "test", symbol = "test", staking = null, purchaseProviders = null, isUtility = null, type = null, currencyId = null, existentialDeposit = null, color = null, isNative = null ) ), nodes = listOf( ChainNodeRemote( url = "url", name = "test" ) ), icon = "test", addressPrefix = 0, options = emptyList(), parentId = null, externalApi = null, minSupportedVersion = null )</ID>
    <ID>VariableNaming:StakingViewStateOld.kt$WelcomeViewState$protected val _showRewardEstimationEvent = MutableLiveData&lt;Event&lt;StakingRewardEstimationBottomSheet.Payload&gt;&gt;()</ID>
    <ID>VariableNaming:V2MigrationTest.kt$V2MigrationTest$private val TEST_DB = "migration-test"</ID>
    <ID>WildcardImport:ExampleInstrumentedTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:ExampleUnitTest.kt$import org.junit.Assert.*</ID>
    <ID>Wrapping:Asset.kt$Asset$it - miscFrozenInPlanks.orZero().max(feeFrozenInPlanks.orZero())</ID>
    <ID>Wrapping:BalanceListViewModel.kt$BalanceListViewModel$if (it.isTestNet) ChainEcosystem.STANDALONE else it.ecosystem()</ID>
    <ID>Wrapping:BalancesUpdateSystem.kt$BalancesUpdateSystem$bulkRetriever.queryKeys(socketService, storageKeyToMapId.keys.toList())</ID>
    <ID>Wrapping:Chain.kt$it.isActive</ID>
    <ID>Wrapping:CollatorProvider.kt$CollatorProvider$it.contentEquals(candidate)</ID>
    <ID>Wrapping:CollatorsAdapter.kt$CollatorViewHolder$containerView.findViewById(R.id.itemValidatorScoringPrimary)</ID>
    <ID>Wrapping:CollatorsAdapter.kt$CollatorViewHolder$containerView.findViewById(R.id.itemValidatorScoringSecondary)</ID>
    <ID>Wrapping:ConfirmPoolRedeemViewModel.kt$ConfirmPoolRedeemViewModel$stakingPoolInteractor.estimateRedeemFee(requireNotNull(poolSharedStateProvider.mainState.get()?.address))</ID>
    <ID>Wrapping:ConfirmPoolUnbondViewModel.kt$ConfirmPoolUnbondViewModel$stakingPoolInteractor.estimateUnstakeFee(poolSharedStateProvider.requireMainState.requireAddress, requireNotNull(it))</ID>
    <ID>Wrapping:ConfirmSendViewModel.kt$ConfirmSendViewModel$TitleValueViewState.ClickState.Value(R.drawable.ic_alert_16, ConfirmSendViewState.CODE_WARNING_CLICK)</ID>
    <ID>Wrapping:CrossChainConfirmViewModel.kt$CrossChainConfirmViewModel$TitleValueViewState.ClickState.Value(R.drawable.ic_alert_16, CrossChainConfirmViewState.CODE_WARNING_CLICK)</ID>
    <ID>Wrapping:CrowdloanAdapter.kt$CrowdloanChildHolder$item.referral?.let(handler::copyReferralClicked)</ID>
    <ID>Wrapping:CrowdloanContributeViewModel.kt$CrowdloanContributeViewModel$it.ordinal == index</ID>
    <ID>Wrapping:CurrentValidatorsInteractor.kt$CurrentValidatorsInteractor$groupSize(Status.Active::class) + groupSize(Status.Elected::class)</ID>
    <ID>Wrapping:CustomBlockProducersAdapter.kt$CustomBlockProducersAdapter$itemHandler.blockProducerClicked(getItem(it))</ID>
    <ID>Wrapping:CustomBlockProducersAdapter.kt$CustomBlockProducersAdapter$itemHandler.blockProducerInfoClicked(getItem(it))</ID>
    <ID>Wrapping:EditPoolConfirmViewModel.kt$EditPoolConfirmViewModel$TitleValueViewState(resourceManager.getString(R.string.pool_staking_pool_name), it)</ID>
    <ID>Wrapping:ExportMnemonicViewModel.kt$ExportMnemonicViewModel$MnemonicCreator.fromEntropy(it)</ID>
    <ID>Wrapping:Ext.kt$it.capitalize()</ID>
    <ID>Wrapping:Mappers.kt$Gson().fromJson&lt;List&lt;String&gt;&gt;(it, object : TypeToken&lt;List&lt;String&gt;&gt;() {}.type)</ID>
    <ID>Wrapping:Navigator.kt$Navigator$navController?.getBackStackEntry(it)</ID>
    <ID>Wrapping:OperationMappers.kt$it.paramName == "amount"</ID>
    <ID>Wrapping:OperationMappers.kt$it.paramName == "liquidityProviderFee"</ID>
    <ID>Wrapping:PayoutRepository.kt$PayoutRepository$bindStakingLedger(it, runtime)</ID>
    <ID>Wrapping:PoolBondMoreViewModel.kt$PoolBondMoreViewModel$stakingPoolSharedStateProvider.manageState.set(it)</ID>
    <ID>Wrapping:PoolInfoViewModel.kt$PoolInfoViewModel$requireNotNull(it).copy(selectedValidators = validators)</ID>
    <ID>Wrapping:PoolRedeemViewModel.kt$PoolRedeemViewModel$stakingPoolInteractor.estimateRedeemFee(requireNotNull(stakingPoolSharedStateProvider.mainState.get()?.address))</ID>
    <ID>Wrapping:PoolUnstakeViewModel.kt$PoolUnstakeViewModel$it.token.amountFromPlanks(stakingPoolSharedStateProvider.requireManageState.stakedInPlanks)</ID>
    <ID>Wrapping:PoolUnstakeViewModel.kt$PoolUnstakeViewModel$stakingPoolSharedStateProvider.manageState.set(it)</ID>
    <ID>Wrapping:Reward.kt$resourceManager.getString(it, gainFormatted)</ID>
    <ID>Wrapping:RewardCalculatorFactory.kt$RewardCalculatorFactory$asset.amountFromPlanks(it).toDouble()</ID>
    <ID>Wrapping:SearchAssetsViewModel.kt$SearchAssetsViewModel$if (it.isTestNet) ChainEcosystem.STANDALONE else it.ecosystem()</ID>
    <ID>Wrapping:SelectCustomCollatorsViewModel.kt$SelectCustomCollatorsViewModel$it.customEnabledFilters.isNotEmpty() || it.postProcessors.isNotEmpty()</ID>
    <ID>Wrapping:SelectCustomValidatorsViewModel.kt$SelectCustomValidatorsViewModel$it.customEnabledFilters.isNotEmpty() || it.postProcessors.isNotEmpty()</ID>
    <ID>Wrapping:SelectRewardDestinationViewModel.kt$SelectRewardDestinationViewModel$it.token.configuration.staking == Asset.StakingType.RELAYCHAIN</ID>
    <ID>Wrapping:SelectRewardDestinationViewModel.kt$SelectRewardDestinationViewModel$rewardCalculatorFactory.create(interactor.currentAssetFlow().first().token.configuration)</ID>
    <ID>Wrapping:SelectValidatorsViewModel.kt$SelectValidatorsViewModel$validatorRecommendatorFactory.create(router.currentStackEntryLifecycle)</ID>
    <ID>Wrapping:SettingsSortingAdapter.kt$SettingsSortingViewHolder$onCheckListener(adapterPosition)</ID>
    <ID>Wrapping:StakingAssetSelector.kt$StakingAssetSelector$it.token.configuration.id == selection.chainAssetId</ID>
    <ID>Wrapping:StakingInteractor.kt$StakingInteractor$walletRepository.getAsset(stashMetaAccount.id, stashId, configuration, null)?.availableForStaking</ID>
    <ID>Wrapping:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$stakingParachainScenarioRepository.getAtStakeOfCollator(chainId, collatorId, getCurrentRound(chainId).getOrThrow().current)</ID>
    <ID>Wrapping:StakingParachainScenarioInteractor.kt$StakingParachainScenarioInteractor$stakingParachainScenarioRepository.getStaked(chainId, getCurrentRound(chainId).getOrThrow().current)</ID>
    <ID>Wrapping:StakingPoolViewModel.kt$StakingPoolViewModel$TitleValueViewState(it, returns.monthly.amount.nullIfEmpty(), returns.monthly.fiatAmount)</ID>
    <ID>Wrapping:StakingPoolViewModel.kt$StakingPoolViewModel$TitleValueViewState(it, returns.yearly.amount.nullIfEmpty(), returns.yearly.fiatAmount)</ID>
    <ID>Wrapping:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$it.asset.staking == StakingType.RELAYCHAIN</ID>
    <ID>Wrapping:StakingRelayChainScenarioInteractor.kt$StakingRelayChainScenarioInteractor$stakingRelayChainScenarioRepository.minimumNominatorBond(it)</ID>
    <ID>Wrapping:StakingViewStateOld.kt$DelegatorViewState$it + leaveCandidatesDelayInRounds</ID>
    <ID>Wrapping:StakingViewStateOld.kt$DelegatorViewState$it.token.configuration.staking == CoreAsset.StakingType.PARACHAIN</ID>
    <ID>Wrapping:StakingViewStateOld.kt$RelaychainWelcomeViewState$it.token.configuration.chainId</ID>
    <ID>Wrapping:StakingViewStateOld.kt$RelaychainWelcomeViewState$it.token.configuration.staking == CoreAsset.StakingType.RELAYCHAIN</ID>
    <ID>Wrapping:StakingViewStateOld.kt$RelaychainWelcomeViewState$rewardCalculatorFactory.create(currentAssetFlow.first().token.configuration)</ID>
    <ID>Wrapping:StakingViewStateOld.kt$StakingPoolWelcomeViewState$it.token.configuration.chainId</ID>
    <ID>Wrapping:StakingViewStateOld.kt$StakingPoolWelcomeViewState$it.token.configuration.staking == CoreAsset.StakingType.RELAYCHAIN</ID>
    <ID>Wrapping:StakingViewStateOld.kt$StakingPoolWelcomeViewState$rewardCalculatorFactory.create(currentAssetFlow.first().token.configuration)</ID>
    <ID>Wrapping:StakingViewStateOld.kt$StashNoneViewState$relayChainScenarioInteractor.observeStashSummary(stashState).shareIn(scope, SharingStarted.Eagerly, replay = 1)</ID>
    <ID>Wrapping:StakingViewStateOld.kt$ValidatorViewState$relayChainScenarioInteractor.observeValidatorSummary(validatorState).shareIn(scope, SharingStarted.Eagerly, replay = 1)</ID>
    <ID>Wrapping:StakingViewStateOld.kt$WelcomeViewState$it.toBigDecimalOrNull() ?: BigDecimal.ZERO</ID>
    <ID>Wrapping:SubqueryRewardCalculator.kt$SubqueryRewardCalculator$stakingApi.getLastRoundId(stakingUrl, StakingLastRoundIdRequest()).data.rounds.nodes.firstOrNull()?.id?.toIntOrNull()</ID>
    <ID>Wrapping:SwapTokensViewModel.kt$SwapTokensViewModel$it &gt;= BigDecimal.ZERO</ID>
    <ID>Wrapping:SwapTokensViewModel.kt$SwapTokensViewModel$polkaswapInteractor.getAvailableDexes()</ID>
    <ID>Wrapping:TitleValue.kt$TitleToValue(state = it, titleColor = green, modifier = modifier, testTag = testTag)</ID>
    <ID>Wrapping:UnbondingsAdapter.kt$UnbondingsHolder$context.getString(it)</ID>
    <ID>Wrapping:ValidateTransferUseCaseImpl.kt$ValidateTransferUseCaseImpl$substrateSource.getTotalBalance(it, recipientAccountId)</ID>
  </CurrentIssues>
</SmellBaseline>
